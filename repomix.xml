This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document. The content has been processed where comments have been removed, line numbers have been added.
Generated by Repomix on: 2025-02-14T19:23:25.162Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: _docs/**, sightline/sightline/Assets.xcassets/**, firebase/**, sightline.xcodeproj/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Line numbers have been added to the beginning of each line
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
sightline/
  sightline/
    Models/
      CaptureMode.swift
      Content.swift
      Event.swift
      FilterCategory.swift
      LandmarkInfo.swift
      Neighborhood.swift
      Place.swift
    Preview Content/
      Preview Assets.xcassets/
        Contents.json
    Services/
      Content/
        ContentService.swift
      Neighborhood/
        NeighborhoodService.swift
      Place/
        PlaceService.swift
      AuthService.swift
      FirestoreError.swift
      FirestoreService.swift
      FirestoreService+TestData.swift
      LandmarkDetectionService.swift
      ServiceContainer.swift
      VideoPlayerManager.swift
      VideoReviewService.swift
    sightline.xcdatamodeld/
      sightline.xcdatamodel/
        contents
      .xccurrentversion
    State/
      AppState.swift
    Stores/
      AppStore.swift
      LandmarkDetectionStore.swift
      ProfileStore.swift
      Store.swift
    Views/
      Components/
        AdaptiveColorButton.swift
        FloatingMenuButton.swift
        ScanningAnimation.swift
        ScanningTransitionView.swift
      ContentFeed/
        Components/
          CategorySelectorView.swift
          NeighborhoodSelectorView.swift
        ContentFeedView.swift
        ContentItemView.swift
        EmptyNeighborhoodState.swift
        VerticalFeedView.swift
      Profile/
        AuthView.swift
        ProfileView.swift
        UserProfileView.swift
      CameraView.swift
      LandmarkDetailView.swift
      MainTabView.swift
      NeighborhoodUnlockedView.swift
      PlaceDetailView.swift
      SplashView.swift
      VideoCaptureView.swift
    DebugGalleryView.swift
    LandmarkDetection.swift
    sightlineApp.swift
  sightline.xcodeproj/
    xcuserdata/
      chrissutton.xcuserdatad/
        xcdebugger/
          Breakpoints_v2.xcbkptlist
        xcschemes/
          xcschememanagement.plist
  sightlineTests/
    sightlineTests.swift
  sightlineUITests/
    sightlineUITests.swift
    sightlineUITestsLaunchTests.swift
.gitignore
.markdownlint.json
.repomixignore
readme.md
repomix.config.json
xml-extractor.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="sightline/sightline/Models/CaptureMode.swift">
1: enum CaptureMode {
2:     case regular
3:     case placeReview(placeId: String)
4: 
5: }
</file>

<file path="sightline/sightline/Models/Content.swift">
  1: import FirebaseFirestore
  2: 
  3: struct Content: Identifiable, Codable, Equatable {
  4:     let id: String
  5:     let placeIds: [String]
  6:     let eventIds: [String]?
  7:     let neighborhoodId: String
  8:     let authorId: String
  9: 
 10: 
 11:     var videoUrl: String
 12:     let thumbnailUrl: String
 13: 
 14: 
 15:     let caption: String
 16:     let tags: [FilterCategory]
 17: 
 18: 
 19:     let likes: Int
 20:     let views: Int
 21: 
 22: 
 23:     let createdAt: Timestamp
 24:     let updatedAt: Timestamp
 25: 
 26: 
 27:     var processingStatus: ProcessingStatus
 28:     var transcription: String?
 29:     var moderationResults: ModerationResults?
 30:     var processingError: ProcessingError?
 31: 
 32: 
 33:     static func == (lhs: Content, rhs: Content) -> Bool {
 34:         lhs.id == rhs.id &&
 35:         lhs.placeIds == rhs.placeIds &&
 36:         lhs.eventIds == rhs.eventIds &&
 37:         lhs.neighborhoodId == rhs.neighborhoodId &&
 38:         lhs.authorId == rhs.authorId &&
 39:         lhs.videoUrl == rhs.videoUrl &&
 40:         lhs.thumbnailUrl == rhs.thumbnailUrl &&
 41:         lhs.caption == rhs.caption &&
 42:         lhs.tags == rhs.tags &&
 43:         lhs.likes == rhs.likes &&
 44:         lhs.views == rhs.views &&
 45:         lhs.processingStatus == rhs.processingStatus &&
 46:         lhs.transcription == rhs.transcription &&
 47:         lhs.moderationResults == rhs.moderationResults &&
 48:         lhs.processingError == rhs.processingError
 49:     }
 50: 
 51:     init(
 52:         id: String,
 53:         placeIds: [String],
 54:         eventIds: [String]? = nil,
 55:         neighborhoodId: String,
 56:         authorId: String,
 57:         videoUrl: String,
 58:         thumbnailUrl: String,
 59:         caption: String,
 60:         tags: [FilterCategory],
 61:         likes: Int,
 62:         views: Int,
 63:         createdAt: Timestamp = Timestamp(),
 64:         updatedAt: Timestamp = Timestamp(),
 65:         processingStatus: ProcessingStatus,
 66:         transcription: String? = nil,
 67:         moderationResults: ModerationResults? = nil,
 68:         processingError: ProcessingError? = nil
 69:     ) {
 70:         self.id = id
 71:         self.placeIds = placeIds
 72:         self.eventIds = eventIds
 73:         self.neighborhoodId = neighborhoodId
 74:         self.authorId = authorId
 75:         self.videoUrl = videoUrl
 76:         self.thumbnailUrl = thumbnailUrl
 77:         self.caption = caption
 78:         self.tags = tags
 79:         self.likes = likes
 80:         self.views = views
 81:         self.createdAt = createdAt
 82:         self.updatedAt = updatedAt
 83:         self.processingStatus = processingStatus
 84:         self.transcription = transcription
 85:         self.moderationResults = moderationResults
 86:         self.processingError = processingError
 87:     }
 88: }
 89: 
 90: enum ProcessingStatus: String, Codable {
 91:     case uploading
 92:     case transcribing
 93:     case moderating
 94:     case tagging
 95:     case complete
 96:     case rejected
 97: }
 98: 
 99: struct ModerationResults: Codable, Equatable {
100:     let flagged: Bool
101:     let categories: [String: Bool]
102:     let categoryScores: [String: Double]
103: }
104: 
105: struct ProcessingError: Codable, Equatable {
106:     let stage: String
107:     let message: String
108:     let timestamp: Date
109: }
</file>

<file path="sightline/sightline/Models/Event.swift">
 1: import FirebaseFirestore
 2: 
 3: struct Event: Identifiable, Codable {
 4:     let id: String
 5:     let placeId: String
 6:     let name: String
 7:     let description: String?
 8:     let startTime: Timestamp
 9:     let endTime: Timestamp?
10:     let tags: [FilterCategory]
11:     let thumbnailUrl: String?
12:     let createdAt: Timestamp
13:     let updatedAt: Timestamp
14: 
15:     init(
16:         id: String,
17:         placeId: String,
18:         name: String,
19:         description: String? = nil,
20:         startTime: Timestamp,
21:         endTime: Timestamp? = nil,
22:         tags: [FilterCategory] = [],
23:         thumbnailUrl: String? = nil,
24:         createdAt: Timestamp = Timestamp(),
25:         updatedAt: Timestamp = Timestamp()
26:     ) {
27:         self.id = id
28:         self.placeId = placeId
29:         self.name = name
30:         self.description = description
31:         self.startTime = startTime
32:         self.endTime = endTime
33:         self.tags = tags
34:         self.thumbnailUrl = thumbnailUrl
35:         self.createdAt = createdAt
36:         self.updatedAt = updatedAt
37:     }
38: }
</file>

<file path="sightline/sightline/Models/FilterCategory.swift">
 1: enum FilterCategory: String, Codable, CaseIterable, Identifiable {
 2:     case restaurant
 3:     case drinks
 4:     case events
 5:     case music
 6:     case art
 7:     case outdoors
 8:     case shopping
 9:     case coffee
10: 
11:     var id: String { rawValue }
12: }
</file>

<file path="sightline/sightline/Models/LandmarkInfo.swift">
 1: import Foundation
 2: import FirebaseFirestore
 3: import CoreLocation
 4: 
 5: 
 6: struct LandmarkInfo: Identifiable {
 7:     let id = UUID()
 8:     let name: String
 9:     let latitude: Double?
10:     let longitude: Double?
11:     let neighborhood: Neighborhood?
12: 
13:     init(name: String,
14:          latitude: Double? = nil,
15:          longitude: Double? = nil,
16:          neighborhood: Neighborhood? = nil) {
17:         self.name = name
18:         self.latitude = latitude
19:         self.longitude = longitude
20:         self.neighborhood = neighborhood
21:     }
22: }
23: 
24: 
25: struct LandmarkLocation: Identifiable {
26:     let id = UUID()
27:     let name: String
28:     let coordinate: CLLocationCoordinate2D
29: }
</file>

<file path="sightline/sightline/Models/Neighborhood.swift">
 1: import FirebaseFirestore
 2: 
 3: struct Neighborhood: Codable, Identifiable, Equatable {
 4:     @DocumentID var id: String?
 5:     let name: String
 6:     let description: String?
 7:     let imageUrl: String?
 8:     let bounds: GeoBounds
 9:     let landmarks: [Landmark]?
10: 
11:     struct GeoBounds: Codable {
12:         struct Point: Codable {
13:             let lat: Double
14:             let lng: Double
15:         }
16:         let northeast: Point
17:         let southwest: Point
18:     }
19: 
20:     struct Landmark: Codable {
21:         let location: GeoPoint
22:         let mid: String
23:         let name: String
24:     }
25: 
26:     static func == (lhs: Neighborhood, rhs: Neighborhood) -> Bool {
27:         return lhs.id == rhs.id
28:     }
29: }
</file>

<file path="sightline/sightline/Models/Place.swift">
 1: import FirebaseFirestore
 2: 
 3: struct Place: Identifiable, Codable {
 4:     let id: String
 5:     let name: String
 6:     let primaryCategory: FilterCategory
 7:     let tags: [FilterCategory]
 8: 
 9: 
10:     let rating: Double
11:     let reviewCount: Int
12:     let coordinates: GeoPoint
13:     let neighborhoodId: String
14:     let address: String
15:     let description: String?
16:     let thumbnailUrl: String?
17:     let details: [String: String]
18:     let createdAt: Timestamp
19:     let updatedAt: Timestamp
20: 
21:     init(
22:         id: String,
23:         name: String,
24:         primaryCategory: FilterCategory,
25:         tags: [FilterCategory],
26:         rating: Double,
27:         reviewCount: Int,
28:         coordinates: GeoPoint,
29:         neighborhoodId: String,
30:         address: String,
31:         description: String? = nil,
32:         thumbnailUrl: String?,
33:         details: [String: String],
34:         createdAt: Timestamp = Timestamp(),
35:         updatedAt: Timestamp = Timestamp()
36:     ) {
37:         self.id = id
38:         self.name = name
39:         self.primaryCategory = primaryCategory
40:         self.tags = tags
41:         self.rating = rating
42:         self.reviewCount = reviewCount
43:         self.coordinates = coordinates
44:         self.neighborhoodId = neighborhoodId
45:         self.address = address
46:         self.description = description
47:         self.thumbnailUrl = thumbnailUrl
48:         self.details = details
49:         self.createdAt = createdAt
50:         self.updatedAt = updatedAt
51:     }
52: }
</file>

<file path="sightline/sightline/Preview Content/Preview Assets.xcassets/Contents.json">
1: {
2:   "info" : {
3:     "author" : "xcode",
4:     "version" : 1
5:   }
6: }
</file>

<file path="sightline/sightline/Services/Content/ContentService.swift">
 1: import Foundation
 2: import Combine
 3: 
 4: protocol ContentService {
 5: 
 6:     func fetchContent(neighborhoodId: String, category: FilterCategory) async throws -> [Content]
 7: 
 8: 
 9:     func prefetchContent(neighborhoodId: String) async
10: 
11: 
12:     func clearCache() async
13: }
14: 
15: actor ContentServiceImpl: ContentService {
16:     private let firestore: FirestoreService
17:     private var cache: [String: [Content]] = [:]
18: 
19:     init(firestore: FirestoreService) {
20:         self.firestore = firestore
21:     }
22: 
23:     func fetchContent(neighborhoodId: String, category: FilterCategory) async throws -> [Content] {
24:         let cacheKey = "\(neighborhoodId)_\(category.rawValue)"
25: 
26: 
27:         if let cached = cache[cacheKey] {
28:             return cached
29:         }
30: 
31: 
32:         let content = try await firestore.fetchContentByCategory(
33:             category: category,
34:             neighborhoodId: neighborhoodId
35:         )
36: 
37: 
38:         cache[cacheKey] = content
39: 
40:         return content
41:     }
42: 
43:     func prefetchContent(neighborhoodId: String) async {
44: 
45:         for category in FilterCategory.allCases {
46:             do {
47:                 _ = try await fetchContent(neighborhoodId: neighborhoodId, category: category)
48:             } catch {
49:                 print("Error prefetching content for \(neighborhoodId), \(category): \(error)")
50:             }
51:         }
52:     }
53: 
54:     func clearCache() async {
55:         cache.removeAll()
56:     }
57: }
</file>

<file path="sightline/sightline/Services/Neighborhood/NeighborhoodService.swift">
 1: import Foundation
 2: 
 3: protocol NeighborhoodService {
 4: 
 5:     func fetchUnlockedNeighborhoods() async throws -> [Neighborhood]
 6: 
 7: 
 8:     func fetchAvailableCategories(neighborhoodId: String) async throws -> [FilterCategory]
 9: 
10: 
11:     func clearCache() async
12: }
13: 
14: actor NeighborhoodServiceImpl: NeighborhoodService {
15:     private let firestore: FirestoreService
16:     private let auth: AuthService
17:     private var neighborhoodsCache: [Neighborhood]?
18:     private var categoriesCache: [String: [FilterCategory]] = [:]
19: 
20:     init(firestore: FirestoreService, auth: AuthService) {
21:         self.firestore = firestore
22:         self.auth = auth
23:     }
24: 
25:     func fetchUnlockedNeighborhoods() async throws -> [Neighborhood] {
26:         if let cached = neighborhoodsCache {
27:             return cached
28:         }
29: 
30:         guard let userId = auth.userId else {
31:             throw ServiceError.notAuthenticated
32:         }
33: 
34:         let neighborhoods = try await firestore.fetchUnlockedNeighborhoods(for: userId)
35:         neighborhoodsCache = neighborhoods
36:         return neighborhoods
37:     }
38: 
39:     func fetchAvailableCategories(neighborhoodId: String) async throws -> [FilterCategory] {
40:         if let cached = categoriesCache[neighborhoodId] {
41:             return cached
42:         }
43: 
44:         let categories = try await firestore.fetchAvailableCategories(for: neighborhoodId)
45:         categoriesCache[neighborhoodId] = categories
46:         return categories
47:     }
48: 
49:     func clearCache() async {
50:         neighborhoodsCache = nil
51:         categoriesCache.removeAll()
52:     }
53: }
54: 
55: enum ServiceError: Error {
56:     case notAuthenticated
57:     case networkError
58:     case invalidData
59: }
</file>

<file path="sightline/sightline/Services/Place/PlaceService.swift">
 1: import Foundation
 2: 
 3: protocol PlaceService {
 4: 
 5:     func fetchPlace(id: String) async throws -> Place
 6: 
 7: 
 8:     func prefetchPlaces(_ ids: [String]) async
 9: }
10: 
11: actor PlaceServiceImpl: PlaceService {
12:     private let firestore: FirestoreService
13:     private var cache: [String: Place] = [:]
14: 
15:     init(firestore: FirestoreService) {
16:         self.firestore = firestore
17:     }
18: 
19:     func fetchPlace(id: String) async throws -> Place {
20:         if let cached = cache[id] {
21:             return cached
22:         }
23: 
24:         let place = try await firestore.fetchPlace(id: id)
25:         cache[id] = place
26:         return place
27:     }
28: 
29:     func prefetchPlaces(_ ids: [String]) async {
30:         await withTaskGroup(of: Void.self) { group in
31:             for id in ids {
32:                 group.addTask {
33:                     do {
34:                         _ = try await self.fetchPlace(id: id)
35:                     } catch {
36:                         print("Error prefetching place \(id): \(error)")
37:                     }
38:                 }
39:             }
40:         }
41:     }
42: }
</file>

<file path="sightline/sightline/Services/AuthService.swift">
 1: import FirebaseAuth
 2: 
 3: protocol AuthServiceProtocol {
 4: 
 5:     var currentUser: User? { get }
 6:     var userId: String? { get }
 7:     var isAuthenticated: Bool { get }
 8: 
 9: 
10:     func signInAnonymously() async throws
11:     func signOut() throws
12: }
13: 
14: class AuthService: AuthServiceProtocol {
15:     private let auth = Auth.auth()
16: 
17:     var currentUser: User? {
18:         auth.currentUser
19:     }
20: 
21:     var userId: String? {
22:         currentUser?.uid
23:     }
24: 
25:     var isAuthenticated: Bool {
26:         currentUser != nil
27:     }
28: 
29:     func signInAnonymously() async throws {
30: 
31:         guard currentUser == nil else { return }
32: 
33:         do {
34:             let result = try await auth.signInAnonymously()
35:             print("Signed in anonymously with uid: \(result.user.uid)")
36:         } catch {
37:             print("Error signing in: \(error.localizedDescription)")
38:             throw error
39:         }
40:     }
41: 
42:     func signOut() throws {
43:         try auth.signOut()
44:     }
45: }
</file>

<file path="sightline/sightline/Services/FirestoreError.swift">
1: enum FirestoreError: Error {
2:     case decodingError
3:     case documentNotFound
4:     case invalidData
5: }
</file>

<file path="sightline/sightline/Services/FirestoreService.swift">
  1: import FirebaseFirestore
  2: import FirebaseStorage
  3: import AVKit
  4: import FirebaseAuth
  5: 
  6: protocol FirestoreServiceProtocol {
  7: 
  8:     func fetchUnlockedNeighborhoods(for userId: String) async throws -> [Neighborhood]
  9: 
 10: 
 11: 
 12: 
 13: 
 14: 
 15:     func fetchContentForPlace(placeId: String) async throws -> [Content]
 16:     func fetchContentByCategory(category: FilterCategory, neighborhoodId: String?) async throws -> [Content]
 17:     func saveDetectionResult(landmarkName: String) async throws
 18: 
 19: 
 20:     func fetchPlace(id: String) async throws -> Place
 21:     func fetchPlacesInNeighborhood(neighborhoodId: String) async throws -> [Place]
 22:     func addPlace(_ place: Place) async throws
 23:     func fetchAvailableCategories(for neighborhoodId: String) async throws -> [FilterCategory]
 24: 
 25: 
 26:     func savePlaceForUser(userId: String, placeId: String) async throws
 27:     func fetchSavedPlaceIds(for userId: String) async throws -> [String]
 28:     func removeSavedPlace(userId: String, placeId: String) async throws
 29: }
 30: 
 31: class FirestoreService: FirestoreServiceProtocol {
 32: 
 33:     let db = Firestore.firestore()
 34:     let storage = Storage.storage()
 35: 
 36: 
 37:     func fetchPlacesInNeighborhood(neighborhoodId: String) async throws -> [Place] {
 38:         let query = db.collection("places").whereField("neighborhoodId", isEqualTo: neighborhoodId)
 39:         let snapshot = try await query.getDocuments()
 40: 
 41:         return try snapshot.documents.map { try $0.data(as: Place.self) }
 42:     }
 43: 
 44:     func addPlace(_ place: Place) async throws {
 45:         try db.collection("places")
 46:             .document(place.id)
 47:             .setData(from: place)
 48:     }
 49: 
 50:     func fetchPlace(id: String) async throws -> Place {
 51:         let docRef = db.collection("places").document(id)
 52:         let document = try await docRef.getDocument()
 53:         return try document.data(as: Place.self)
 54:     }
 55: 
 56: 
 57:     func fetchContentForPlace(placeId: String) async throws -> [Content] {
 58:         let snapshot = try await db.collection("content")
 59:             .whereField("placeId", isEqualTo: placeId)
 60:             .order(by: "createdAt", descending: true)
 61:             .getDocuments()
 62: 
 63:         return snapshot.documents.compactMap { document in
 64:             try? document.data(as: Content.self)
 65:         }
 66:     }
 67: 
 68:     func fetchContentByCategory(category: FilterCategory, neighborhoodId: String?) async throws -> [Content] {
 69:         print("üîç Fetching content for category: \(category.rawValue), neighborhood: \(neighborhoodId ?? "all")")
 70: 
 71:         // Start with base query
 72:         var query = db.collection("content")
 73:             .whereField("tags", arrayContains: category.rawValue)
 74:             .whereField("processingStatus", isEqualTo: ProcessingStatus.complete.rawValue)
 75: 
 76:         if let neighborhoodId = neighborhoodId {
 77: 
 78:             query = query.whereField("neighborhoodId", isEqualTo: neighborhoodId)
 79:         }
 80: 
 81: 
 82:         query = query.order(by: "createdAt", descending: true)
 83:             .limit(to: 50)
 84: 
 85:         do {
 86:             let snapshot = try await query.getDocuments()
 87: 
 88:             let content = snapshot.documents.compactMap { document -> Content? in
 89:                 do {
 90:                     return try document.data(as: Content.self)
 91:                 } catch {
 92:                     print("‚ö†Ô∏è Failed to decode content: \(document.documentID), error: \(error)")
 93:                     return nil
 94:                 }
 95:             }
 96: 
 97:             print("‚úÖ Found \(content.count) content items")
 98:             return content
 99:         } catch let error as NSError {
100: 
101:             if error.domain == "FIRFirestoreErrorDomain" && error.code == 9 {
102:                 print("‚ö†Ô∏è Missing index error - falling back to client-side filtering")
103: 
104: 
105:                 let snapshot = try await db.collection("content")
106:                     .whereField("tags", arrayContains: category.rawValue)
107:                     .whereField("processingStatus", isEqualTo: ProcessingStatus.complete.rawValue)
108:                     .order(by: "createdAt", descending: true)
109:                     .getDocuments()
110: 
111: 
112:                 let content = snapshot.documents.compactMap { document -> Content? in
113:                     guard let content = try? document.data(as: Content.self) else { return nil }
114:                     if let neighborhoodId = neighborhoodId {
115:                         return content.neighborhoodId == neighborhoodId ? content : nil
116:                     }
117:                     return content
118:                 }
119: 
120:                 print("‚úÖ Found \(content.count) content items using fallback")
121:                 return content
122:             }
123:             throw error
124:         }
125:     }
126: 
127: 
128:     func saveDetectionResult(landmarkName: String) async throws {
129:         let landmarkData: [String: Any] = [
130:             "name": landmarkName,
131:             "detectedAt": FieldValue.serverTimestamp()
132:         ]
133: 
134:         try await db.collection("detectedLandmarks")
135:             .addDocument(data: landmarkData)
136:     }
137: 
138:     func fetchUnlockedNeighborhoods(for userId: String) async throws -> [Neighborhood] {
139:         print("üîç Fetching unlocked neighborhoods for user: \(userId)")
140: 
141: 
142:         let unlockedSnapshot = try await db.collection("users")
143:             .document(userId)
144:             .collection("unlocked_neighborhoods")
145:             .getDocuments()
146: 
147: 
148:         let neighborhoodIds = unlockedSnapshot.documents.map { $0.documentID }
149: 
150:         guard !neighborhoodIds.isEmpty else {
151:             print("‚ö†Ô∏è No unlocked neighborhoods found for user")
152:             return []
153:         }
154: 
155: 
156:         let neighborhoodSnapshot = try await db.collection("neighborhoods")
157:             .whereField(FieldPath.documentID(), in: neighborhoodIds)
158:             .getDocuments()
159: 
160:         let neighborhoods = neighborhoodSnapshot.documents.compactMap { document -> Neighborhood? in
161:             try? document.data(as: Neighborhood.self)
162:         }
163: 
164:         print("‚úÖ Found \(neighborhoods.count) unlocked neighborhoods")
165:         return neighborhoods
166:     }
167: 
168: 
169:     private func decodeGeoBounds(from data: [String: Any]) throws -> Neighborhood.GeoBounds {
170:         guard let northeast = data["northeast"] as? [String: Any],
171:               let southwest = data["southwest"] as? [String: Any] else {
172:             throw DecodingError.dataCorrupted(.init(codingPath: [], debugDescription: "Missing bounds data"))
173:         }
174: 
175:         return Neighborhood.GeoBounds(
176:             northeast: .init(
177:                 lat: northeast["lat"] as? Double ?? 0,
178:                 lng: northeast["lng"] as? Double ?? 0
179:             ),
180:             southwest: .init(
181:                 lat: southwest["lat"] as? Double ?? 0,
182:                 lng: southwest["lng"] as? Double ?? 0
183:             )
184:         )
185:     }
186: 
187: 
188:     private func decodeLandmarks(from data: [[String: Any]]) throws -> [Neighborhood.Landmark]? {
189:         return data.compactMap { landmarkData in
190:             guard let location = landmarkData["location"] as? GeoPoint,
191:                   let mid = landmarkData["mid"] as? String,
192:                   let name = landmarkData["name"] as? String else {
193:                 return nil
194:             }
195: 
196:             return Neighborhood.Landmark(
197:                 location: location,
198:                 mid: mid,
199:                 name: name
200:             )
201:         }
202:     }
203: 
204:     func fetchAvailableCategories(for neighborhoodId: String) async throws -> [FilterCategory] {
205:         print("üîç Fetching available categories for neighborhood: \(neighborhoodId)")
206: 
207:         let snapshot = try await db.collection("content")
208:             .whereField("neighborhoodId", isEqualTo: neighborhoodId)
209:             .getDocuments()
210: 
211: 
212:         var categorySet = Set<String>()
213: 
214: 
215:         for document in snapshot.documents {
216:             if let tags = document.data()["tags"] as? [String] {
217:                 categorySet.formUnion(tags)
218:             }
219:         }
220: 
221: 
222:         let categories = categorySet.compactMap { tagString -> FilterCategory? in
223:             return FilterCategory(rawValue: tagString)
224:         }.sorted { $0.rawValue < $1.rawValue }
225: 
226:         print("‚úÖ Found \(categories.count) available categories")
227:         return categories
228:     }
229: 
230: 
231: 
232: 
233:     func savePlaceForUser(userId: String, placeId: String) async throws {
234:         let docRef = db.collection("users")
235:             .document(userId)
236:             .collection("saved_places")
237:             .document(placeId)
238: 
239:         try await docRef.setData([
240:             "savedAt": FieldValue.serverTimestamp()
241:         ])
242:     }
243: 
244: 
245:     func fetchSavedPlaceIds(for userId: String) async throws -> [String] {
246:         let snapshot = try await db.collection("users")
247:             .document(userId)
248:             .collection("saved_places")
249:             .getDocuments()
250: 
251:         return snapshot.documents.map { $0.documentID }
252:     }
253: 
254:     func createAnnotationRequest(imageURL: String, originalFilename: String) async throws {
255:         let annotationRequest = [
256:             "imageURL": imageURL,
257:             "originalFilename": originalFilename,
258:             "status": "pending",
259:             "createdAt": Timestamp(),
260:             "updatedAt": Timestamp()
261:         ] as [String : Any]
262: 
263:         try await db.collection("annotationRequests").addDocument(data: annotationRequest)
264:     }
265: 
266:     func removeSavedPlace(userId: String, placeId: String) async throws {
267:         let docRef = db.collection("users")
268:             .document(userId)
269:             .collection("saved_places")
270:             .document(placeId)
271: 
272:         try await docRef.delete()
273:     }
274: }
</file>

<file path="sightline/sightline/Services/FirestoreService+TestData.swift">
1: 
</file>

<file path="sightline/sightline/Services/LandmarkDetectionService.swift">
 1: import UIKit
 2: import FirebaseFunctions
 3: import FirebaseAuth
 4: import os
 5: 
 6: 
 7: actor LandmarkDetectionService {
 8:     private lazy var functions = Functions.functions()
 9:     private let logger = Logger(
10:         subsystem: Bundle.main.bundleIdentifier ?? "Sightline",
11:         category: "LandmarkDetection"
12:     )
13: 
14: 
15: 
16: 
17:     func detectLandmark(in image: UIImage) async throws -> [String: Any]? {
18:         guard let imageData = image.jpegData(compressionQuality: 0.8) else {
19:             logger.error("Failed to convert image to JPEG data")
20:             throw LandmarkDetectionError.invalidImageData
21:         }
22: 
23:         let imageSize = image.size
24:         logger.info("Sending landmark detection request - Image size: \(imageSize.width)x\(imageSize.height), Data size: \(imageData.count) bytes")
25: 
26:         let base64String = imageData.base64EncodedString()
27:         let requestData: [String: Any] = [
28:             "image": ["content": base64String],
29:             "features": [
30:                 ["maxResults": 1, "type": "LANDMARK_DETECTION"]
31:             ]
32:         ]
33: 
34:         logger.debug("Calling annotateImage cloud function...")
35:         let result = try await functions.httpsCallable("annotateImage").call(requestData)
36: 
37:         guard let dict = result.data as? [String: Any] else {
38:             logger.error("Invalid response format from cloud function")
39:             throw LandmarkDetectionError.failedCloudFunction("Invalid response format")
40:         }
41: 
42:         if let landmarkData = dict["landmark"] as? [String: Any] {
43:             if let name = landmarkData["name"] as? String {
44:                 logger.info("Successfully detected landmark: \(name)")
45:             } else {
46:                 logger.info("Successfully detected landmark (name not available)")
47:             }
48:             return landmarkData
49:         } else {
50:             logger.notice("No landmark detected in image")
51:             return nil
52:         }
53:     }
54: }
55: 
56: 
57: enum LandmarkDetectionError: Error {
58:     case invalidImageData
59:     case failedCloudFunction(String)
60: }
</file>

<file path="sightline/sightline/Services/ServiceContainer.swift">
 1: import Foundation
 2: 
 3: 
 4: class ServiceContainer {
 5: 
 6:     static let shared = ServiceContainer()
 7: 
 8: 
 9:     let auth: AuthServiceProtocol
10:     let firestore: FirestoreServiceProtocol
11: 
12: 
13:     private(set) lazy var content: ContentService = {
14:         ContentServiceImpl(firestore: firestore as! FirestoreService)
15:     }()
16: 
17:     private(set) lazy var neighborhood: NeighborhoodService = {
18:         NeighborhoodServiceImpl(firestore: firestore as! FirestoreService, auth: auth as! AuthService)
19:     }()
20: 
21:     private(set) lazy var place: PlaceService = {
22:         PlaceServiceImpl(firestore: firestore as! FirestoreService)
23:     }()
24: 
25: 
26:     private init() {
27:         self.auth = AuthService()
28:         self.firestore = FirestoreService()
29:     }
30: }
</file>

<file path="sightline/sightline/Services/VideoPlayerManager.swift">
  1: import AVFoundation
  2: import Combine
  3: import SwiftUI
  4: import FirebaseStorage
  5: import AVKit
  6: import Foundation
  7: 
  8: @MainActor
  9: final class VideoPlayerManager: ObservableObject {
 10:     @Published private(set) var currentPlayer: AVPlayer?
 11:     @Published private(set) var isLoading = false
 12:     @Published private(set) var error: Error?
 13:     @Published private(set) var readyPlayerUrls: Set<String> = []
 14: 
 15:     private var playerLooper: AVPlayerLooper?
 16:     private var cancellables = Set<AnyCancellable>()
 17: 
 18: 
 19:     private var preloadedPlayers: [String: AVQueuePlayer] = [:]
 20: 
 21:     private var preloadedVideosQueue: [String] = []
 22: 
 23:     private let maxCacheSize = 10
 24: 
 25:     private var preloadTasks: [String: Task<Void, Never>] = [:]
 26:     private let preloadLimit = 2
 27: 
 28:     private var currentlyPlayingUrl: String?
 29: 
 30: 
 31:     func preparePlayer(for url: String) async {
 32: 
 33:         if preloadedPlayers[url] != nil {
 34:             print("üîÑ Video \(url) already prepared. Skipping.")
 35:             return
 36:         }
 37: 
 38:         isLoading = true
 39:         error = nil
 40: 
 41:         do {
 42:             let downloadUrl = try await getDownloadURL(for: url)
 43:             let asset = AVURLAsset(url: downloadUrl)
 44: 
 45:             guard try await asset.load(.isPlayable) else {
 46:                 throw NSError(domain: "VideoPlayerManager", code: -1,
 47:                               userInfo: [NSLocalizedDescriptionKey: "Video is not playable"])
 48:             }
 49: 
 50:             let item = AVPlayerItem(asset: asset)
 51:             let player = AVQueuePlayer(playerItem: item)
 52:             playerLooper = AVPlayerLooper(player: player, templateItem: item)
 53: 
 54: 
 55:             try await waitUntilPlayerItemReady(item)
 56: 
 57:             preloadedPlayers[url] = player
 58:             readyPlayerUrls.insert(url)
 59:             isLoading = false
 60:             print("‚úÖ Prepared player for URL: \(url)")
 61: 
 62:         } catch {
 63:             self.error = error
 64:             self.isLoading = false
 65:             print("‚ùå Error preparing player for URL: \(url), Error: \(error)")
 66:         }
 67:     }
 68: 
 69: 
 70:     func play(url: String) {
 71:         print("üé¨ Starting playback for URL: \(url)")
 72: 
 73:         if let player = preloadedPlayers[url], readyPlayerUrls.contains(url) {
 74:             currentPlayer = player
 75:             currentlyPlayingUrl = url
 76:             player.seek(to: .zero)
 77:             player.play()
 78:             print("‚úÖ Playing from preloaded player")
 79:         } else {
 80:             print("‚ö†Ô∏è No preloaded player, preparing and playing")
 81:             Task {
 82:                 await preparePlayer(for: url)
 83: 
 84:                 if let player = preloadedPlayers[url], readyPlayerUrls.contains(url) {
 85:                     currentPlayer = player
 86:                     currentlyPlayingUrl = url
 87:                     player.play()
 88:                 }
 89:             }
 90:         }
 91:     }
 92: 
 93:     func pause() {
 94:         currentPlayer?.pause()
 95:         print("‚è∏Ô∏è Paused current playback")
 96:     }
 97: 
 98: 
 99:     func pause(url: String) {
100:         if let player = preloadedPlayers[url] {
101:             player.pause()
102:             if currentlyPlayingUrl == url {
103:                 currentPlayer = nil
104:                 currentlyPlayingUrl = nil
105:             }
106:             print("‚è∏Ô∏è Paused playback for URL: \(url)")
107:         }
108:     }
109: 
110:     func preloadVideos(for urls: [String], at index: Int) {
111: 
112:         cleanupDistantPreloads(currentIndex: index)
113: 
114: 
115:         let start = max(0, index - preloadLimit)
116:         let end = min(urls.count - 1, index + preloadLimit)
117: 
118:         for i in start...end where i != index {
119:             let url = urls[i]
120:             if preloadedPlayers[url] == nil && preloadTasks[url] == nil {
121:                 preloadTasks[url] = Task {
122:                     await preparePlayer(for: url)
123:                 }
124:             }
125:         }
126:     }
127: 
128: 
129:     private func waitUntilPlayerItemReady(_ item: AVPlayerItem) async throws {
130:         while item.status != .readyToPlay {
131:             if item.status == .failed {
132:                 throw item.error ?? NSError(domain: "VideoPlayerManager", code: -1,
133:                                              userInfo: [NSLocalizedDescriptionKey: "Failed to load video"])
134:             }
135:             try await Task.sleep(nanoseconds: 50_000_000)
136:         }
137:     }
138: 
139:     private func cleanupDistantPreloads(currentIndex: Int) {
140: 
141: 
142:     }
143: 
144:     func playerFor(url: String) -> AVPlayer? {
145: 
146:         if url == currentlyPlayingUrl {
147:             return currentPlayer
148:         }
149: 
150:         return readyPlayerUrls.contains(url) ? preloadedPlayers[url] : nil
151:     }
152: 
153:     private func getDownloadURL(for gsUrl: String) async throws -> URL {
154:         let storageRef = Storage.storage().reference(forURL: gsUrl)
155:         return try await storageRef.downloadURL()
156:     }
157: 
158:     func cleanup()  {
159:         currentPlayer?.pause()
160:         playerLooper = nil
161:         currentPlayer = nil
162:         currentlyPlayingUrl = nil
163:         error = nil
164:         isLoading = false
165:         cancellables.removeAll()
166:     }
167: 
168: 
169:     func clearCache() {
170:         preloadedPlayers.forEach { (_, player) in
171:             player.pause()
172:         }
173:         preloadedPlayers.removeAll()
174:         preloadedVideosQueue.removeAll()
175:         preloadTasks.removeAll()
176:         readyPlayerUrls.removeAll()
177:         print("Cleared video cache")
178:     }
179: }
180: 
181: extension VideoPlayerManager {
182:     nonisolated static func create() async -> VideoPlayerManager {
183:         await MainActor.run { VideoPlayerManager() }
184:     }
185: }
</file>

<file path="sightline/sightline/Services/VideoReviewService.swift">
  1: import Foundation
  2: import FirebaseStorage
  3: import FirebaseFirestore
  4: import FirebaseFunctions
  5: import FirebaseAuth
  6: 
  7: class VideoReviewService {
  8:     private let storage = Storage.storage()
  9:     private let functions = Functions.functions()
 10:     private let firestore = Firestore.firestore()
 11: 
 12:     func uploadReview(videoURL: URL, placeId: String) async throws -> String {
 13:         guard let currentUser = Auth.auth().currentUser else {
 14:             throw NSError(domain: "VideoReviewService",
 15:                          code: 401,
 16:                          userInfo: [NSLocalizedDescriptionKey: "User must be logged in to upload reviews"])
 17:         }
 18: 
 19:         let reviewId = UUID().uuidString
 20: 
 21:         do {
 22:             print("üìù Starting upload for reviewId: \(reviewId)")
 23:             print("üìù Auth state:", currentUser.uid)
 24: 
 25:             let storagePath = "processing/\(placeId)/\(reviewId).mp4"
 26:             print("üìù Storage path: \(storagePath)")
 27: 
 28: 
 29:             let initialData: [String: Any] = [
 30:                 "id": reviewId,
 31:                 "placeIds": [placeId],
 32:                 "userId": currentUser.uid,
 33:                 "createdAt": FieldValue.serverTimestamp(),
 34:                 "processingStatus": "awaiting_upload",
 35:                 "neighborhoodId": "",
 36:                 "caption": "",
 37:                 "thumbnailUrl": "",
 38:                 "tags": [],
 39:                 "likes": 0,
 40:                 "views": 0,
 41:                 "transcription": "",
 42:                 "moderationResults": [:],
 43:                 "processingError": [:],
 44:                 "startedAt": FieldValue.serverTimestamp(),
 45:                 "updatedAt": FieldValue.serverTimestamp()
 46:             ]
 47: 
 48:             print("üìù Creating Firestore document")
 49:             try await firestore
 50:                 .collection("content")
 51:                 .document(reviewId)
 52:                 .setData(initialData)
 53: 
 54:             print("üìù Reading video data")
 55:             let videoData = try Data(contentsOf: videoURL)
 56:             let storageRef = storage.reference().child(storagePath)
 57: 
 58:             let metadata = StorageMetadata()
 59:             metadata.contentType = "video/mp4"
 60: 
 61:             print("üìù Using storage bucket:", storage.reference().bucket)
 62: 
 63:             print("üìù Uploading to Storage")
 64:             _ = try await storageRef.putDataAsync(videoData, metadata: metadata)
 65:             let downloadURL = try await storageRef.downloadURL()
 66: 
 67: 
 68:             try await firestore
 69:                 .collection("content")
 70:                 .document(reviewId)
 71:                 .updateData([
 72:                     "videoPath": "gs://\(storage.reference().bucket)/\(storagePath)",
 73:                     "videoUrl": downloadURL.absoluteString,
 74:                     "updatedAt": FieldValue.serverTimestamp()
 75:                 ])
 76: 
 77:             print("‚úÖ Upload complete for reviewId: \(reviewId)")
 78:             return reviewId
 79: 
 80:         } catch {
 81:             print("‚ùå Upload error: \(error)")
 82:             if let storageError = error as? StorageErrorCode {
 83:                 print("Storage error code: \(storageError.rawValue)")
 84:             }
 85:             try? await firestore
 86:                 .collection("content")
 87:                 .document(reviewId)
 88:                 .updateData([
 89:                     "processingStatus": "error",
 90:                     "processingError": [
 91:                         "stage": "upload",
 92:                         "message": error.localizedDescription,
 93:                         "timestamp": FieldValue.serverTimestamp()
 94:                     ]
 95:                 ])
 96:             throw error
 97:         }
 98:     }
 99: 
100:     func listenToProcessingStatus(reviewId: String, completion: @escaping (String) -> Void) -> ListenerRegistration {
101:         let db = Firestore.firestore()
102:         return db.collection("content").document(reviewId)
103:             .addSnapshotListener { documentSnapshot, error in
104:                 guard let document = documentSnapshot else {
105:                     print("Error fetching document: \(error?.localizedDescription ?? "Unknown error")")
106:                     completion("error")
107:                     return
108:                 }
109: 
110:                 guard let data = document.data(),
111:                       let status = data["processingStatus"] as? String else {
112:                     print("Document data was empty or missing processingStatus")
113:                     completion("error")
114:                     return
115:                 }
116: 
117:                 completion(status)
118:             }
119:     }
120: }
</file>

<file path="sightline/sightline/sightline.xcdatamodeld/sightline.xcdatamodel/contents">
1: <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
2: <model type="com.apple.IDECoreDataModeler.DataModel" documentVersion="1.0" lastSavedToolsVersion="1" systemVersion="11A491" minimumToolsVersion="Automatic" sourceLanguage="Swift" usedWithCloudKit="false" userDefinedModelVersionIdentifier="">
3:     <entity name="Item" representedClassName="Item" syncable="YES" codeGenerationType="class">
4:         <attribute name="timestamp" optional="YES" attributeType="Date" usesScalarValueType="NO"/>
5:     </entity>
6:     <elements>
7:         <element name="Item" positionX="-63" positionY="-18" width="128" height="44"/>
8:     </elements>
9: </model>
</file>

<file path="sightline/sightline/sightline.xcdatamodeld/.xccurrentversion">
1: <?xml version="1.0" encoding="UTF-8"?>
2: <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
3: <plist version="1.0">
4: <dict>
5: 	<key>_XCCurrentVersionName</key>
6: 	<string>sightline.xcdatamodel</string>
7: </dict>
8: </plist>
</file>

<file path="sightline/sightline/State/AppState.swift">
 1: import SwiftUI
 2: 
 3: class AppState: ObservableObject {
 4: 
 5:     @Published var shouldSwitchToFeed = false
 6:     @Published var shouldSwitchToDiscover = false
 7:     @Published var navigationPath = NavigationPath()
 8: 
 9: 
10:     @Published var shouldSwitchToProfile = false
11: 
12: 
13:     enum NavigationDestination: Hashable {
14:         case placeDetail(placeId: String, initialContentId: String)
15:     }
16: }
</file>

<file path="sightline/sightline/Stores/AppStore.swift">
  1: import Combine
  2: import FirebaseFirestore
  3: import SwiftUI
  4: 
  5: @MainActor
  6: class AppStore: Store {
  7:     private let services = ServiceContainer.shared
  8: 
  9:     @Published var unlockedNeighborhoods: [Neighborhood] = []
 10:     @Published var availableCategories: [FilterCategory] = []
 11:     @Published var contentItems: [Content] = []
 12:     @Published var places: [String: Place] = [:]
 13: 
 14: 
 15:     @Published var selectedNeighborhood: Neighborhood? {
 16:         didSet {
 17: 
 18:             currentIndex = 0
 19:             Task {
 20:                 await loadContent()
 21:             }
 22:         }
 23:     }
 24:     @Published var selectedCategory: FilterCategory = .restaurant {
 25:         didSet {
 26: 
 27:             currentIndex = 0
 28:             Task {
 29:                 await loadContent()
 30:             }
 31:         }
 32:     }
 33: 
 34: 
 35:     @Published var currentIndex: Int = 0
 36: 
 37: 
 38:     let videoManager = VideoPlayerManager()
 39: 
 40: 
 41:     @Published var feedVersion: Int = 0
 42: 
 43:     @Published var isLoadingContent: Bool = false
 44: 
 45:     func loadUnlockedNeighborhoods() async {
 46:         do {
 47:             let neighborhoods = try await services.neighborhood.fetchUnlockedNeighborhoods()
 48:             unlockedNeighborhoods = neighborhoods
 49:             if selectedNeighborhood == nil ||
 50:                 !neighborhoods.contains(where: { $0.id == selectedNeighborhood?.id }) {
 51:                 selectedNeighborhood = neighborhoods.first
 52:             }
 53:         } catch {
 54:             print("Error loading neighborhoods: \(error)")
 55:         }
 56:     }
 57: 
 58:     func loadAvailableCategories() async {
 59:         guard let neighborhood = selectedNeighborhood else { return }
 60:         do {
 61:             let categories = try await services.neighborhood.fetchAvailableCategories(neighborhoodId: neighborhood.id!)
 62:             availableCategories = categories
 63: 
 64:             if !categories.contains(selectedCategory) && !categories.isEmpty {
 65:                 selectedCategory = categories[0]
 66:             }
 67:         } catch {
 68:             print("Error loading categories: \(error)")
 69:         }
 70:     }
 71: 
 72:     func loadContent() async {
 73:         isLoadingContent = true
 74:         defer { isLoadingContent = false }
 75: 
 76: 
 77:         if currentIndex >= 0, currentIndex < contentItems.count {
 78:             let oldUrl = contentItems[currentIndex].videoUrl
 79:             videoManager.pause(url: oldUrl)
 80:         }
 81: 
 82:         guard let neighborhood = selectedNeighborhood else {
 83:             contentItems = []
 84:             places = [:]
 85:             return
 86:         }
 87: 
 88:         do {
 89: 
 90:             await loadAvailableCategories()
 91: 
 92: 
 93:             let fetchedContent = try await services.content.fetchContent(
 94:                 neighborhoodId: neighborhood.id!,
 95:                 category: selectedCategory
 96:             )
 97: 
 98: 
 99:             var placeMap: [String: Place] = [:]
100:             for item in fetchedContent {
101:                 for placeId in item.placeIds {
102:                     if places[placeId] == nil && placeMap[placeId] == nil {
103:                         if let place = try? await services.place.fetchPlace(id: placeId) {
104:                             placeMap[placeId] = place
105:                         }
106:                     }
107:                 }
108:             }
109: 
110:             contentItems = fetchedContent
111:             places.merge(placeMap) { (_, new) in new }
112: 
113: 
114:             if !contentItems.isEmpty {
115:                 let urls = contentItems.map { $0.videoUrl }
116:                 videoManager.preloadVideos(for: urls, at: 0)
117:             }
118: 
119: 
120:             feedVersion += 1
121:         } catch {
122:             print("Error loading content: \(error)")
123:             contentItems = []
124:             places = [:]
125:         }
126:     }
127: }
</file>

<file path="sightline/sightline/Stores/LandmarkDetectionStore.swift">
  1: import SwiftUI
  2: import Combine
  3: 
  4: @MainActor
  5: class LandmarkDetectionStore: Store {
  6:     @Published var detectedLandmark: LandmarkInfo? = nil
  7:     @Published var errorMessage: String = ""
  8:     @Published var debugImages: [String] = ["utcapitol1", "utcapitol2", "ladybirdlake1"]
  9:     @Published var isCapturing = false
 10: 
 11:     private var consecutiveFailures = 0
 12:     private let maxFailuresBeforeNotice = 3
 13:     private var hasDetectedLandmark = false
 14: 
 15:     func startCapture() {
 16:         isCapturing = true
 17:         errorMessage = "Scanning..."
 18:         consecutiveFailures = 0
 19:         hasDetectedLandmark = false
 20:     }
 21: 
 22:     func captureCompleted() {
 23:         isCapturing = false
 24:         if detectedLandmark == nil {
 25:             errorMessage = "None detected, try finding another landmark."
 26:         }
 27:     }
 28: 
 29:     func reset() {
 30:         isCapturing = false
 31:         errorMessage = ""
 32:         detectedLandmark = nil
 33:         consecutiveFailures = 0
 34:         hasDetectedLandmark = false
 35:     }
 36: 
 37:      func detectLandmark(image: UIImage, using service: LandmarkDetectionService) async {
 38:         guard !hasDetectedLandmark else { return }
 39: 
 40:         self.detectedLandmark = nil
 41:         do {
 42:             if let landmarkData = try await service.detectLandmark(in: image) {
 43:                 hasDetectedLandmark = true
 44:                 consecutiveFailures = 0
 45:                 let name = (landmarkData["name"] as? String) ?? "Unknown"
 46:                 let locations = (landmarkData["locations"] as? [[String: Any]]) ?? []
 47:                 var lat: Double? = nil
 48:                 var lon: Double? = nil
 49:                 if let firstLocation = locations.first,
 50:                    let latLng = firstLocation["latLng"] as? [String: Any] {
 51:                     lat = latLng["latitude"] as? Double
 52:                     lon = latLng["longitude"] as? Double
 53:                 }
 54:                 let nbData = landmarkData["neighborhood"] as? [String: Any]
 55:                 let neighborhood = buildNeighborhood(from: nbData)
 56:                 let landmarkInfo = LandmarkInfo(
 57:                     name: name,
 58:                     latitude: lat,
 59:                     longitude: lon,
 60:                     neighborhood: neighborhood
 61:                 )
 62:                 self.detectedLandmark = landmarkInfo
 63:                 self.errorMessage = ""
 64:                 consecutiveFailures = 0
 65:             } else {
 66:                 consecutiveFailures += 1
 67:                 if consecutiveFailures >= maxFailuresBeforeNotice && isCapturing {
 68:                     self.errorMessage = "No landmarks detected yet... Keep scanning the area"
 69:                 }
 70:             }
 71:         } catch {
 72:             consecutiveFailures += 1
 73:             if consecutiveFailures >= maxFailuresBeforeNotice && isCapturing {
 74:                 self.errorMessage = "Having trouble detecting landmarks. Try moving closer or adjusting your angle."
 75:             } else {
 76:                 self.errorMessage = "Error: \(error.localizedDescription)"
 77:             }
 78:         }
 79:     }
 80: 
 81:     private func buildNeighborhood(from data: [String: Any]?) -> Neighborhood? {
 82:         guard let data = data,
 83:               let placeId = data["place_id"] as? String,
 84:               let nbName = data["name"] as? String,
 85:               let geometry = data["bounds"] as? [String: Any],
 86:               let ne = geometry["northeast"] as? [String: Any],
 87:               let sw = geometry["southwest"] as? [String: Any] else {
 88:             return nil
 89:         }
 90:         let bounds = Neighborhood.GeoBounds(
 91:             northeast: Neighborhood.GeoBounds.Point(
 92:                 lat: ne["lat"] as? Double ?? 0,
 93:                 lng: ne["lng"] as? Double ?? 0
 94:             ),
 95:             southwest: Neighborhood.GeoBounds.Point(
 96:                 lat: sw["lat"] as? Double ?? 0,
 97:                 lng: sw["lng"] as? Double ?? 0
 98:             )
 99:         )
100:         return Neighborhood(
101:             id: placeId,
102:             name: nbName,
103:             description: nil,
104:             imageUrl: nil,
105:             bounds: bounds,
106:             landmarks: nil
107:         )
108:     }
109: 
110: }
</file>

<file path="sightline/sightline/Stores/ProfileStore.swift">
  1: import Combine
  2: import FirebaseAuth
  3: import SwiftUI
  4: 
  5: @MainActor
  6: class ProfileStore: Store {
  7:     private let services = ServiceContainer.shared
  8:     private var authStateDidChangeListenerHandle: AuthStateDidChangeListenerHandle?
  9: 
 10:     @Published var user: User?
 11:     @Published var savedPlaces: [Place] = []
 12:     @Published var unlockedNeighborhoodNames: [String] = []
 13: 
 14:     @Published var isAnonymous: Bool = true
 15:     @Published var isLoading: Bool = false
 16:     @Published var errorMessage: String?
 17:     @Published var userEmail: String?
 18:     @Published var hasPendingSavedPlaces: Bool = false
 19: 
 20: 
 21:     init() {
 22: 
 23:         authStateDidChangeListenerHandle = Auth.auth().addStateDidChangeListener { [weak self] auth, user in
 24:             guard let self = self else { return }
 25:             self.user = user
 26:             self.isAnonymous = user?.isAnonymous ?? true
 27:             self.userEmail = user?.email
 28: 
 29:             if let user = user, user.isAnonymous {
 30:                 Task {
 31:                     await self.checkPendingSavedPlaces()
 32:                 }
 33:             } else if let user = user {
 34: 
 35:                  Task {
 36:                     await self.loadData()
 37:                  }
 38:             }
 39:         }
 40:     }
 41: 
 42: 
 43:     deinit {
 44:         if let handle = authStateDidChangeListenerHandle {
 45:             Auth.auth().removeStateDidChangeListener(handle)
 46:         }
 47:     }
 48: 
 49: 
 50:     func loadData() async {
 51:       guard !isAnonymous else {return}
 52:       async let savedPlacesTask = loadSavedPlaces()
 53:       async let neighborhoodTask = loadUnlockedNeighborhoods()
 54: 
 55:       _ = await(savedPlacesTask, neighborhoodTask)
 56:     }
 57: 
 58:     func loadSavedPlaces() async {
 59:         guard let userId = user?.uid else { return }
 60:         do {
 61:             let placeIds = try await services.firestore.fetchSavedPlaceIds(for: userId)
 62:             var fetched: [Place] = []
 63:             try await withThrowingTaskGroup(of: Place?.self) {group in
 64:               for pid in placeIds {
 65:                 group.addTask{
 66:                   try await self.services.firestore.fetchPlace(id: pid)
 67:                 }
 68:               }
 69:               for try await place in group {
 70:                 if let place = place {
 71:                   fetched.append(place)
 72:                 }
 73:               }
 74:             }
 75:             fetched.sort{$0.name < $1.name}
 76:             await MainActor.run {
 77:                 savedPlaces = fetched
 78:             }
 79:         } catch {
 80:             print("Error fetching saved places: \(error)")
 81:         }
 82:     }
 83: 
 84:     func loadUnlockedNeighborhoods() async {
 85:         guard let userId = user?.uid else { return }
 86:         do {
 87:             let neighborhoods = try await services.neighborhood.fetchUnlockedNeighborhoods()
 88:             self.unlockedNeighborhoodNames = neighborhoods.map { $0.name }.sorted()
 89:         } catch {
 90:             print("Error fetching unlocked neighborhoods: \(error)")
 91:         }
 92:     }
 93: 
 94:      func checkPendingSavedPlaces() async {
 95:         guard let userId = Auth.auth().currentUser?.uid else { return }
 96:         do {
 97:             let placeIds = try await services.firestore.fetchSavedPlaceIds(for: userId)
 98:             await MainActor.run {
 99:                 self.hasPendingSavedPlaces = !placeIds.isEmpty
100:             }
101:         } catch {
102:             print("Error checking pending saved places: \(error)")
103:         }
104:     }
105: 
106:      func signIn(email: String, password: String) async {
107:         guard !isLoading else { return }
108:         guard !email.isEmpty else {
109:             errorMessage = "Please enter an email"
110:             return
111:         }
112:         guard !password.isEmpty else {
113:             errorMessage = "Please enter a password"
114:             return
115:         }
116: 
117:         isLoading = true
118:         errorMessage = nil
119: 
120:         do {
121:             let result = try await Auth.auth().signIn(withEmail: email, password: password)
122:             isAnonymous = false
123:             userEmail = result.user.email
124:         } catch {
125:             errorMessage = error.localizedDescription
126:         }
127: 
128:         isLoading = false
129:     }
130: 
131:     func removeSavedPlace(_ place: Place) async {
132:         guard let userId = user?.uid else { return }
133:         do {
134:             try await services.firestore.removeSavedPlace(userId: userId, placeId: place.id)
135:             savedPlaces.removeAll { $0.id == place.id }
136:         } catch {
137:             print("Error removing place: \(error)")
138:             errorMessage = "Failed to remove place."
139:         }
140:     }
141: 
142:      func signUp(email: String, password: String, confirmPassword: String) async {
143:         guard !isLoading else { return }
144:         guard !email.isEmpty else {
145:             errorMessage = "Please enter an email"
146:             return
147:         }
148:         guard password == confirmPassword else {
149:             errorMessage = "Passwords don't match"
150:             return
151:         }
152:         guard password.count >= 6 else {
153:             errorMessage = "Password must be at least 6 characters"
154:             return
155:         }
156: 
157:         isLoading = true
158:         errorMessage = nil
159: 
160:         do {
161: 
162:             if let user = Auth.auth().currentUser {
163:                 let credential = EmailAuthProvider.credential(withEmail: email, password: password)
164:                 try await user.link(with: credential)
165:                 isAnonymous = false
166:                 userEmail = email
167:             }
168:         } catch {
169:             errorMessage = error.localizedDescription
170:         }
171: 
172:         isLoading = false
173:     }
174: 
175:     func resetAccount() async {
176:         print("üîÑ Starting account reset...")
177:         do {
178:             print("üì§ Attempting to sign out current user...")
179:             try services.auth.signOut()
180:             print("‚úÖ Sign out successful")
181: 
182:             print("üóëÔ∏è Clearing UserDefaults...")
183:             UserDefaults.standard.removePersistentDomain(forName: Bundle.main.bundleIdentifier!)
184:             print("‚úÖ UserDefaults cleared")
185: 
186: 
187:             print("üîÑ Resetting view model state...")
188:             isAnonymous = true
189:             userEmail = nil
190:             errorMessage = nil
191:             savedPlaces.removeAll()
192:             print("‚úÖ View model state reset")
193: 
194:             print("‚è≥ Waiting for Firebase to auto-create anonymous user...")
195:             try await Task.sleep(nanoseconds: 1_000_000_000)
196: 
197:             if let currentUser = Auth.auth().currentUser {
198:                 print("‚úÖ New user state: anonymous=\(currentUser.isAnonymous), email=\(currentUser.email ?? "")")
199:             } else {
200:                 print("‚ö†Ô∏è No current user after reset")
201:             }
202:         } catch {
203:             print("‚ùå Reset failed with error: \(error.localizedDescription)")
204:             errorMessage = "Failed to reset account: \(error.localizedDescription)"
205:         }
206:     }
207: 
208:     func signOut() async {
209:       do {
210:         try services.auth.signOut()
211:         isAnonymous = true
212:         user = nil
213:         userEmail = nil
214:         savedPlaces.removeAll()
215:         unlockedNeighborhoodNames.removeAll()
216:       } catch {
217:         print("Failed to sign out")
218:       }
219:     }
220: }
</file>

<file path="sightline/sightline/Stores/Store.swift">
1: import SwiftUI
2: 
3: protocol Store: ObservableObject {}
</file>

<file path="sightline/sightline/Views/Components/AdaptiveColorButton.swift">
 1: import SwiftUI
 2: 
 3: struct AdaptiveColorButton<Label: View>: View {
 4:     let action: () -> Void
 5:     let label: () -> Label
 6:     let isSelected: Bool
 7:     let expandHorizontally: Bool
 8: 
 9:     init(
10:         isSelected: Bool = false,
11:         expandHorizontally: Bool = false,
12:         action: @escaping () -> Void,
13:         @ViewBuilder label: @escaping () -> Label
14:     ) {
15:         self.isSelected = isSelected
16:         self.expandHorizontally = expandHorizontally
17:         self.action = action
18:         self.label = label
19:     }
20: 
21:     var body: some View {
22:         Button(action: action) {
23:             label()
24:                 .foregroundColor(.black)
25:                 .padding(.horizontal, 12)
26:                 .padding(.vertical, 8)
27:                 .frame(height: 36)
28:                 .background(.thinMaterial)
29:                 .cornerRadius(8)
30:                 .fixedSize(horizontal: !expandHorizontally, vertical: false)
31:         }
32:     }
33: }
34: 
35: #Preview {
36:     VStack(spacing: 20) {
37:         AdaptiveColorButton {
38:             print("Tapped")
39:         } label: {
40:             Text("Default Button")
41:         }
42: 
43:         AdaptiveColorButton(expandHorizontally: true) {
44:             print("Tapped")
45:         } label: {
46:             Text("Expanded Button")
47:         }
48: 
49:         AdaptiveColorButton {
50:             print("Tapped")
51:         } label: {
52:             HStack {
53:                 Image(systemName: "star.fill")
54:                 Text("Icon Button")
55:             }
56:         }
57:     }
58:     .padding()
59:     .frame(maxWidth: .infinity)
60:     .background(Color.black)
61: }
</file>

<file path="sightline/sightline/Views/Components/FloatingMenuButton.swift">
  1: import SwiftUI
  2: 
  3: 
  4: extension View {
  5:     @ViewBuilder func `if`<Content: View>(
  6:         _ condition: Bool,
  7:         transform: (Self) -> Content
  8:     ) -> some View {
  9:         if condition {
 10:             transform(self)
 11:         } else {
 12:             self
 13:         }
 14:     }
 15: }
 16: 
 17: struct FloatingMenuButton<Label: View>: View {
 18:     let action: () -> Void
 19:     let label: () -> Label
 20:     let isSelected: Bool
 21:     let expandHorizontally: Bool
 22: 
 23:     @State private var buttonFrame: CGRect = .zero
 24: 
 25:     init(
 26:         action: @escaping () -> Void,
 27:         isSelected: Bool = false,
 28:         expandHorizontally: Bool = false,
 29:         @ViewBuilder label: @escaping () -> Label
 30:     ) {
 31:         self.action = action
 32:         self.isSelected = isSelected
 33:         self.expandHorizontally = expandHorizontally
 34:         self.label = label
 35:     }
 36: 
 37:     var body: some View {
 38:         AdaptiveColorButton(
 39:             isSelected: isSelected,
 40:             expandHorizontally: expandHorizontally,
 41:             action: action,
 42:             label: label
 43:         )
 44:         .background(
 45:             GeometryReader { geo in
 46:                 Color.clear.onAppear {
 47:                     buttonFrame = geo.frame(in: .global)
 48:                 }
 49:             }
 50:         )
 51:     }
 52: }
 53: 
 54: struct FloatingMenu<T: Identifiable>: View {
 55:     let items: [T]
 56:     let itemTitle: (T) -> String
 57:     let selectedId: T.ID?
 58:     let onSelect: (T) -> Void
 59:     let alignment: HorizontalAlignment
 60:     @Binding var isExpanded: Bool
 61:     let onExploreMore: (() -> Void)?
 62: 
 63: 
 64:     @Namespace private var menuAnimation
 65: 
 66:     init(
 67:         items: [T],
 68:         itemTitle: @escaping (T) -> String,
 69:         selectedId: T.ID?,
 70:         onSelect: @escaping (T) -> Void,
 71:         alignment: HorizontalAlignment,
 72:         isExpanded: Binding<Bool>,
 73:         onExploreMore: (() -> Void)? = nil
 74:     ) {
 75:         self.items = items
 76:         self.itemTitle = itemTitle
 77:         self.selectedId = selectedId
 78:         self.onSelect = onSelect
 79:         self.alignment = alignment
 80:         self._isExpanded = isExpanded
 81:         self.onExploreMore = onExploreMore
 82:     }
 83: 
 84:     var body: some View {
 85: 
 86:         let triggerItem = items.first { $0.id == selectedId } ?? items.first
 87: 
 88:         VStack(alignment: alignment, spacing: 12) {
 89: 
 90:             VStack(alignment: alignment, spacing: 0) {
 91:                 FloatingMenuButton(
 92:                     action: {
 93:                         withAnimation(.spring(response: 0.4, dampingFraction: 0.8, blendDuration: 0.1)) {
 94: 
 95:                                 isExpanded.toggle()
 96: 
 97: 
 98: 
 99:                         }
100:                     },
101:                     isSelected: triggerItem?.id == selectedId,
102:                     expandHorizontally: alignment == .leading
103:                 ) {
104: 
105: 
106:                     Text(triggerItem.map(itemTitle) ?? "")
107:                         .if(!isExpanded) { view in
108:                             view.matchedGeometryEffect(id: "menuItem", in: menuAnimation)
109:                         }
110:                 }
111:             }
112: 
113: 
114:             VStack(alignment: alignment, spacing: 12) {
115:                 ForEach(Array(items.filter { $0.id != triggerItem?.id }.enumerated()),
116:                         id: \.element.id) { index, item in
117:                     FloatingMenuButton(
118:                         action: {
119:                             withAnimation(
120:                                 .spring(response: 0.4, dampingFraction: 0.8, blendDuration: 0.1)
121:                                     .delay(Double(index) * 0.05)
122:                             ) {
123:                                 onSelect(item)
124:                                 isExpanded = false
125:                             }
126:                         },
127:                         isSelected: item.id == selectedId,
128:                         expandHorizontally: alignment == .leading
129:                     ) {
130: 
131:                         Text(itemTitle(item))
132:                             .if(item.id == selectedId && isExpanded) { view in
133:                                 view.matchedGeometryEffect(id: "menuItem", in: menuAnimation)
134:                             }
135:                     }
136:                     .offset(x: isExpanded ? 0 : (alignment == .leading ? -200 : 200))
137:                     .animation(
138:                         .spring(response: 0.4, dampingFraction: 0.8, blendDuration: 0.1)
139:                             .delay(Double(index) * 0.05),
140:                         value: isExpanded
141:                     )
142:                 }
143: 
144: 
145: 
146: 
147: 
148: 
149: 
150: 
151: 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
164: 
165: 
166:             }
167:             .clipped()
168:             .frame(height: isExpanded ? nil : 0)
169:         }
170:         .frame(maxHeight: .infinity, alignment: .top)
171:     }
172: }
173: 
174: #Preview("FloatingMenu") {
175:     struct PreviewItem: Identifiable {
176:         let id: String
177:         let name: String
178:     }
179: 
180:     struct PreviewWrapper: View {
181:         @State private var leftExpanded = false
182:         @State private var rightExpanded = false
183:         @State private var singleExpanded = false
184:         @State private var leftSelected = "1"
185:         @State private var rightSelected = "2"
186: 
187:         let items = [
188:             PreviewItem(id: "1", name: "Dashboard"),
189:             PreviewItem(id: "2", name: "Reports"),
190:             PreviewItem(id: "3", name: "Settings")
191:         ]
192: 
193:         var body: some View {
194:             ZStack {
195:                 Color.black.ignoresSafeArea()
196: 
197:                 VStack(spacing: 40) {
198: 
199:                     FloatingMenu(
200:                         items: items,
201:                         itemTitle: { $0.name },
202:                         selectedId: leftSelected,
203:                         onSelect: { item in
204:                             leftSelected = item.id
205:                             leftExpanded = false
206:                         },
207:                         alignment: .leading,
208:                         isExpanded: $leftExpanded
209:                     )
210: 
211: 
212:                     FloatingMenu(
213:                         items: items,
214:                         itemTitle: { $0.name },
215:                         selectedId: rightSelected,
216:                         onSelect: { item in
217:                             rightSelected = item.id
218:                             rightExpanded = false
219:                         },
220:                         alignment: .trailing,
221:                         isExpanded: $rightExpanded
222:                     )
223: 
224: 
225:                     FloatingMenu(
226:                         items: [items[0]],
227:                         itemTitle: { $0.name },
228:                         selectedId: "1",
229:                         onSelect: { _ in },
230:                         alignment: .leading,
231:                         isExpanded: $singleExpanded,
232:                         onExploreMore: {}
233:                     )
234:                 }
235:                 .padding()
236:             }
237:         }
238:     }
239: 
240:     return PreviewWrapper()
241: }
</file>

<file path="sightline/sightline/Views/Components/ScanningAnimation.swift">
 1: import SwiftUI
 2: 
 3: struct ScanningAnimation: View {
 4:     let namespace: Namespace.ID
 5:     @State private var position: CGFloat = 0.0
 6: 
 7:     var body: some View {
 8:         GeometryReader { geometry in
 9:             let halfHeight = geometry.size.height / 2
10:             let scanningTop = geometry.size.height * 0.1 - halfHeight
11:             let scanningBottom = geometry.size.height * 0.9 - halfHeight
12: 
13:             ZStack {
14: 
15:                 Rectangle()
16:                     .fill(
17:                         LinearGradient(
18:                             gradient: Gradient(colors: [
19:                                 .clear,
20:                                 .blue.opacity(0.5),
21:                                 .blue,
22:                                 .blue.opacity(0.5),
23:                                 .clear
24:                             ]),
25:                             startPoint: .leading,
26:                             endPoint: .trailing
27:                         )
28:                     )
29:                     .frame(height: 3)
30:                     .offset(y: position)
31:                     .shadow(color: .blue.opacity(0.5), radius: 4)
32: 
33: 
34:                 ScannerCorners()
35:                     .stroke(Color.white.opacity(0.7), lineWidth: 3)
36:                     .frame(width: geometry.size.width * 0.8,
37:                            height: geometry.size.height * 0.7)
38:                     .position(x: geometry.size.width / 2,
39:                              y: geometry.size.height / 2)
40:             }
41:             .onAppear {
42:                 position = scanningTop
43:                 withAnimation(
44:                     .easeInOut(duration: 2.0)
45:                         .repeatForever(autoreverses: true)
46:                 ) {
47:                     position = scanningBottom
48:                 }
49:             }
50:         }
51:     }
52: }
53: 
54: struct ScannerCorners: Shape {
55:     func path(in rect: CGRect) -> Path {
56:         var path = Path()
57:         let cornerLength: CGFloat = 30
58: 
59: 
60:         path.move(to: CGPoint(x: rect.minX, y: rect.minY + cornerLength))
61:         path.addLine(to: CGPoint(x: rect.minX, y: rect.minY))
62:         path.addLine(to: CGPoint(x: rect.minX + cornerLength, y: rect.minY))
63: 
64: 
65:         path.move(to: CGPoint(x: rect.maxX - cornerLength, y: rect.minY))
66:         path.addLine(to: CGPoint(x: rect.maxX, y: rect.minY))
67:         path.addLine(to: CGPoint(x: rect.maxX, y: rect.minY + cornerLength))
68: 
69: 
70:         path.move(to: CGPoint(x: rect.maxX, y: rect.maxY - cornerLength))
71:         path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY))
72:         path.addLine(to: CGPoint(x: rect.maxX - cornerLength, y: rect.maxY))
73: 
74: 
75:         path.move(to: CGPoint(x: rect.minX + cornerLength, y: rect.maxY))
76:         path.addLine(to: CGPoint(x: rect.minX, y: rect.maxY))
77:         path.addLine(to: CGPoint(x: rect.minX, y: rect.maxY - cornerLength))
78: 
79:         return path
80:     }
81: }
</file>

<file path="sightline/sightline/Views/Components/ScanningTransitionView.swift">
 1: import SwiftUI
 2: 
 3: struct ScanningTransitionView: View {
 4:     let namespace: Namespace.ID
 5:     @State private var animateTransition = false
 6: 
 7:     var body: some View {
 8:         GeometryReader { geometry in
 9:             ZStack {
10: 
11:                 Rectangle()
12:                     .fill(
13:                         LinearGradient(
14:                             gradient: Gradient(colors: [
15:                                 .clear,
16:                                 .blue.opacity(0.9),
17:                                 .blue,
18:                                 .blue.opacity(0.9),
19:                                 .clear
20:                             ]),
21:                             startPoint: .leading,
22:                             endPoint: .trailing
23:                         )
24:                     )
25: 
26:                     .frame(height: animateTransition ? 100 : 3)
27:                     .shadow(color: .blue.opacity(animateTransition ? 1.0 : 0.5),
28:                             radius: animateTransition ? 30 : 4)
29:                     .matchedGeometryEffect(id: "scannerLine", in: namespace)
30:                     .opacity(animateTransition ? 0 : 1)
31: 
32: 
33:                 ScannerCorners()
34:                     .stroke(Color.white.opacity(0.7), lineWidth: animateTransition ? 1 : 3)
35:                     .frame(width: animateTransition ? geometry.size.width * 1.5 : geometry.size.width * 0.8,
36:                            height: animateTransition ? geometry.size.height * 1.5 : geometry.size.height * 0.8)
37:                     .position(x: geometry.size.width / 2, y: geometry.size.height / 2)
38:                     .matchedGeometryEffect(id: "scannerCorners", in: namespace)
39:                     .opacity(animateTransition ? 0 : 1)
40:             }
41:             .onAppear {
42: 
43:                 withAnimation(.easeInOut(duration: 1.2)) {
44:                     animateTransition = true
45:                 }
46:             }
47:         }
48:         .ignoresSafeArea()
49:     }
50: }
</file>

<file path="sightline/sightline/Views/ContentFeed/Components/CategorySelectorView.swift">
 1: import SwiftUI
 2: @MainActor
 3: struct CategorySelectorView: View {
 4:   @Binding var selectedCategory: FilterCategory
 5:   @EnvironmentObject var appStore: AppStore
 6:     @Binding var isExpanded: Bool
 7:     let onCategorySelected: () -> Void
 8: 
 9:     var body: some View {
10:         FloatingMenu(
11:           items: appStore.availableCategories,
12:           itemTitle: {$0.rawValue.capitalized},
13:           selectedId: selectedCategory.rawValue,
14:           onSelect: {category in
15:             appStore.contentItems = []
16:             appStore.places = [:]
17:             selectedCategory = category
18:             isExpanded = false
19:             onCategorySelected()
20:           },
21:           alignment: .trailing,
22:           isExpanded: $isExpanded
23:         ).task {
24:           await appStore.loadAvailableCategories()
25:         }
26:     }
27: }
</file>

<file path="sightline/sightline/Views/ContentFeed/Components/NeighborhoodSelectorView.swift">
 1: import SwiftUI
 2: 
 3: struct NeighborhoodSelectorView: View {
 4:     @Binding var selectedNeighborhood: Neighborhood?
 5:     @EnvironmentObject var appStore: AppStore
 6:     @Binding var isExpanded: Bool
 7:     let onExploreMore: () -> Void
 8:     let onNeighborhoodSelected: () -> Void
 9: 
10:     var body: some View {
11:         FloatingMenu(
12:             items: appStore.unlockedNeighborhoods,
13:             itemTitle: { $0.name },
14:             selectedId: selectedNeighborhood?.id,
15:             onSelect: { neighborhood in
16:                 withAnimation {
17:                     appStore.contentItems = []
18:                     appStore.places = [:]
19:                     selectedNeighborhood = neighborhood
20:                     isExpanded = false
21:                     onNeighborhoodSelected()
22:                 }
23:             },
24:             alignment: .leading,
25:             isExpanded: $isExpanded,
26:             onExploreMore: onExploreMore
27:         )
28:         .task {
29:             if appStore.unlockedNeighborhoods.isEmpty {
30:                 await appStore.loadUnlockedNeighborhoods()
31:             }
32:             if selectedNeighborhood == nil, let first = appStore.unlockedNeighborhoods.first {
33:                 selectedNeighborhood = first
34:                 onNeighborhoodSelected()
35:             }
36:         }
37:     }
38: }
</file>

<file path="sightline/sightline/Views/ContentFeed/ContentFeedView.swift">
  1: import SwiftUI
  2: import UIKit
  3: 
  4: struct ContentFeedView: View {
  5:     @EnvironmentObject var appState: AppState
  6:     @EnvironmentObject var appStore: AppStore
  7: 
  8:     @State private var showingNeighborhoods = false
  9:     @State private var showingCategories = false
 10:     @State private var selectedPlaceId: String? = nil
 11: 
 12:     var body: some View {
 13:         ZStack(alignment: .top) {
 14:             Color.black.ignoresSafeArea()
 15: 
 16:             contentDisplay
 17:                 .zIndex(0)
 18: 
 19:             menuBar
 20:                 .zIndex(2)
 21:         }
 22: 
 23:         .sheet(item: Binding(
 24:             get: { selectedPlaceId.map { PlaceDetailPresentation(placeId: $0) } },
 25:             set: { presentation in selectedPlaceId = presentation?.placeId }
 26:         )) {
 27:             presentation in
 28:             PlaceDetailView(placeId: presentation.placeId)
 29:                 .presentationDetents([.medium, .large])
 30:                 .presentationDragIndicator(.visible)
 31:                 .presentationBackgroundInteraction(.enabled)
 32:         }
 33:         .task {
 34: 
 35:             await appStore.loadUnlockedNeighborhoods()
 36:         }
 37:     }
 38: 
 39:     @ViewBuilder
 40:     private var contentDisplay: some View {
 41:         if appStore.unlockedNeighborhoods.isEmpty {
 42:             EmptyNeighborhoodState()
 43:         } else if appStore.isLoadingContent {
 44:             VStack {
 45:                 Spacer()
 46:                 ProgressView()
 47:                     .progressViewStyle(CircularProgressViewStyle(tint: .white))
 48:                 Spacer()
 49:             }
 50:         } else if appStore.contentItems.isEmpty {
 51:             Text("No content available")
 52:                 .foregroundColor(.white)
 53:         } else {
 54:             feedView
 55:         }
 56:     }
 57: 
 58:     private var feedView: some View {
 59:         VerticalFeedView(
 60:             currentIndex: $appStore.currentIndex,
 61:             itemCount: appStore.contentItems.count,
 62:             feedVersion: appStore.feedVersion,
 63:             onIndexChanged: { newIndex, oldIndex in
 64: 
 65:                 if oldIndex >= 0, oldIndex < appStore.contentItems.count {
 66:                     let oldVideoUrl = appStore.contentItems[oldIndex].videoUrl
 67:                     appStore.videoManager.pause(url: oldVideoUrl)
 68:                 }
 69: 
 70: 
 71:                 appStore.currentIndex = newIndex
 72:             }
 73:         ) { index in
 74: 
 75:             if index >= 0 && index < appStore.contentItems.count {
 76:                 let content = appStore.contentItems[index]
 77:                 ContentItemView(content: content, appStore: appStore)
 78:                     .environmentObject(appStore)
 79:                     .onTapGesture {
 80:                         if let placeId = content.placeIds.first {
 81:                             selectedPlaceId = placeId
 82:                         }
 83:                     }
 84:             } else {
 85:                 Color.black
 86:                     .frame(maxWidth: .infinity, maxHeight: .infinity)
 87:             }
 88:         }
 89:         .ignoresSafeArea()
 90:         .onAppear {
 91: 
 92:             if !appStore.contentItems.isEmpty {
 93:                 appStore.videoManager.play(url: appStore.contentItems[appStore.currentIndex].videoUrl)
 94:             }
 95:         }
 96:     }
 97: 
 98:     private var menuBar: some View {
 99:         HStack(alignment: .top) {
100:             NeighborhoodSelectorView(
101:                 selectedNeighborhood: $appStore.selectedNeighborhood,
102:                 isExpanded: $showingNeighborhoods,
103:                 onExploreMore: { appState.shouldSwitchToDiscover = true },
104:                 onNeighborhoodSelected: { Task { await appStore.loadContent() } }
105:             )
106: 
107:             Spacer()
108: 
109:             if let neighborhoodId = appStore.selectedNeighborhood?.id {
110:                 CategorySelectorView(
111:                     selectedCategory: $appStore.selectedCategory,
112:                     isExpanded: $showingCategories,
113:                     onCategorySelected: { Task { await appStore.loadContent() } }
114:                 )
115:                 .id(neighborhoodId)
116:             } else {
117:                 Text("Select a neighborhood").foregroundColor(.white)
118:             }
119:         }
120:         .padding(.top, 24)
121:         .padding(.horizontal, 16)
122:     }
123: }
124: 
125: struct PlaceDetailPresentation: Identifiable {
126:     let id = UUID()
127:     let placeId: String
128: }
</file>

<file path="sightline/sightline/Views/ContentFeed/ContentItemView.swift">
  1: import SwiftUI
  2: import AVKit
  3: import FirebaseStorage
  4: 
  5: struct ContentItemView: View {
  6:     @EnvironmentObject var appState: AppState
  7:     @EnvironmentObject var appStore: AppStore
  8:     let content: Content
  9: 
 10:     @State private var showingPlaceDetail = false
 11:     @Environment(\.safeAreaInsets) private var safeAreaInsets
 12: 
 13: 
 14:     @ObservedObject private var videoManager: VideoPlayerManager
 15: 
 16:     init(content: Content, appStore: AppStore) {
 17:         self.content = content
 18:         self.videoManager = appStore.videoManager
 19:     }
 20: 
 21:     var body: some View {
 22:         GeometryReader { geo in
 23:             ZStack {
 24:                 if let player = videoManager.playerFor(url: content.videoUrl) {
 25: 
 26:                     VideoPlayer(player: player)
 27:                         .edgesIgnoringSafeArea(.all)
 28:                         .frame(
 29:                             width: geo.size.width,
 30:                             height: geo.size.height + safeAreaInsets.top + safeAreaInsets.bottom
 31:                         )
 32:                         .offset(y: -safeAreaInsets.top)
 33:                 } else if videoManager.error != nil {
 34: 
 35:                     Color.black
 36:                     VStack {
 37:                         Image(systemName: "exclamationmark.triangle")
 38:                             .font(.largeTitle)
 39:                             .foregroundColor(.yellow)
 40:                         Text("Failed to load video")
 41:                             .foregroundColor(.white)
 42:                     }
 43:                 } else {
 44: 
 45:                     Color.black
 46:                     ProgressView()
 47:                         .scaleEffect(1.5)
 48:                         .tint(.white)
 49:                 }
 50: 
 51: 
 52:                 VStack {
 53:                     Spacer()
 54:                     HStack {
 55:                         VStack(alignment: .leading, spacing: 8) {
 56:                             Text(content.caption)
 57:                                 .font(.headline)
 58:                                 .foregroundColor(.white)
 59:                                 .multilineTextAlignment(.leading)
 60: 
 61:                             Button {
 62:                                 showingPlaceDetail = true
 63:                             } label: {
 64:                                 Text(appStore.places[content.placeIds.first ?? ""]?.name ?? "Loading place...")
 65:                                     .font(.subheadline)
 66:                                     .foregroundColor(.white)
 67:                                     .padding(.horizontal, 12)
 68:                                     .padding(.vertical, 6)
 69:                                     .background(.ultraThinMaterial)
 70:                                     .cornerRadius(16)
 71:                             }
 72:                         }
 73:                         Spacer()
 74:                     }
 75:                     .padding(.horizontal)
 76:                     .padding(.bottom, 120)
 77:                     .background(
 78:                         LinearGradient(
 79:                             gradient: Gradient(colors: [.clear, .black.opacity(0.3)]),
 80:                             startPoint: .top,
 81:                             endPoint: .bottom
 82:                         )
 83:                         .padding(.top, -100)
 84:                     )
 85:                 }
 86:             }
 87:         }
 88:         .sheet(isPresented: $showingPlaceDetail) {
 89:             if let firstPlaceId = content.placeIds.first {
 90:                 PlaceDetailView(placeId: firstPlaceId, mode: .discovery)
 91:                     .presentationDetents([.fraction(0.75), .large])
 92:                     .presentationDragIndicator(.visible)
 93:             }
 94:         }
 95: 
 96:         .onAppear {
 97:             videoManager.play(url: content.videoUrl)
 98:         }
 99:         .onDisappear {
100:             videoManager.pause()
101:         }
102:     }
103: }
104: 
105: private extension EnvironmentValues {
106:     var safeAreaInsets: EdgeInsets {
107:         (UIApplication.shared.windows.first?.safeAreaInsets ?? .zero).insets
108:     }
109: }
110: 
111: private extension UIEdgeInsets {
112:     var insets: EdgeInsets {
113:         EdgeInsets(top: top, leading: left, bottom: bottom, trailing: right)
114:     }
115: }
</file>

<file path="sightline/sightline/Views/ContentFeed/EmptyNeighborhoodState.swift">
 1: import SwiftUI
 2: 
 3: 
 4: struct EmptyNeighborhoodState: View {
 5:     var body: some View {
 6:         GeometryReader { geometry in
 7:             ScrollView {
 8:                 ZStack {
 9: 
10:                     Image("nocontent")
11:                         .resizable()
12:                         .aspectRatio(contentMode: .fill)
13:                         .frame(width: geometry.size.width, height: geometry.size.height)
14:                         .clipped()
15:                         .ignoresSafeArea()
16: 
17: 
18:                     VStack(spacing: 24) {
19:                         VStack(spacing: 16) {
20: 
21:                             Text("Unlock Your First Neighborhood")
22:                                 .font(.custom("Baskerville-Bold", size: 28))
23:                                 .multilineTextAlignment(.center)
24:                                 .foregroundColor(.black)
25:                                 .opacity(0.9)
26:                                 .lineLimit(nil)
27:                                 .fixedSize(horizontal: false, vertical: true)
28: 
29:                             Text("Discover local landmarks to unlock neighborhood content and start exploring stories from your community")
30:                                 .font(.custom("Baskerville", size: 18))
31:                                 .foregroundColor(.black)
32:                                 .multilineTextAlignment(.center)
33: 
34:                             Image(systemName: "camera.viewfinder")
35:                                 .font(.system(size: 72))
36:                                 .foregroundColor(.black.opacity(0.9))
37:                                 .padding(.top, 8)
38:                         }
39:                         .padding(24)
40:                         .background(.thinMaterial)
41:                         .cornerRadius(16)
42:                         .shadow(radius: 8)
43:                     }
44:                     .padding()
45:                 }
46:                 .frame(minHeight: geometry.size.height)
47:             }
48:             .ignoresSafeArea(edges: .top)
49:         }
50:         .ignoresSafeArea(edges: .top)
51:     }
52: }
</file>

<file path="sightline/sightline/Views/ContentFeed/VerticalFeedView.swift">
  1: import SwiftUI
  2: import UIKit
  3: 
  4: struct VerticalFeedView<Content: View>: UIViewControllerRepresentable {
  5: 
  6:     let onIndexChanged: (Int, Int) -> Void
  7:     let content: (Int) -> Content
  8: 
  9:     @Binding var currentIndex: Int
 10:     let itemCount: Int
 11: 
 12: 
 13:     let feedVersion: Int
 14: 
 15:     init(
 16:         currentIndex: Binding<Int>,
 17:         itemCount: Int,
 18:         feedVersion: Int,
 19:         onIndexChanged: @escaping (Int, Int) -> Void,
 20:         @ViewBuilder content: @escaping (Int) -> Content
 21:     ) {
 22:         self._currentIndex = currentIndex
 23:         self.itemCount = itemCount
 24:         self.feedVersion = feedVersion
 25:         self.onIndexChanged = onIndexChanged
 26:         self.content = content
 27:     }
 28: 
 29:     func makeCoordinator() -> Coordinator {
 30:         Coordinator(self)
 31:     }
 32: 
 33:     func makeUIViewController(context: Context) -> UIPageViewController {
 34:         let controller = UIPageViewController(
 35:             transitionStyle: .scroll,
 36:             navigationOrientation: .vertical,
 37:             options: [.interPageSpacing: 0]
 38:         )
 39:         controller.dataSource = context.coordinator
 40:         controller.delegate = context.coordinator
 41:         controller.view.backgroundColor = .black
 42: 
 43: 
 44:         controller.view.gestureRecognizers?.forEach { gesture in
 45:             (gesture as? UIScreenEdgePanGestureRecognizer)?.isEnabled = false
 46:         }
 47: 
 48: 
 49:         let hostingController = context.coordinator.hostingController(for: currentIndex)
 50:         controller.setViewControllers([hostingController], direction: .forward, animated: false)
 51: 
 52:         return controller
 53:     }
 54: 
 55:     func updateUIViewController(_ uiViewController: UIPageViewController, context: Context) {
 56:         let coordinator = context.coordinator
 57: 
 58: 
 59:         guard currentIndex >= 0 && currentIndex < itemCount else {
 60:             DispatchQueue.main.async {
 61:                 self.currentIndex = max(0, min(self.itemCount - 1, self.currentIndex))
 62:             }
 63:             return
 64:         }
 65: 
 66: 
 67:         if coordinator.feedVersion != feedVersion {
 68:             coordinator.feedVersion = feedVersion
 69:             coordinator.hostingControllers.removeAll()
 70: 
 71:             let newVC = coordinator.hostingController(for: currentIndex)
 72:             uiViewController.setViewControllers([newVC], direction: .forward, animated: false)
 73:             coordinator.currentIndex = currentIndex
 74:             return
 75:         }
 76: 
 77: 
 78:         if coordinator.currentIndex != currentIndex {
 79:             let direction: UIPageViewController.NavigationDirection =
 80:                 coordinator.currentIndex > currentIndex ? .reverse : .forward
 81:             let newVC = coordinator.hostingController(for: currentIndex)
 82:             let shouldAnimate = abs(coordinator.currentIndex - currentIndex) <= 1
 83:             uiViewController.setViewControllers([newVC], direction: direction, animated: shouldAnimate)
 84: 
 85: 
 86:             let oldIndex = coordinator.currentIndex
 87:             coordinator.currentIndex = currentIndex
 88: 
 89:             onIndexChanged(currentIndex, oldIndex)
 90:         }
 91:     }
 92: 
 93:     class Coordinator: NSObject, UIPageViewControllerDataSource, UIPageViewControllerDelegate {
 94:         var parent: VerticalFeedView
 95:         var currentIndex: Int
 96:         var feedVersion: Int
 97: 
 98: 
 99:         var hostingControllers: [Int: UIHostingController<AnyView>] = [:]
100: 
101:         init(_ verticalFeedView: VerticalFeedView) {
102:             self.parent = verticalFeedView
103:             self.currentIndex = verticalFeedView.currentIndex
104:             self.feedVersion = verticalFeedView.feedVersion
105:         }
106: 
107:         func hostingController(for index: Int) -> UIHostingController<AnyView> {
108:             guard index >= 0 && index < parent.itemCount else {
109:                 return UIHostingController(rootView: AnyView(Color.black))
110:             }
111:             if let existing = hostingControllers[index] {
112:                 return existing
113:             }
114:             let newView = AnyView(
115:                 parent.content(index)
116:                     .frame(maxWidth: .infinity, maxHeight: .infinity)
117:                     .background(Color.black)
118:             )
119:             let controller = UIHostingController(rootView: newView)
120:             controller.view.backgroundColor = .clear
121:             hostingControllers[index] = controller
122:             cleanupDistantControllers(from: index)
123:             return controller
124:         }
125: 
126:         private func cleanupDistantControllers(from currentIndex: Int) {
127: 
128:             let keepRange = (currentIndex - 2)...(currentIndex + 2)
129:             hostingControllers = hostingControllers.filter { keepRange.contains($0.key) }
130:         }
131: 
132: 
133:         func pageViewController(_ pageViewController: UIPageViewController,
134:                                 viewControllerBefore viewController: UIViewController) -> UIViewController? {
135:             let index = currentIndex - 1
136:             guard index >= 0 else { return nil }
137:             return hostingController(for: index)
138:         }
139: 
140:         func pageViewController(_ pageViewController: UIPageViewController,
141:                                 viewControllerAfter viewController: UIViewController) -> UIViewController? {
142:             let index = currentIndex + 1
143:             guard index < parent.itemCount else { return nil }
144:             return hostingController(for: index)
145:         }
146: 
147: 
148:         func pageViewController(_ pageViewController: UIPageViewController,
149:                                 didFinishAnimating finished: Bool,
150:                                 previousViewControllers: [UIViewController],
151:                                 transitionCompleted completed: Bool) {
152:             guard completed,
153:                   let visibleVC = pageViewController.viewControllers?.first,
154:                   let newIndex = hostingControllers.first(where: { $0.value == visibleVC })?.key
155:             else { return }
156: 
157:             let oldIndex = currentIndex
158:             currentIndex = newIndex
159: 
160: 
161:             parent.onIndexChanged(newIndex, oldIndex)
162:         }
163:     }
164: }
</file>

<file path="sightline/sightline/Views/Profile/AuthView.swift">
  1: import SwiftUI
  2: import FirebaseAuth
  3: 
  4: struct AuthView: View {
  5:     @EnvironmentObject var profileStore: ProfileStore
  6:     @State private var isSignIn = false
  7:     @State private var email = ""
  8:     @State private var password = ""
  9:     @State private var confirmPassword = ""
 10: 
 11:     var body: some View {
 12:         GeometryReader { geometry in
 13:             ScrollView {
 14:                 ZStack {
 15:                     // Background Image (Keep this)
 16:                     Image("profile-bg")
 17:                         .resizable()
 18:                         .aspectRatio(contentMode: .fill)
 19:                         .frame(width: geometry.size.width, height: geometry.size.height)
 20:                         .clipped()
 21:                         .ignoresSafeArea()
 22: 
 23: 
 24:                     VStack(spacing: 24) {
 25:                         VStack(spacing: 24) {
 26: 
 27:                             VStack(spacing: 8) {
 28:                                 Text(isSignIn ? "Sign In" : "Create an Account")
 29:                                 .font(.custom("Baskerville-Bold", size: 24))
 30:                                 .foregroundColor(.black)
 31: 
 32:                                 if profileStore.hasPendingSavedPlaces {
 33:                                     Text("Sign up to save your places!")
 34:                                         .font(.custom("Baskerville", size: 18))
 35:                                         .foregroundColor(.black)
 36:                                         .multilineTextAlignment(.center)
 37:                                         .padding(.horizontal)
 38:                                 } else {
 39:                                     Text(isSignIn ? "Welcome Back" : "Save Places, Post Content, and More")
 40:                                         .font(.custom("Baskerville", size: 18))
 41:                                         .foregroundColor(.black)
 42:                                         .multilineTextAlignment(.center)
 43:                                 }
 44:                             }
 45: 
 46: 
 47:                             VStack(spacing: 16) {
 48:                                 TextField("Email", text: $email)
 49:                                     .textContentType(.emailAddress)
 50:                                     .keyboardType(.emailAddress)
 51:                                     .autocapitalization(.none)
 52:                                     .foregroundColor(.black)
 53: 
 54: 
 55:                                 SecureField("Password", text: $password)
 56:                                     .textContentType(isSignIn ? .password : .newPassword)
 57:                                     .foregroundColor(.black)
 58: 
 59: 
 60: 
 61:                                 if !isSignIn {
 62:                                     SecureField("Confirm Password", text: $confirmPassword)
 63:                                         .textContentType(.newPassword)
 64: 
 65:                                 }
 66:                             }
 67: 
 68:                             if let error = profileStore.errorMessage {
 69:                                 Text(error)
 70:                                     .foregroundColor(.red)
 71:                                     .font(.caption)
 72:                                     .padding(.horizontal)
 73:                             }
 74: 
 75:                             Button(action: {
 76:                                 Task {
 77:                                     if isSignIn {
 78:                                         await profileStore.signIn(email: email, password: password)
 79:                                     } else {
 80:                                         await profileStore.signUp(email: email, password: password, confirmPassword: confirmPassword)
 81:                                     }
 82:                                 }
 83:                             }) {
 84:                                 if profileStore.isLoading {
 85:                                     ProgressView()
 86:                                         .progressViewStyle(CircularProgressViewStyle(tint: .white))
 87:                                 } else {
 88:                                     Text(isSignIn ? "Sign In" : "Create Account")
 89:                                         .frame(maxWidth: .infinity)
 90:                                         .foregroundColor(.white)
 91:                                 }
 92:                             }
 93:                             .padding()
 94:                             .background(Color.yellow)
 95:                             .cornerRadius(10)
 96:                             .disabled(profileStore.isLoading)
 97: 
 98: 
 99:                             Button(action: {
100:                                 withAnimation {
101:                                     isSignIn.toggle()
102:                                     profileStore.errorMessage = nil
103:                                 }
104:                             }) {
105:                                 Text(isSignIn ? "Need an account? Sign Up" : "Already have an account? Sign In")
106:                                     .foregroundColor(.white)
107:                                     .underline()
108:                             }
109:                         }
110:                         .padding(24)
111:                         .background(.thinMaterial)
112:                         .cornerRadius(16)
113:                         .shadow(radius: 8)
114: 
115:                         Button(action: {
116:                             Task {
117:                                 await profileStore.resetAccount()
118:                             }
119:                         }) {
120:                             Text("Reset Account")
121:                                 .frame(maxWidth: .infinity)
122:                                 .padding()
123:                                 .background(Color.red.opacity(0.9))
124:                                 .foregroundColor(.white)
125:                                 .cornerRadius(10)
126:                         }
127:                     }
128:                     .padding()
129:                 }
130:                 .frame(minHeight: geometry.size.height)
131:             }
132:             .scrollDismissesKeyboard(.interactively)
133:             .ignoresSafeArea(edges: .top)
134:         }
135:         .ignoresSafeArea(edges: .top)
136:     }
137: }
</file>

<file path="sightline/sightline/Views/Profile/ProfileView.swift">
 1: import SwiftUI
 2: import FirebaseAuth
 3: 
 4: struct ProfileView: View {
 5:     @EnvironmentObject private var appState: AppState
 6:     @EnvironmentObject private var profileStore: ProfileStore
 7: 
 8:     var body: some View {
 9:         ZStack {
10:             if profileStore.isLoading {
11:                 ProgressView()
12:             } else if profileStore.isAnonymous {
13:                 AuthView()
14:                     .environmentObject(profileStore)
15:             } else {
16:                 UserProfileView()
17:                     .environmentObject(profileStore)
18:                     .navigationTitle("Profile")
19:             }
20:         }
21:     }
22: }
</file>

<file path="sightline/sightline/Views/Profile/UserProfileView.swift">
  1: import SwiftUI
  2: 
  3: 
  4: struct UserProfileView: View {
  5:     @EnvironmentObject var profileStore: ProfileStore
  6:     @State private var showProfileMenu = false
  7:     @State private var selectedPlace: Place?
  8:     @State private var showPlaceDetail = false
  9: 
 10:     var body: some View {
 11:         ScrollView {
 12:             VStack(spacing: 20) {
 13:                 profileSection
 14:                     .padding(.top, 60)
 15: 
 16:                 unlockedNeighborhoodsSection
 17: 
 18:                 savedPlacesSection
 19: 
 20:                 Spacer(minLength: 20)
 21:             }
 22:             .padding(.horizontal)
 23:         }
 24:         .background(
 25:             Image("profile-bg")
 26:                 .resizable()
 27:                 .aspectRatio(contentMode: .fill)
 28:                 .ignoresSafeArea()
 29:         )
 30:         .onAppear {
 31:             Task {
 32:                 await profileStore.loadData()
 33:             }
 34:         }
 35:         .confirmationDialog("Profile Options", isPresented: $showProfileMenu) {
 36:             Button("Sign Out", role: .destructive) {
 37:                 Task {
 38:                     await profileStore.signOut()
 39:                 }
 40:             }
 41:             Button("Cancel", role: .cancel) { }
 42:         }
 43:     }
 44: 
 45:     private var profileSection: some View {
 46:         Button(action: { showProfileMenu = true }) {
 47:             HStack(spacing: 12) {
 48:                 Image(systemName: "person.circle.fill")
 49:                     .resizable()
 50:                     .frame(width: 40, height: 40)
 51:                     .foregroundColor(.black)
 52: 
 53:                 VStack(alignment: .leading) {
 54:                     Text(profileStore.userEmail ?? "") // Use profileStore
 55:                         .font(.headline)
 56:                         .foregroundColor(.black)
 57:                         .lineLimit(1)
 58:                 }
 59: 
 60:                 Spacer()
 61: 
 62:                 Image(systemName: "chevron.down")
 63:                     .foregroundColor(.black)
 64:             }
 65:             .padding(16)
 66:             .background(
 67:                 RoundedRectangle(cornerRadius: 16)
 68:                     .fill(.ultraThinMaterial)
 69:                     .shadow(radius: 4)
 70:             )
 71:         }
 72:     }
 73: 
 74:     private var unlockedNeighborhoodsSection: some View {
 75:         VStack(alignment: .leading, spacing: 16) {
 76:             Text("Unlocked Neighborhoods")
 77:                 .font(.title3.bold())
 78:                 .foregroundColor(.black)
 79: 
 80:             if profileStore.unlockedNeighborhoodNames.isEmpty {
 81:                 Button(action: {
 82: 
 83:                 }) {
 84:                     HStack {
 85:                         Text("Unlock your first neighborhood!")
 86:                             .foregroundColor(.black)
 87:                         Spacer()
 88:                         Image(systemName: "camera.fill")
 89:                             .foregroundColor(.black)
 90:                     }
 91:                 }
 92:             } else {
 93:                 ForEach(profileStore.unlockedNeighborhoodNames, id: \.self) { neighborhood in
 94:                     HStack(spacing: 12) {
 95:                         Image(systemName: "checkmark.circle.fill")
 96:                             .foregroundColor(.green)
 97:                         Text(neighborhood)
 98:                             .foregroundColor(.black)
 99:                         Spacer()
100:                     }
101:                 }
102:             }
103:         }
104:         .padding(16)
105:         .background(
106:             RoundedRectangle(cornerRadius: 16)
107:                 .fill(.ultraThinMaterial)
108:                 .shadow(radius: 4)
109:         )
110:     }
111: 
112:     private var savedPlacesSection: some View {
113:         VStack(alignment: .leading, spacing: 16) {
114:             Text("Saved Places")
115:                 .font(.title3.bold())
116:                 .foregroundColor(.black)
117: 
118:             if profileStore.savedPlaces.isEmpty {
119:                 Text("No saved places yet")
120:                     .foregroundColor(.gray)
121:             } else {
122:                 List {
123:                     ForEach(profileStore.savedPlaces) { place in
124:                         PlaceRow(place: place)
125:                             .listRowInsets(EdgeInsets())
126:                             .listRowSeparator(.hidden)
127:                             .listRowBackground(Color.clear)
128:                             .contentShape(Rectangle())
129:                             .onTapGesture {
130:                                 Task {
131: 
132:                                     selectedPlace = place
133:                                     showPlaceDetail = true
134:                                 }
135:                             }
136:                     }
137:                     .onDelete { indexSet in
138:                         guard let index = indexSet.first else { return }
139:                         let place = profileStore.savedPlaces[index]
140:                         Task {
141:                             await profileStore.removeSavedPlace(place)
142:                         }
143:                     }
144:                 }
145:                 .listStyle(.plain)
146:                 .frame(minHeight: CGFloat(profileStore.savedPlaces.count * 60))
147:                 .scrollContentBackground(.hidden)
148:             }
149:         }
150:         .padding(16)
151:         .background(
152:             RoundedRectangle(cornerRadius: 16)
153:                 .fill(.ultraThinMaterial)
154:                 .shadow(radius: 4)
155:         )
156:         .sheet(item: $selectedPlace) { place in
157:             PlaceDetailView(placeId: place.id, mode: .review)
158:         }
159:     }
160: }
161: 
162: 
163: private struct PlaceRow: View {
164:     let place: Place
165: 
166:     var body: some View {
167:         HStack {
168:             VStack(alignment: .leading, spacing: 4) {
169:                 Text(place.name)
170:                     .font(.subheadline.bold())
171:                     .foregroundColor(.black)
172:                 Text(place.address)
173:                     .font(.caption)
174:                     .foregroundColor(.gray)
175:             }
176:             .frame(maxWidth: .infinity, alignment: .leading)
177:             .padding(.vertical, 8)
178: 
179:             Image(systemName: "chevron.right")
180:                 .foregroundColor(.gray)
181:         }
182:     }
183: }
184: 
185: 
186: struct StatView: View {
187:     let title: String
188:     let value: String
189: 
190:     var body: some View {
191:         VStack(spacing: 4) {
192:             Text(value)
193:                 .font(.headline)
194:             Text(title)
195:                 .font(.caption)
196:                 .foregroundColor(.secondary)
197:         }
198:     }
199: }
</file>

<file path="sightline/sightline/Views/CameraView.swift">
  1: import SwiftUI
  2: import AVFoundation
  3: import CoreHaptics
  4: 
  5: class CameraController: NSObject, ObservableObject {
  6:     @Published var isAuthorized = false
  7:     @Published var error: String?
  8:     @Published var isCapturing = false
  9: 
 10:     var captureSession: AVCaptureSession?
 11:     private var videoOutput = AVCaptureVideoDataOutput()
 12:     private(set) var frameCount = 0
 13:     private let maxFrames = 10
 14:     private var captureStartTime: Date?
 15:     private var lastCaptureTime: Date?
 16:     private var onFrameCaptured: ((UIImage) -> Void)?
 17:     private var onCaptureCompleted: (() -> Void)?
 18: 
 19:     private var hasCompletedCapture = false
 20: 
 21:     override init() {
 22:         super.init()
 23:         checkPermissions()
 24:     }
 25: 
 26:     func checkPermissions() {
 27:         switch AVCaptureDevice.authorizationStatus(for: .video) {
 28:         case .authorized:
 29:             self.isAuthorized = true
 30:             setupCamera()
 31:         case .notDetermined:
 32:             AVCaptureDevice.requestAccess(for: .video) { [weak self] granted in
 33:                 DispatchQueue.main.async {
 34:                     self?.isAuthorized = granted
 35:                     if granted {
 36:                         self?.setupCamera()
 37:                     }
 38:                 }
 39:             }
 40:         case .denied, .restricted:
 41:             self.isAuthorized = false
 42:             self.error = "Camera access is denied. Please enable it in Settings."
 43:         @unknown default:
 44:             self.isAuthorized = false
 45:             self.error = "Unknown camera authorization status"
 46:         }
 47:     }
 48: 
 49:     private func setupCamera() {
 50:         let session = AVCaptureSession()
 51:         session.sessionPreset = .medium
 52: 
 53:         guard let device = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back),
 54:               let input = try? AVCaptureDeviceInput(device: device) else {
 55:             error = "Failed to initialize camera"
 56:             return
 57:         }
 58: 
 59:         if session.canAddInput(input) {
 60:             session.addInput(input)
 61:         }
 62: 
 63:         videoOutput.setSampleBufferDelegate(self, queue: DispatchQueue(label: "camera.frame.processing"))
 64: 
 65:         if session.canAddOutput(videoOutput) {
 66:             session.addOutput(videoOutput)
 67:         }
 68: 
 69:         captureSession = session
 70:     }
 71: 
 72:     func startCapturing(onFrameCaptured: @escaping (UIImage) -> Void, onCaptureCompleted: @escaping () -> Void) {
 73:         self.onFrameCaptured = onFrameCaptured
 74:         self.frameCount = 0
 75:         self.lastCaptureTime = nil
 76:         self.captureStartTime = Date()
 77:         self.isCapturing = true
 78:         self.onCaptureCompleted = onCaptureCompleted
 79:         self.hasCompletedCapture = false
 80: 
 81:         DispatchQueue.global(qos: .userInitiated).async { [weak self] in
 82:             self?.captureSession?.startRunning()
 83:         }
 84:     }
 85: 
 86:     func stopCapturing() {
 87:         guard !hasCompletedCapture else { return }
 88: 
 89:         hasCompletedCapture = true
 90:         self.isCapturing = false
 91:         self.onFrameCaptured = nil
 92: 
 93:         DispatchQueue.global(qos: .userInitiated).async { [weak self] in
 94:             self?.captureSession?.stopRunning()
 95:             DispatchQueue.main.async {
 96:                 self?.onCaptureCompleted?()
 97:             }
 98:         }
 99:     }
100: }
101: 
102: extension CameraController: AVCaptureVideoDataOutputSampleBufferDelegate {
103:     func captureOutput(_ output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection) {
104:         guard isCapturing && frameCount < maxFrames else { return }
105: 
106:         let now = Date()
107: 
108:         if frameCount == 0 {
109:             guard let startTime = captureStartTime, now.timeIntervalSince(startTime) >= 3.0 else {
110:                 return
111:             }
112:         } else {
113:             let requiredInterval: TimeInterval = frameCount < 5 ? 1.0 : 2.0
114:             guard let lastTime = lastCaptureTime, now.timeIntervalSince(lastTime) >= requiredInterval else {
115:                 return
116:             }
117:         }
118: 
119:         guard let imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer),
120:               let onFrameCaptured = onFrameCaptured else {
121:             return
122:         }
123: 
124:         let ciImage = CIImage(cvPixelBuffer: imageBuffer)
125:         let context = CIContext()
126:         guard let cgImage = context.createCGImage(ciImage, from: ciImage.extent) else { return }
127:         let image = UIImage(cgImage: cgImage)
128: 
129:         DispatchQueue.main.async {
130:             self.frameCount += 1
131:             self.lastCaptureTime = now
132:             onFrameCaptured(image)
133: 
134:             if self.frameCount >= self.maxFrames {
135:                 self.stopCapturing()
136:             }
137:         }
138:     }
139: }
140: 
141: struct CameraPreviewView: UIViewRepresentable {
142:     let session: AVCaptureSession
143: 
144:     func makeUIView(context: Context) -> UIView {
145:         let view = UIView(frame: UIScreen.main.bounds)
146:         let previewLayer = AVCaptureVideoPreviewLayer(session: session)
147:         previewLayer.frame = view.frame
148:         previewLayer.videoGravity = .resizeAspectFill
149:         view.layer.addSublayer(previewLayer)
150:         return view
151:     }
152: 
153:     func updateUIView(_ uiView: UIView, context: Context) {}
154: }
155: 
156: 
157: 
158: import SwiftUI
159: import AVFoundation
160: import CoreHaptics
161: 
162: struct CameraView: View {
163:     @StateObject private var cameraController = CameraController()
164:     @Environment(\.dismiss) private var dismiss
165:     var onFrameCaptured: (UIImage) -> Void
166:     @Binding var shouldFlash: Bool
167: 
168:     @State private var flashOverlayOpacity: Double = 0.0
169:     @EnvironmentObject var landmarkDetectionStore: LandmarkDetectionStore
170:     @State private var hapticEngine: CHHapticEngine?
171:     @State private var successMessage: String?
172:     @Namespace private var namespace
173: 
174:     var body: some View {
175:         GeometryReader { geometry in
176:             ZStack {
177:                 if let session = cameraController.captureSession {
178:                     CameraPreviewView(session: session)
179: 
180: 
181:                     if let message = successMessage {
182:                         Text(message)
183:                             .foregroundColor(.white)
184:                             .padding()
185:                             .background(Color.yellow.opacity(0.7))
186:                             .cornerRadius(10)
187:                             .transition(.opacity)
188:                     } else if let error = cameraController.error {
189:                         Text(error)
190:                             .foregroundColor(.white)
191:                             .padding()
192:                             .background(Color.black.opacity(0.7))
193:                             .cornerRadius(10)
194:                     }
195: 
196: 
197:                     Color.white
198:                         .opacity(flashOverlayOpacity)
199:                         .ignoresSafeArea()
200: 
201: 
202:                     if cameraController.isCapturing && !shouldFlash && !landmarkDetectionStore.isCapturing {
203:                         ScanningAnimation(namespace: namespace)
204:                             .ignoresSafeArea()
205:                     }
206:                 }
207:             }
208:             .ignoresSafeArea(.all, edges: .all)
209:             .onChange(of: shouldFlash) { newValue in
210:                 if newValue {
211:                     playHapticSuccess()
212:                     withAnimation(.easeIn(duration: 0.1)) {
213:                         flashOverlayOpacity = 1.0
214:                         successMessage = "Landmark Found!"
215:                     }
216:                     withAnimation(.easeOut(duration: 0.3).delay(0.1)) {
217:                         flashOverlayOpacity = 0.0
218:                     }
219:                 }
220:             }
221:             .onAppear {
222:                 prepareHaptics()
223:                 landmarkDetectionStore.startCapture()
224:                 cameraController.startCapturing(
225:                     onFrameCaptured: { image in
226:                         onFrameCaptured(image)
227:                     },
228:                     onCaptureCompleted: {
229:                         landmarkDetectionStore.captureCompleted()
230:                     }
231:                 )
232:             }
233:             .onDisappear {
234:                 cameraController.stopCapturing()
235:             }
236:         }
237:     }
238: 
239:     private func prepareHaptics() {
240:         guard CHHapticEngine.capabilitiesForHardware().supportsHaptics else { return }
241: 
242:         do {
243:             hapticEngine = try CHHapticEngine()
244:             try hapticEngine?.start()
245:         } catch {
246:             print("Haptics error: \(error)")
247:         }
248:     }
249: 
250:     private func playHapticSuccess() {
251:         guard CHHapticEngine.capabilitiesForHardware().supportsHaptics,
252:               let engine = hapticEngine else { return }
253: 
254:         do {
255:             let intensity = CHHapticEventParameter(parameterID: .hapticIntensity, value: 1.0)
256:             let sharpness = CHHapticEventParameter(parameterID: .hapticSharpness, value: 1.0)
257:             let event = CHHapticEvent(eventType: .hapticTransient, parameters: [intensity, sharpness], relativeTime: 0)
258: 
259:             let pattern = try CHHapticPattern(events: [event], parameters: [])
260:             let player = try engine.makePlayer(with: pattern)
261:             try player.start(atTime: 0)
262:         } catch {
263:             print("Failed to play haptic: \(error)")
264:         }
265:     }
266: }
267: #if DEBUG
268: 
269: private struct MockCameraPreviewView: View {
270:     var body: some View {
271:         Color.gray
272:     }
273: }
274: 
275: struct CameraView_Previews: PreviewProvider {
276:     static var previews: some View {
277:         CameraView(
278:             onFrameCaptured: { _ in },
279:             shouldFlash: .constant(false)
280:         )
281:         .previewDisplayName("Camera View")
282: 
283: 
284:         CameraView(
285:             onFrameCaptured: { _ in },
286:             shouldFlash: .constant(true)
287:         )
288:         .previewDisplayName("With Flash")
289:     }
290: }
291: #endif
</file>

<file path="sightline/sightline/Views/LandmarkDetailView.swift">
1: 
</file>

<file path="sightline/sightline/Views/MainTabView.swift">
  1: import SwiftUI
  2: import FirebaseAuth
  3: 
  4: struct MainTabView: View {
  5:     @StateObject private var appState = AppState()
  6:     @State private var selectedTab = 0
  7: 
  8:     @EnvironmentObject var appStore: AppStore
  9:     @EnvironmentObject var profileStore: ProfileStore
 10:     @EnvironmentObject var landmarkDetectionStore: LandmarkDetectionStore
 11: 
 12:     private let services = ServiceContainer.shared
 13: 
 14:     var body: some View {
 15:         NavigationStack(path: $appState.navigationPath) {
 16:             TabView(selection: $selectedTab) {
 17: 
 18:                 LandmarkDetectionView()
 19:                     .environmentObject(appState)
 20:                     .environmentObject(landmarkDetectionStore)
 21:                     .tabItem {
 22:                         Label("Discover", systemImage: "camera.viewfinder")
 23:                     }
 24:                     .tag(0)
 25: 
 26: 
 27:                 ContentFeedView()
 28:                     .environmentObject(appState)
 29:                     .environmentObject(appStore)
 30:                     .tabItem {
 31:                         Label("Feed", systemImage: "play.square.stack")
 32:                     }
 33:                     .tag(1)
 34: 
 35: 
 36: 
 37:                 ProfileView()
 38:                     .environmentObject(appState)
 39:                     .environmentObject(profileStore)
 40:                     .tabItem {
 41:                         Label("Profile", systemImage: "person.circle")
 42:                     }
 43:                     .tag(2)
 44:             }
 45:             .tint(.white)
 46:             .onAppear {
 47: 
 48:                 let appearance = UITabBarAppearance()
 49:                 appearance.configureWithOpaqueBackground()
 50:                 appearance.backgroundColor = UIColor.black
 51: 
 52:                 appearance.stackedLayoutAppearance.normal.iconColor = .gray
 53:                 appearance.stackedLayoutAppearance.normal.titleTextAttributes = [.foregroundColor: UIColor.gray]
 54: 
 55:                 appearance.stackedLayoutAppearance.selected.iconColor = .white
 56:                 appearance.stackedLayoutAppearance.selected.titleTextAttributes = [.foregroundColor: UIColor.white]
 57: 
 58:                 UITabBar.appearance().standardAppearance = appearance
 59:                 if #available(iOS 15.0, *) {
 60:                     UITabBar.appearance().scrollEdgeAppearance = appearance
 61:                 }
 62:             }
 63:             .task {
 64: 
 65:                 do {
 66:                     try await services.auth.signInAnonymously()
 67:                 } catch {
 68:                     print("Failed to sign in: \(error)")
 69:                 }
 70:             }
 71: 
 72:             .onChange(of: appState.shouldSwitchToFeed) { oldValue, newValue in
 73:                 if newValue {
 74:                     withAnimation {
 75:                         selectedTab = 1
 76:                     }
 77:                     appState.shouldSwitchToFeed = false
 78:                 }
 79:             }
 80: 
 81:             .onChange(of: appState.shouldSwitchToProfile) { oldValue, newValue in
 82:                 if newValue {
 83:                     withAnimation {
 84:                         selectedTab = 2
 85:                     }
 86:                     appState.shouldSwitchToProfile = false
 87:                 }
 88:             }
 89: 
 90: 
 91:             .onChange(of: selectedTab) { oldValue, newValue in
 92:                 if oldValue == 1 && newValue != 1 {
 93:                     appStore.videoManager.pause()
 94:                 }
 95:             }
 96: 
 97: 
 98:             .navigationDestination(for: AppState.NavigationDestination.self) { destination in
 99:                 switch destination {
100:                 case .placeDetail(let placeId, let initialContentId):
101:                     PlaceDetailView(placeId: placeId)
102:                 }
103:             }
104:         }
105:     }
106: }
</file>

<file path="sightline/sightline/Views/NeighborhoodUnlockedView.swift">
  1: import SwiftUI
  2: import MapKit
  3: 
  4: struct NeighborhoodUnlockedView: View {
  5:     let neighborhood: Neighborhood
  6:     let landmark: LandmarkInfo
  7:     let onContinue: () -> Void
  8: 
  9:     @State private var region = MKCoordinateRegion(
 10:         center: CLLocationCoordinate2D(latitude: 30.0, longitude: -97.0),
 11:         span: MKCoordinateSpan(latitudeDelta: 0.05, longitudeDelta: 0.05)
 12:     )
 13: 
 14:     var body: some View {
 15:         VStack(spacing: 24) {
 16: 
 17:             Text("Neighborhood Unlocked!")
 18:                 .font(.system(size: 28, weight: .bold))
 19:                 .foregroundColor(.yellow)
 20:                 .padding(.top, 80)
 21: 
 22:             Text(neighborhood.name)
 23:                 .font(.system(size: 24, weight: .semibold))
 24:                 .multilineTextAlignment(.center)
 25:                 .padding(.horizontal, 16)
 26: 
 27:             if let description = neighborhood.description, !description.isEmpty {
 28:                 Text(description)
 29:                     .font(.body)
 30:                     .foregroundColor(.secondary)
 31:                     .multilineTextAlignment(.center)
 32:                     .padding(.horizontal, 24)
 33:             }
 34: 
 35: 
 36:             Map(
 37:                 coordinateRegion: $region,
 38:                 annotationItems: [
 39:                     LandmarkLocation(
 40:                         name: landmark.name,
 41:                         coordinate: CLLocationCoordinate2D(
 42:                             latitude: landmark.latitude ?? 30.0,
 43:                             longitude: landmark.longitude ?? -97.0
 44:                         )
 45:                     )
 46:                 ]
 47:             ) { location in
 48:                 MapMarker(coordinate: location.coordinate, tint: .red)
 49:             }
 50:             .frame(height: 220)
 51:             .cornerRadius(12)
 52:             .padding(.horizontal)
 53:             .onAppear {
 54:                 if let lat = landmark.latitude, let lon = landmark.longitude {
 55:                     region = MKCoordinateRegion(
 56:                         center: CLLocationCoordinate2D(latitude: lat, longitude: lon),
 57:                         span: MKCoordinateSpan(latitudeDelta: 0.01, longitudeDelta: 0.01)
 58:                     )
 59:                 }
 60:             }
 61: 
 62: 
 63:             Button {
 64:                 onContinue()
 65:             } label: {
 66:                 Text("Continue")
 67:                     .frame(maxWidth: .infinity)
 68:                     .padding()
 69:                     .background(Color.blue)
 70:                     .foregroundColor(.white)
 71:                     .cornerRadius(12)
 72:             }
 73:             .padding(.horizontal, 24)
 74:             .padding(.bottom, 40)
 75:         }
 76:         .frame(maxWidth: .infinity, minHeight: UIScreen.main.bounds.height)
 77:         .background(.thinMaterial)
 78:         .ignoresSafeArea()
 79:         .onAppear {
 80:             print("üî∑ NeighborhoodUnlockedView appeared")
 81:         }
 82:         .task {
 83:             print("üî∑ NeighborhoodUnlockedView task started")
 84: 
 85:         }
 86:     }
 87: }
 88: 
 89: struct NeighborhoodUnlockedView_Previews: PreviewProvider {
 90:     static var previews: some View {
 91:         NeighborhoodUnlockedView(
 92:             neighborhood: Neighborhood(
 93:                 id: "test",
 94:                 name: "Test Neighborhood",
 95:                 description: "Sample description",
 96:                 imageUrl: nil,
 97:                 bounds: Neighborhood.GeoBounds(
 98:                     northeast: .init(lat: 30.2, lng: -97.7),
 99:                     southwest: .init(lat: 30.1, lng: -97.8)
100:                 ),
101:                 landmarks: nil
102:             ),
103:             landmark: LandmarkInfo(name: "Test Landmark", latitude: 30.2, longitude: -97.7),
104:             onContinue: {}
105:         )
106:     }
107: }
</file>

<file path="sightline/sightline/Views/PlaceDetailView.swift">
  1: import SwiftUI
  2: import MapKit
  3: import FirebaseFirestore
  4: import FirebaseAuth
  5: import os
  6: 
  7: 
  8: enum PlaceDetailMode {
  9:     case discovery
 10:     case review
 11: }
 12: 
 13: struct PlaceDetailView: View {
 14:     let placeId: String
 15:     let mode: PlaceDetailMode
 16:     @StateObject private var viewModel: PlaceDetailViewModel
 17:     @Environment(\.dismiss) private var dismiss
 18:     @EnvironmentObject private var appState: AppState
 19: 
 20: 
 21:     @State private var sheetHeight: CGFloat = UIScreen.main.bounds.height * 0.7
 22:     @State private var offset: CGFloat = 0
 23: 
 24:     @State private var region = MKCoordinateRegion(
 25:         center: CLLocationCoordinate2D(latitude: 30.0, longitude: -97.0),
 26:         span: MKCoordinateSpan(latitudeDelta: 0.05, longitudeDelta: 0.05)
 27:     )
 28: 
 29: 
 30:     @State private var showError = false
 31: 
 32:     @State private var showingVideoCapture = false
 33: 
 34:     private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "Sightline", category: "PlaceDetailView")
 35: 
 36:     init(placeId: String, mode: PlaceDetailMode = .discovery) {
 37:         self.placeId = placeId
 38:         self.mode = mode
 39:         _viewModel = StateObject(wrappedValue: PlaceDetailViewModel())
 40:     }
 41: 
 42:     func openDirections() {
 43:         guard let place = viewModel.place else { return }
 44: 
 45:         let coordinates = "\(place.coordinates.latitude),\(place.coordinates.longitude)"
 46:         let name = place.name.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? ""
 47:         let url = URL(string: "http:
 48: 
 49:         if let url = url, UIApplication.shared.canOpenURL(url) {
 50:             UIApplication.shared.open(url)
 51:         } else {
 52:             viewModel.errorMessage = "Unable to open Maps"
 53:         }
 54:     }
 55: 
 56:     var directionsButton: some View {
 57:         Button(action: openDirections) {
 58:             HStack {
 59:                 Image(systemName: "map.fill")
 60:                 Text("Get Directions")
 61:             }
 62:             .foregroundColor(.white)
 63:             .padding(.vertical, 12)
 64:             .padding(.horizontal, 24)
 65:             .background(Color.blue)
 66:             .cornerRadius(10)
 67:         }
 68:         .disabled(viewModel.place == nil)
 69:         .opacity(viewModel.place == nil ? 0.6 : 1.0)
 70:     }
 71: 
 72:     var actionButton: some View {
 73:         switch mode {
 74:         case .discovery:
 75:             return savePlaceButton
 76:         case .review:
 77:             return leaveReviewButton
 78:         }
 79:     }
 80: 
 81:     var savePlaceButton: some View {
 82:         Button(action: {
 83:             Task {
 84:                 await viewModel.savePlace()
 85: 
 86:                 appState.shouldSwitchToProfile = true
 87:                 dismiss()
 88:             }
 89:         }) {
 90:             HStack {
 91:                 Image(systemName: "heart.fill")
 92:                 Text("Save Place")
 93:             }
 94:             .foregroundColor(.white)
 95:             .padding(.vertical, 12)
 96:             .padding(.horizontal, 24)
 97:             .background(Color.pink)
 98:             .cornerRadius(10)
 99:         }
100:         .disabled(viewModel.place == nil)
101:         .opacity(viewModel.place == nil ? 0.6 : 1.0)
102:     }
103: 
104:     var leaveReviewButton: some View {
105:         Button(action: {
106:             showingVideoCapture = true
107:         }) {
108:             HStack {
109:                 Image(systemName: "video.fill")
110:                 Text("Record Review")
111:             }
112:             .foregroundColor(.white)
113:             .padding(.vertical, 12)
114:             .padding(.horizontal, 24)
115:             .background(Color.orange)
116:             .cornerRadius(10)
117:         }
118:         .disabled(viewModel.place == nil)
119:         .opacity(viewModel.place == nil ? 0.6 : 1.0)
120:         .fullScreenCover(isPresented: $showingVideoCapture) {
121:             VideoCaptureView(placeId: placeId)
122:         }
123:     }
124: 
125:     var mapView: some View {
126:         Group {
127:             if let place = viewModel.place {
128:                 Map(coordinateRegion: $region, annotationItems: [place]) { place in
129:                     MapMarker(
130:                         coordinate: CLLocationCoordinate2D(
131:                             latitude: place.coordinates.latitude,
132:                             longitude: place.coordinates.longitude
133:                         ),
134:                         tint: .red
135:                     )
136:                 }
137:                 .onAppear {
138: 
139:                     let coordinate = CLLocationCoordinate2D(
140:                         latitude: place.coordinates.latitude,
141:                         longitude: place.coordinates.longitude
142:                     )
143:                     if CLLocationCoordinate2DIsValid(coordinate) {
144:                         region = MKCoordinateRegion(
145:                             center: coordinate,
146:                             span: MKCoordinateSpan(latitudeDelta: 0.01, longitudeDelta: 0.01)
147:                         )
148:                     } else {
149:                         logger.warning("Invalid coordinates for place: \(place.id)")
150:                     }
151:                 }
152:                 .frame(height: 200)
153:                 .cornerRadius(12)
154:                 .padding(.horizontal)
155:             } else {
156:                 ProgressView()
157:                     .frame(height: 200)
158:             }
159:         }
160:     }
161: 
162:     var headerView: some View {
163:         Text(viewModel.place?.name ?? "Loading...")
164:             .font(.title2)
165:             .fontWeight(.bold)
166:             .frame(maxWidth: .infinity)
167:             .padding(.top, 16)
168:             .padding(.bottom, 8)
169:     }
170: 
171:     var body: some View {
172:         GeometryReader { geometry in
173:             ScrollView {
174:                 VStack(spacing: 16) {
175:                     headerView
176: 
177:                     if let errorMessage = viewModel.errorMessage {
178:                         Text(errorMessage)
179:                             .foregroundColor(.red)
180:                             .padding(.horizontal)
181:                     }
182: 
183: 
184:                     Text(viewModel.place?.description ?? "No description available.")
185:                         .font(.body)
186:                         .padding(.horizontal)
187: 
188:                     mapView
189: 
190:                     directionsButton
191:                     actionButton
192:                 }
193:             }
194:             .frame(maxWidth: geometry.size.width)
195:             .background(.ultraThinMaterial)
196:             .clipShape(RoundedRectangle(cornerRadius: 20, style: .continuous))
197:         }
198:         .presentationDetents([
199:             .height(400),
200:             .large
201:         ])
202:         .presentationDragIndicator(.visible)
203:         .presentationBackgroundInteraction(.enabled)
204:         .presentationBackground(.ultraThinMaterial)
205:         .onAppear {
206:             Task {
207:                 await viewModel.loadPlaceDetails(placeId: placeId)
208:             }
209:         }
210:     }
211: }
212: 
213: @MainActor
214: final class PlaceDetailViewModel: ObservableObject {
215:     @Published var place: Place?
216:     @Published var errorMessage: String?
217: 
218:     private let services = ServiceContainer.shared
219:     private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "Sightline", category: "PlaceDetailView")
220: 
221:     func loadPlaceDetails(placeId: String) async {
222:         do {
223:             let fetchedPlace = try await services.firestore.fetchPlace(id: placeId)
224:             await MainActor.run {
225:                 self.place = fetchedPlace
226:                 self.errorMessage = nil
227:             }
228:         } catch {
229:             logger.error("Error loading place details: \(error.localizedDescription)")
230:             await MainActor.run {
231:                 self.errorMessage = "Unable to load place details"
232:             }
233:         }
234:     }
235: 
236:     func savePlace() async {
237:         guard let place = self.place,
238:               let userId = Auth.auth().currentUser?.uid else { return }
239: 
240:         do {
241:             try await services.firestore.savePlaceForUser(userId: userId, placeId: place.id)
242:         } catch {
243:             self.errorMessage = "Error saving place: \(error.localizedDescription)"
244:         }
245:     }
246: }
</file>

<file path="sightline/sightline/Views/SplashView.swift">
  1: import SwiftUI
  2: 
  3: struct SplashView: View {
  4:     @State private var progress: CGFloat = 0
  5:     @State private var opacity: Double = 1
  6:     let onFinished: () -> Void
  7: 
  8:     var body: some View {
  9:         ZStack {
 10:             Color.black.edgesIgnoringSafeArea(.all)
 11: 
 12: 
 13:             BorderAnimation(progress: progress, startPosition: .topMiddle, clockwise: true)
 14:                 .stroke(Color.yellow, lineWidth: 10)
 15:                 .edgesIgnoringSafeArea(.all)
 16:                 .mask(
 17:                     RoundedRectangle(cornerRadius: UIScreen.main.displayCornerRadius)
 18:                         .edgesIgnoringSafeArea(.all)
 19:                 )
 20: 
 21: 
 22:             BorderAnimation(progress: progress, startPosition: .topMiddle, clockwise: false)
 23:                 .stroke(Color.yellow, lineWidth: 10)
 24:                 .edgesIgnoringSafeArea(.all)
 25:                 .mask(
 26:                     RoundedRectangle(cornerRadius: UIScreen.main.displayCornerRadius)
 27:                         .edgesIgnoringSafeArea(.all)
 28:                 )
 29: 
 30:             VStack(spacing: 24) {
 31: 
 32: 
 33:                 Image("Icon-1024")
 34:                     .resizable()
 35:                     .frame(width: 80, height: 80)
 36:                     .cornerRadius(16)
 37:                     .shadow(color: .blue.opacity(0.3), radius: 10)
 38: 
 39:                 VStack(spacing: 12) {
 40:                     Text("SightLine")
 41:                         .font(.custom("Baskerville", size: 24))
 42:                         .fontWeight(.medium)
 43:                         .foregroundColor(.white)
 44:                 }
 45:             }
 46:         }
 47:         .opacity(opacity)
 48:         .onAppear {
 49:             withAnimation(.linear(duration: 2).repeatForever(autoreverses: false)) {
 50:                 progress = 1.0
 51:             }
 52: 
 53:             DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
 54:                 withAnimation(.easeOut(duration: 0.5)) {
 55:                     opacity = 0
 56:                 }
 57:                 DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
 58:                     onFinished()
 59:                 }
 60:             }
 61:         }
 62:     }
 63: }
 64: 
 65: extension UIScreen {
 66:     var displayCornerRadius: CGFloat {
 67:         let key = "_displayCornerRadius"
 68:         if let val = self.value(forKey: key) as? CGFloat {
 69:             return val
 70:         }
 71:         return 39
 72:     }
 73: }
 74: 
 75: 
 76: enum BorderStartPosition {
 77:     case topMiddle
 78: }
 79: 
 80: struct BorderAnimation: Shape {
 81:     var progress: CGFloat
 82:     var startPosition: BorderStartPosition
 83:     var clockwise: Bool
 84: 
 85:     var animatableData: CGFloat {
 86:         get { progress }
 87:         set { progress = newValue }
 88:     }
 89: 
 90:     func path(in rect: CGRect) -> Path {
 91:         let cornerRadius = UIScreen.main.displayCornerRadius
 92: 
 93:         return Path { path in
 94: 
 95:             path.move(to: CGPoint(x: rect.midX, y: rect.minY))
 96: 
 97:             if clockwise {
 98: 
 99:                 path.addLine(to: CGPoint(x: rect.maxX - cornerRadius, y: rect.minY))
100:                 path.addArc(
101:                     center: CGPoint(x: rect.maxX - cornerRadius, y: rect.minY + cornerRadius),
102:                     radius: cornerRadius,
103:                     startAngle: Angle(degrees: -90),
104:                     endAngle: Angle(degrees: 0),
105:                     clockwise: false
106:                 )
107: 
108: 
109:                 path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY - cornerRadius))
110:                 path.addArc(
111:                     center: CGPoint(x: rect.maxX - cornerRadius, y: rect.maxY - cornerRadius),
112:                     radius: cornerRadius,
113:                     startAngle: Angle(degrees: 0),
114:                     endAngle: Angle(degrees: 90),
115:                     clockwise: false
116:                 )
117: 
118:                 path.addLine(to: CGPoint(x: rect.minX + cornerRadius, y: rect.maxY))
119:                 path.addArc(
120:                     center: CGPoint(x: rect.minX + cornerRadius, y: rect.maxY - cornerRadius),
121:                     radius: cornerRadius,
122:                     startAngle: Angle(degrees: 90),
123:                     endAngle: Angle(degrees: 180),
124:                     clockwise: false
125:                 )
126: 
127:                 path.addLine(to: CGPoint(x: rect.minX, y: rect.minY + cornerRadius))
128:                 path.addArc(
129:                     center: CGPoint(x: rect.minX + cornerRadius, y: rect.minY + cornerRadius),
130:                     radius: cornerRadius,
131:                     startAngle: Angle(degrees: 180),
132:                     endAngle: Angle(degrees: 270),
133:                     clockwise: false
134:                 )
135: 
136:                 path.addLine(to: CGPoint(x: rect.midX, y: rect.minY))
137:             } else {
138: 
139:                 path.addLine(to: CGPoint(x: rect.minX + cornerRadius, y: rect.minY))
140:                 path.addArc(
141:                     center: CGPoint(x: rect.minX + cornerRadius, y: rect.minY + cornerRadius),
142:                     radius: cornerRadius,
143:                     startAngle: Angle(degrees: -90),
144:                     endAngle: Angle(degrees: 180),
145:                     clockwise: true
146:                 )
147: 
148: 
149:                 path.addLine(to: CGPoint(x: rect.minX, y: rect.maxY - cornerRadius))
150:                 path.addArc(
151:                     center: CGPoint(x: rect.minX + cornerRadius, y: rect.maxY - cornerRadius),
152:                     radius: cornerRadius,
153:                     startAngle: Angle(degrees: 180),
154:                     endAngle: Angle(degrees: 90),
155:                     clockwise: true
156:                 )
157: 
158:                 path.addLine(to: CGPoint(x: rect.maxX - cornerRadius, y: rect.maxY))
159:                 path.addArc(
160:                     center: CGPoint(x: rect.maxX - cornerRadius, y: rect.maxY - cornerRadius),
161:                     radius: cornerRadius,
162:                     startAngle: Angle(degrees: 90),
163:                     endAngle: Angle(degrees: 0),
164:                     clockwise: true
165:                 )
166: 
167:                 path.addLine(to: CGPoint(x: rect.maxX, y: rect.minY + cornerRadius))
168:                 path.addArc(
169:                     center: CGPoint(x: rect.maxX - cornerRadius, y: rect.minY + cornerRadius),
170:                     radius: cornerRadius,
171:                     startAngle: Angle(degrees: 0),
172:                     endAngle: Angle(degrees: -90),
173:                     clockwise: true
174:                 )
175: 
176:                 path.addLine(to: CGPoint(x: rect.midX, y: rect.minY))
177:             }
178:         }.trimmedPath(from: 0, to: progress)
179:     }
180: }
181: 
182: 
183: struct SplashView_Previews: PreviewProvider {
184:     static var previews: some View {
185:         SplashView {
186:             print("Splash finished")
187:         }
188:         .previewDisplayName("Splash Screen")
189:     }
190: }
</file>

<file path="sightline/sightline/Views/VideoCaptureView.swift">
  1: import SwiftUI
  2: import AVFoundation
  3: import FirebaseFirestore
  4: 
  5: class VideoCaptureController: NSObject, ObservableObject {
  6:     @Published var isAuthorized = false
  7:     @Published var isRecording = false
  8:     @Published var error: String?
  9:     @Published var isUploading = false
 10:     @Published var shouldDismiss = false
 11:     @Published var uploadProgress: Double = 0
 12:     @Published var processingState: ProcessingState = .notStarted
 13: 
 14:     var captureSession: AVCaptureSession?
 15:     private var videoOutput: AVCaptureMovieFileOutput?
 16:     private var previewLayer: AVCaptureVideoPreviewLayer?
 17:     private let reviewService = VideoReviewService()
 18:     let placeId: String
 19:     private let maxRecordingDuration: TimeInterval = 60
 20:     private var currentCamera: AVCaptureDevice.Position = .back
 21:     private var statusListener: ListenerRegistration?
 22: 
 23:     init(placeId: String) {
 24:         self.placeId = placeId
 25:         super.init()
 26:         checkPermissions()
 27:     }
 28: 
 29:     private func checkPermissions() {
 30:         switch AVCaptureDevice.authorizationStatus(for: .video) {
 31:         case .authorized:
 32:             setupCaptureSession()
 33:         case .notDetermined:
 34:             AVCaptureDevice.requestAccess(for: .video) { [weak self] granted in
 35:                 DispatchQueue.main.async {
 36:                     if granted {
 37:                         self?.setupCaptureSession()
 38:                     }
 39:                 }
 40:             }
 41:         case .denied, .restricted:
 42:             error = "Camera access denied"
 43:         @unknown default:
 44:             error = "Unknown authorization status"
 45:         }
 46:     }
 47: 
 48:     private func setupCaptureSession() {
 49:         let session = AVCaptureSession()
 50: 
 51: 
 52:         guard let videoDevice = AVCaptureDevice.default(for: .video),
 53:               let videoInput = try? AVCaptureDeviceInput(device: videoDevice),
 54:               session.canAddInput(videoInput) else {
 55:             error = "Failed to setup video capture"
 56:             return
 57:         }
 58:         session.addInput(videoInput)
 59: 
 60: 
 61:         guard let audioDevice = AVCaptureDevice.default(for: .audio),
 62:               let audioInput = try? AVCaptureDeviceInput(device: audioDevice),
 63:               session.canAddInput(audioInput) else {
 64:             error = "Failed to setup audio capture"
 65:             return
 66:         }
 67:         session.addInput(audioInput)
 68: 
 69: 
 70:         let movieOutput = AVCaptureMovieFileOutput()
 71:         if session.canAddOutput(movieOutput) {
 72:             session.addOutput(movieOutput)
 73:             self.videoOutput = movieOutput
 74:         }
 75: 
 76:         self.captureSession = session
 77:         isAuthorized = true
 78: 
 79: 
 80:         DispatchQueue.global(qos: .userInitiated).async { [weak self] in
 81:             self?.captureSession?.startRunning()
 82:         }
 83:     }
 84: 
 85:     func startRecording() {
 86:         guard let output = videoOutput else { return }
 87: 
 88:         let paths = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)
 89:         let fileUrl = paths[0].appendingPathComponent("review_video.mp4")
 90: 
 91:         try? FileManager.default.removeItem(at: fileUrl)
 92: 
 93: 
 94:         output.maxRecordedDuration = CMTime(seconds: maxRecordingDuration, preferredTimescale: 600)
 95:         output.startRecording(to: fileUrl, recordingDelegate: self)
 96:         isRecording = true
 97:     }
 98: 
 99:     func stopRecording() {
100:         videoOutput?.stopRecording()
101:     }
102: 
103:     func switchCamera() {
104:         guard let session = captureSession else { return }
105: 
106:         session.beginConfiguration()
107: 
108: 
109:         let videoInput = session.inputs.first { input in
110:             (input as? AVCaptureDeviceInput)?.device.hasMediaType(.video) ?? false
111:         }
112:         if let videoInput = videoInput {
113:             session.removeInput(videoInput)
114:         }
115: 
116: 
117:         currentCamera = currentCamera == .front ? .back : .front
118: 
119: 
120:         let devicePosition: AVCaptureDevice.Position = currentCamera
121:         guard let videoDevice = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: devicePosition),
122:               let videoInput = try? AVCaptureDeviceInput(device: videoDevice),
123:               session.canAddInput(videoInput) else {
124:             error = "Failed to switch camera"
125:             session.commitConfiguration()
126:             return
127:         }
128: 
129:         session.addInput(videoInput)
130:         session.commitConfiguration()
131:     }
132: 
133:     private func listenToProcessingUpdates(reviewId: String) {
134: 
135:         statusListener?.remove()
136: 
137: 
138:         statusListener = reviewService.listenToProcessingStatus(reviewId: reviewId) { [weak self] status in
139:             guard let self = self else { return }
140: 
141:             Task { @MainActor in
142:                 switch status {
143:                 case "awaiting_upload":
144:                     self.processingState = .awaitingUpload
145:                 case "pending":
146:                     self.processingState = .pending
147:                 case "moderating":
148:                     self.processingState = .moderating
149:                 case "tagging":
150:                     self.processingState = .tagging
151:                 case "complete":
152:                     self.processingState = .complete
153: 
154:                     DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
155:                         self.shouldDismiss = true
156:                     }
157:                 case "error":
158:                     self.processingState = .error(message: "Processing failed")
159:                 case "rejected":
160:                     self.processingState = .error(message: "Content was rejected")
161:                 default:
162:                     print("Unknown processing status:", status)
163:                     self.processingState = .error(message: "Unknown status")
164:                 }
165:             }
166:         }
167:     }
168: 
169:     deinit {
170:         statusListener?.remove()
171:     }
172: }
173: 
174: extension VideoCaptureController: AVCaptureFileOutputRecordingDelegate {
175:     func fileOutput(_ output: AVCaptureFileOutput, didFinishRecordingTo outputFileURL: URL, from connections: [AVCaptureConnection], error: Error?) {
176:         isRecording = false
177: 
178:         if let error = error {
179:             self.error = error.localizedDescription
180:             return
181:         }
182: 
183:         processingState = .uploading
184: 
185:         Task {
186:             do {
187:                 let reviewId = try await reviewService.uploadReview(videoURL: outputFileURL, placeId: placeId)
188: 
189: 
190:                 listenToProcessingUpdates(reviewId: reviewId)
191: 
192:                 await MainActor.run {
193:                     processingState = .pending
194:                 }
195:             } catch {
196:                 await MainActor.run {
197:                     processingState = .error(message: error.localizedDescription)
198:                 }
199:             }
200:         }
201:     }
202: }
203: 
204: struct VideoCapturePreviewView: UIViewRepresentable {
205:     let session: AVCaptureSession
206: 
207:     func makeUIView(context: Context) -> UIView {
208:         let view = UIView(frame: UIScreen.main.bounds)
209:         let previewLayer = AVCaptureVideoPreviewLayer(session: session)
210:         previewLayer.frame = view.frame
211:         previewLayer.videoGravity = .resizeAspectFill
212:         view.layer.addSublayer(previewLayer)
213:         return view
214:     }
215: 
216:     func updateUIView(_ uiView: UIView, context: Context) {}
217: }
218: 
219: struct VideoCaptureView: View {
220:     @StateObject private var controller: VideoCaptureController
221:     @Environment(\.dismiss) private var dismiss
222: 
223:     init(placeId: String) {
224:         _controller = StateObject(wrappedValue: VideoCaptureController(placeId: placeId))
225:     }
226: 
227:     var body: some View {
228:         ZStack {
229:             if case .notStarted = controller.processingState {
230: 
231:                 if let session = controller.captureSession {
232:                     VideoCapturePreviewView(session: session)
233: 
234:                     VStack {
235:                         Spacer()
236: 
237: 
238:                         HStack {
239: 
240:                             Button(action: { dismiss() }) {
241:                                 Image(systemName: "xmark.circle.fill")
242:                                     .font(.system(size: 30))
243:                                     .foregroundColor(.white)
244:                                     .padding()
245:                             }
246: 
247:                             Spacer()
248: 
249: 
250:                             Button(action: {
251:                                 if controller.isRecording {
252:                                     controller.stopRecording()
253:                                 } else {
254:                                     controller.startRecording()
255:                                 }
256:                             }) {
257:                                 Image(systemName: controller.isRecording ? "stop.circle.fill" : "record.circle")
258:                                     .font(.system(size: 72))
259:                                     .foregroundColor(controller.isRecording ? .red : .white)
260:                             }
261: 
262:                             Spacer()
263: 
264: 
265:                             Button(action: { controller.switchCamera() }) {
266:                                 Image(systemName: "camera.rotate.fill")
267:                                     .font(.system(size: 30))
268:                                     .foregroundColor(.white)
269:                                     .padding()
270:                             }
271:                         }
272:                         .padding(.bottom, 30)
273:                     }
274:                 }
275:             } else {
276: 
277:                 ZStack {
278:                     Color.black.edgesIgnoringSafeArea(.all)
279: 
280:                     VStack(spacing: 20) {
281:                         ProcessingStatusView(state: controller.processingState)
282: 
283: 
284:                         Button(action: { dismiss() }) {
285:                             Text("Cancel")
286:                                 .foregroundColor(.white)
287:                                 .padding(.horizontal, 20)
288:                                 .padding(.vertical, 10)
289:                                 .background(Color.gray.opacity(0.3))
290:                                 .cornerRadius(8)
291:                         }
292:                     }
293:                 }
294:             }
295: 
296:             if let error = controller.error {
297:                 Text(error)
298:                     .foregroundColor(.white)
299:                     .padding()
300:                     .background(Color.black.opacity(0.7))
301:                     .cornerRadius(10)
302:             }
303:         }
304:         .ignoresSafeArea()
305:         .onChange(of: controller.shouldDismiss) { shouldDismiss in
306:             if shouldDismiss {
307:                 dismiss()
308:             }
309:         }
310:     }
311: }
312: 
313: struct ProcessingStatusView: View {
314:     let state: ProcessingState
315: 
316:     var body: some View {
317:         VStack(spacing: 8) {
318:             if case .uploading = state {
319:                 ProgressView()
320:                     .progressViewStyle(CircularProgressViewStyle(tint: .white))
321:             }
322: 
323:             Text(state.description)
324:                 .foregroundColor(.white)
325:                 .font(.system(size: 16, weight: .medium))
326:                 .multilineTextAlignment(.center)
327:                 .padding(.horizontal)
328:                 .background(Color.black.opacity(0.6))
329:                 .cornerRadius(8)
330:         }
331:     }
332: }
333: 
334: enum ProcessingState {
335:     case notStarted
336:     case uploading
337:     case awaitingUpload
338:     case pending
339:     case moderating
340:     case tagging
341:     case complete
342:     case error(message: String)
343: 
344:     var description: String {
345:         switch self {
346:         case .notStarted:
347:             return ""
348:         case .uploading:
349:             return "Uploading video..."
350:         case .awaitingUpload:
351:             return "Preparing upload..."
352:         case .pending:
353:             return "Transcribing audio..."
354:         case .moderating:
355:             return "Checking content..."
356:         case .tagging:
357:             return "Analyzing content..."
358:         case .complete:
359:             return "Complete!"
360:         case .error(let message):
361:             return "Error: \(message)"
362:         }
363:     }
364: }
</file>

<file path="sightline/sightline/DebugGalleryView.swift">
1: 
</file>

<file path="sightline/sightline/LandmarkDetection.swift">
  1: import SwiftUI
  2: import UIKit
  3: import FirebaseAuth
  4: import FirebaseFirestore
  5: 
  6: struct LandmarkDetectionView: View {
  7:     @EnvironmentObject var appState: AppState
  8:     @EnvironmentObject var appStore: AppStore
  9:     @EnvironmentObject var landmarkDetectionStore: LandmarkDetectionStore
 10: 
 11:     private let detectionService = LandmarkDetectionService()
 12: 
 13:     @State private var isCameraMode = false
 14: 
 15: 
 16:     @State private var showTransition: Bool = false
 17:     @State private var shouldFlash = false
 18:     @State private var fadeToBlack = false
 19:     @State private var showingGalleryPicker = false
 20: 
 21: 
 22:     @State private var showUnlockedOverlay = false
 23:     @State private var previewNeighborhood: Neighborhood? = nil
 24:     @State private var previewLandmark: LandmarkInfo? = nil
 25: 
 26:     @Namespace private var scanningNamespace
 27: 
 28:     var body: some View {
 29:         GeometryReader { geometry in
 30:             ZStack {
 31: 
 32:                 Image("discoverbg")
 33:                     .resizable()
 34:                     .aspectRatio(contentMode: .fill)
 35:                     .frame(width: geometry.size.width, height: geometry.size.height + 100)
 36:                     .clipped()
 37: 
 38:                 if isCameraMode {
 39:                     CameraView(
 40:                         onFrameCaptured: { image in
 41:                             Task {
 42:                                 await landmarkDetectionStore.detectLandmark(image: image, using: detectionService)
 43:                                 if let landmark = landmarkDetectionStore.detectedLandmark {
 44:                                     await animateLandmarkDetectionFlow(landmark: landmark)
 45:                                 }
 46:                             }
 47:                         },
 48:                         shouldFlash: $shouldFlash
 49:                     )
 50:                     .environmentObject(landmarkDetectionStore)
 51: 
 52: 
 53:                     VStack {
 54:                         HStack {
 55:                             Button {
 56:                                 isCameraMode = false
 57:                                 landmarkDetectionStore.reset()
 58:                             } label: {
 59:                                 Image(systemName: "xmark")
 60:                                     .font(.title2)
 61:                                     .foregroundColor(.white)
 62:                                     .padding(12)
 63:                                     .background(.ultraThinMaterial)
 64:                                     .clipShape(Circle())
 65:                             }
 66:                             .padding(.leading)
 67:                             Spacer()
 68:                         }
 69:                         .padding(.top, geometry.safeAreaInsets.top)
 70:                         Spacer()
 71:                     }
 72: 
 73:                     if showTransition {
 74:                         ScanningTransitionView(namespace: scanningNamespace)
 75:                             .ignoresSafeArea()
 76:                     } else {
 77:                         ScanningAnimation(namespace: scanningNamespace)
 78:                             .ignoresSafeArea()
 79:                     }
 80: 
 81:                     Color.black
 82:                         .opacity(fadeToBlack ? 1.0 : 0.0)
 83:                         .ignoresSafeArea()
 84:                 } else {
 85: 
 86:                     ScrollView {
 87:                         GeometryReader { scrollGeometry in
 88:                             VStack {
 89:                                 Spacer(minLength: 800)
 90:                                 VStack(spacing: 16) {
 91:                                     Text("Discover Your City")
 92:                                         .font(.custom("Baskerville-Bold", size: 28))
 93:                                         .foregroundColor(.black)
 94:                                         .opacity(0.9)
 95:                                         .multilineTextAlignment(.center)
 96:                                         .lineLimit(nil)
 97:                                         .fixedSize(horizontal: false, vertical: true)
 98:                                         .frame(maxWidth: .infinity)
 99:                                         .padding(.horizontal, 24)
100:                                     Text("Capture landmarks to unlock neighborhood content and explore local stories")
101:                                         .font(.custom("Baskerville", size: 20))
102:                                         .foregroundColor(.black)
103:                                         .multilineTextAlignment(.center)
104:                                         .lineLimit(nil)
105:                                         .fixedSize(horizontal: false, vertical: true)
106:                                         .frame(maxWidth: .infinity)
107:                                         .padding(.horizontal, 24)
108:                                     Button {
109:                                         isCameraMode = true
110:                                     } label: {
111:                                         HStack(spacing: 12) {
112:                                             Image(systemName: "camera.fill")
113:                                                 .font(.title3)
114:                                             Text("Open Camera")
115:                                                 .font(.title3)
116:                                         }
117:                                         .foregroundColor(.black)
118:                                         .frame(maxWidth: .infinity)
119:                                         .padding(.vertical, 16)
120:                                         .background(Color(.systemYellow))
121:                                         .cornerRadius(12)
122:                                     }
123:                                     .padding(.top, 12)
124:                                 }
125:                                 .padding(24)
126:                                 .background(.thinMaterial)
127:                                 .cornerRadius(16)
128:                                 .shadow(radius: 8)
129:                                 .padding()
130:                                 Spacer(minLength: 0)
131:                             }
132:                             .frame(minWidth: scrollGeometry.size.width, minHeight: scrollGeometry.size.height)
133:                         }
134:                     }
135:                 }
136: 
137: 
138:                 if showUnlockedOverlay, let nb = previewNeighborhood, let lm = previewLandmark {
139:                     NeighborhoodUnlockedView(
140:                         neighborhood: nb,
141:                         landmark: lm,
142:                         onContinue: {
143:                             withAnimation(.easeOut(duration: 0.3)) {
144:                                 showUnlockedOverlay = false
145:                                 resetOverlayState()
146:                                 appState.shouldSwitchToFeed = true
147:                             }
148:                         }
149:                     )
150:                     .ignoresSafeArea()
151:                     .transition(.move(edge: .bottom))
152:                     .zIndex(2)
153:                 }
154:             }
155:             .ignoresSafeArea(.container, edges: [.top])
156:             .sheet(isPresented: $showingGalleryPicker) {
157:                 NavigationView {
158:                     ScrollView {
159:                         LazyVGrid(columns: [
160:                             GridItem(.flexible()),
161:                             GridItem(.flexible()),
162:                             GridItem(.flexible())
163:                         ], spacing: 8) {
164:                             ForEach(landmarkDetectionStore.debugImages, id: \.self) { name in
165:                                 Image(name)
166:                                     .resizable()
167:                                     .aspectRatio(contentMode: .fill)
168:                                     .frame(height: 120)
169:                                     .clipShape(RoundedRectangle(cornerRadius: 8))
170:                                     .onTapGesture {
171:                                         if let uiImage = UIImage(named: name) {
172:                                             Task {
173:                                                 await landmarkDetectionStore.detectLandmark(image: uiImage, using: detectionService)
174:                                                 if let landmark = landmarkDetectionStore.detectedLandmark {
175:                                                     await animateLandmarkDetectionFlow(landmark: landmark)
176:                                                 }
177:                                             }
178:                                         }
179:                                         showingGalleryPicker = false
180:                                     }
181:                             }
182:                         }
183:                         .padding()
184:                     }
185:                     .navigationTitle("Debug Gallery")
186:                     .toolbar {
187:                         ToolbarItem(placement: .navigationBarTrailing) {
188:                             Button("Done") {
189:                                 showingGalleryPicker = false
190:                             }
191:                         }
192:                     }
193:                 }
194:             }
195:             .onDisappear {
196:                 resetOverlayState()
197:             }
198:         }
199:     }
200: 
201:     private func resetOverlayState() {
202:         showUnlockedOverlay = false
203:         previewNeighborhood = nil
204:         previewLandmark = nil
205:     }
206: 
207:     private func animateLandmarkDetectionFlow(landmark: LandmarkInfo) async {
208:         let startTime = Date()
209:         print("üïí Starting landmark flow at: \(startTime)")
210: 
211: 
212:         withAnimation {
213:             shouldFlash = true
214:         }
215: 
216: 
217:         isCameraMode = false
218:         landmarkDetectionStore.captureCompleted()
219: 
220: 
221:         if let neighborhood = landmark.neighborhood {
222:             print("üïí About to show overlay: +\(Date().timeIntervalSince(startTime))s")
223:             withAnimation(.easeInOut) {
224:                 previewNeighborhood = neighborhood
225:                 previewLandmark = landmark
226:                 showUnlockedOverlay = true
227:             }
228: 
229:             Task {
230:                 print("üïí Starting background tasks: +\(Date().timeIntervalSince(startTime))s")
231:                 await ServiceContainer.shared.neighborhood.clearCache()
232:                 await appStore.loadUnlockedNeighborhoods()
233:                 appStore.selectedNeighborhood = neighborhood
234:                 await appStore.loadContent()
235:             }
236:         }
237:     }
238: }
</file>

<file path="sightline/sightline/sightlineApp.swift">
 1: import SwiftUI
 2: import FirebaseCore
 3: 
 4: import FirebaseAuth
 5: 
 6: 
 7: @main
 8: struct SightlineApp: App {
 9:     @StateObject private var appStore = AppStore()
10:     @StateObject private var profileStore = ProfileStore()
11:     @StateObject private var landmarkDetectionStore = LandmarkDetectionStore()
12:     @State private var showingSplash = true
13: 
14:     init() {
15:         FirebaseApp.configure()
16:     }
17: 
18:     var body: some Scene {
19:         WindowGroup {
20:             ZStack {
21:                 MainTabView()
22:                     .environmentObject(appStore)
23:                     .environmentObject(profileStore)
24:                     .environmentObject(landmarkDetectionStore)
25:                     .task {
26: 
27:                         do {
28:                             try await ServiceContainer.shared.auth.signInAnonymously()
29: 
30:                             await appStore.loadUnlockedNeighborhoods()
31: 
32:                             withAnimation {
33:                                 showingSplash = false
34:                             }
35:                         } catch {
36:                             print("Failed to initialize app: \(error)")
37: 
38:                             showingSplash = false
39:                         }
40:                     }
41:                 if showingSplash {
42:                     SplashView{}
43:                         .transition(.opacity)
44:                 }
45:             }
46:         }
47:     }
48: }
</file>

<file path="sightline/sightline.xcodeproj/xcuserdata/chrissutton.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist">
1: <?xml version="1.0" encoding="UTF-8"?>
2: <Bucket
3:    uuid = "D2849DC8-FDC9-410B-B0D8-E42151764F8C"
4:    type = "1"
5:    version = "2.0">
6: </Bucket>
</file>

<file path="sightline/sightline.xcodeproj/xcuserdata/chrissutton.xcuserdatad/xcschemes/xcschememanagement.plist">
 1: <?xml version="1.0" encoding="UTF-8"?>
 2: <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
 3: <plist version="1.0">
 4: <dict>
 5: 	<key>SchemeUserState</key>
 6: 	<dict>
 7: 		<key>sightline.xcscheme_^#shared#^_</key>
 8: 		<dict>
 9: 			<key>orderHint</key>
10: 			<integer>0</integer>
11: 		</dict>
12: 	</dict>
13: </dict>
14: </plist>
</file>

<file path="sightline/sightlineTests/sightlineTests.swift">
 1: import Testing
 2: @testable import sightline
 3: 
 4: struct sightlineTests {
 5: 
 6:     @Test func example() async throws {
 7: 
 8:     }
 9: 
10: }
</file>

<file path="sightline/sightlineUITests/sightlineUITests.swift">
 1: import XCTest
 2: 
 3: final class sightlineUITests: XCTestCase {
 4: 
 5:     override func setUpWithError() throws {
 6: 
 7: 
 8: 
 9:         continueAfterFailure = false
10: 
11: 
12:     }
13: 
14:     override func tearDownWithError() throws {
15: 
16:     }
17: 
18:     @MainActor
19:     func testExample() throws {
20: 
21:         let app = XCUIApplication()
22:         app.launch()
23: 
24: 
25:     }
26: 
27:     @MainActor
28:     func testLaunchPerformance() throws {
29:         if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 7.0, *) {
30: 
31:             measure(metrics: [XCTApplicationLaunchMetric()]) {
32:                 XCUIApplication().launch()
33:             }
34:         }
35:     }
36: }
</file>

<file path="sightline/sightlineUITests/sightlineUITestsLaunchTests.swift">
 1: import XCTest
 2: 
 3: final class sightlineUITestsLaunchTests: XCTestCase {
 4: 
 5:     override class var runsForEachTargetApplicationUIConfiguration: Bool {
 6:         true
 7:     }
 8: 
 9:     override func setUpWithError() throws {
10:         continueAfterFailure = false
11:     }
12: 
13:     @MainActor
14:     func testLaunch() throws {
15:         let app = XCUIApplication()
16:         app.launch()
17: 
18: 
19: 
20: 
21:         let attachment = XCTAttachment(screenshot: app.screenshot())
22:         attachment.name = "Launch Screen"
23:         attachment.lifetime = .keepAlways
24:         add(attachment)
25:     }
26: }
</file>

<file path=".gitignore">
 1: # Firebase build and deployment files
 2: /firebase-debug.log
 3: /firebase-debug.*.log
 4: .firebaserc
 5: 
 6: # Firebase Hosting
 7: /firebase.json
 8: *.cache
 9: hosting/.cache
10: 
11: # Firebase Functions
12: /functions/node_modules/
13: /functions/.env
14: /functions/package-lock.json
15: 
16: # Firebase Emulators
17: /firebase-*.zip
18: /.firebase/
19: /emulator-ui/
20: 
21: # Logs
22: *.log
23: npm-debug.log*
24: yarn-debug.log*
25: yarn-error.log*
26: 
27: # Environment files (local configs)
28: /.env.*
29: .DS_Store
30: .env.*
31: 
32: # Xcode
33: *.pbxproj
34: *.xcworkspace
35: *.xcuserdatadirectory
36: GoogleService-Info.plist
</file>

<file path=".markdownlint.json">
1: {
2:   "MD013": false,
3:   "MD025": false,
4:   "MD033": false,
5:   "MD022": false,
6:   "MD032": false
7: }
</file>

<file path=".repomixignore">
1: # Add patterns to ignore here, one per line
2: # Example:
3: # *.log
4: # tmp/
</file>

<file path="readme.md">
  1: # Sightline: Discover Your City's Stories
  2: 
  3: Sightline is a mobile application that helps you explore your city in a new way. By identifying landmarks through your camera, you can unlock content and stories about the places around you.
  4: 
  5: ## Table of Contents
  6: 
  7: - [Features](#features)
  8: - [Project Structure](#project-structure)
  9: - [Firebase Integration](#firebase-integration)
 10:     - [Cloud Functions](#cloud-functions)
 11:     - [Firestore](#firestore)
 12:     - [Firebase Storage](#firebase-storage)
 13:     - [Authentication](#authentication)
 14: - [iOS Application (SwiftUI)](#ios-application-swiftui)
 15:     - [Models](#models)
 16:     - [Services](#services)
 17:     - [State Management](#state-management)
 18:     - [Views](#views)
 19:     - [Landmark Detection](#landmark-detection-ios)
 20:     - [Video Playback](#video-playback)
 21: - [Development Setup](#development-setup)
 22:     - [Prerequisites](#prerequisites)
 23:     - [Installation](#installation)
 24:     - [Configuration](#configuration)
 25: - [Testing](#testing)
 26: - [Contributing](#contributing)
 27: - [License](#license) (This section is added, assuming a license will be added)
 28: - [Code Overview (Repomix)](#code-overview-repomix)
 29: 
 30: ## Features
 31: 
 32: -   **Landmark Detection:** Use your camera to identify landmarks and unlock content related to them.
 33: -   **Content Feed:** Browse a curated feed of videos and information about places and events in your unlocked neighborhoods.
 34: -   **Neighborhood-Based Content:** Content is organized by neighborhoods, which are unlocked by discovering landmarks within them.
 35: -   **Category Filtering:** Filter content by categories such as restaurants, events, music, art, and more.
 36: -   **Place Details:** View detailed information about places, including descriptions, addresses, and user-generated content.
 37: -   **User Profiles:** Create an account to save places and manage your content (future feature).
 38: -   **Anonymous Authentication:**  Start exploring immediately with anonymous sign-in; create an account later to save progress.
 39: -   **Video Caching & Preloading:** Optimized video playback with caching and preloading of content.
 40: 
 41: ## Project Structure
 42: 
 43: The repository is organized into two main parts:
 44: 
 45: -   **`firebase/`**: Contains the backend logic and configuration for Firebase, including Cloud Functions, Firestore rules, and storage rules.
 46: -   **`sightline/`**: Contains the Xcode project for the iOS application.
 47: 
 48: ‚îú‚îÄ‚îÄ firebase/ # Firebase backend
 49: ‚îÇ ‚îú‚îÄ‚îÄ functions/ # Cloud Functions
 50: ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ .eslintrc.json
 51: ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ .gitignore
 52: ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ index.js # Main Cloud Functions code
 53: ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ package.json
 54: ‚îÇ ‚îú‚îÄ‚îÄ firebase.json # Firebase configuration
 55: ‚îÇ ‚îú‚îÄ‚îÄ firestore.indexes.json # Firestore indexes
 56: ‚îÇ ‚îú‚îÄ‚îÄ firestore.rules # Firestore security rules
 57: ‚îÇ ‚îî‚îÄ‚îÄ storage.rules # Firebase Storage security rules
 58: ‚îú‚îÄ‚îÄ sightline/ # iOS application (Xcode project)
 59: ‚îÇ ‚îú‚îÄ‚îÄ sightline/ # Main application code
 60: ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ Assets.xcassets/ # Asset catalog
 61: ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ Models/ # Data models
 62: ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ Services/ # Services for interacting with Firebase and other APIs
 63: ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ State/ # Application state management
 64: ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ Views/ # UI components and views
 65: ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ sightline.xcdatamodeld/ # Core Data model (empty, not actively used)
 66: ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ DebugGalleryView.swift # Debug view for testing landmark detection
 67: ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ LandmarkDetection.swift # Landmark detection logic
 68: ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sightlineApp.swift # Main application entry point
 69: ‚îÇ ‚îú‚îÄ‚îÄ sightline.xcodeproj/ # Xcode project file
 70: ‚îÇ ‚îî‚îÄ‚îÄ sightlineTests/ # Unit tests
 71: ‚îÇ ‚îî‚îÄ‚îÄ sightlineUITests/ # UI Tests
 72: ‚îú‚îÄ‚îÄ .gitignore # Files and folders to ignore in Git
 73: ‚îú‚îÄ‚îÄ .markdownlint.json # Markdown linting configuration
 74: ‚îú‚îÄ‚îÄ .repomixignore # Files to ignore for Repomix (currently empty)
 75: ‚îî‚îÄ‚îÄ repomix.config.json # Repomix configuration
 76: 
 77: ## Firebase Integration
 78: 
 79: Sightline utilizes several Firebase services:
 80: 
 81: ### Cloud Functions
 82: 
 83: -   **`annotateImage`**: This function is the core of the landmark detection feature. It takes an image as input, sends it to the Google Cloud Vision API, and processes the results.
 84:     -   It authenticates users (requires sign-in).
 85:     -   It calls the Google Cloud Vision API to detect landmarks.
 86:     -   It fetches neighborhood data using the Google Maps Geocoding API.
 87:     -   It updates Firestore collections:
 88:         -   `neighborhoods`: Adds or updates neighborhood information, including detected landmarks.
 89:         -   `users/unlocked_neighborhoods`: Tracks which neighborhoods a user has unlocked.
 90:         -   `detectedLandmarks`: Stores a record of all detected landmarks.
 91:     -   It returns landmark information, including name, MID (Machine ID), score, locations, and neighborhood details.
 92: 
 93: ### Firestore
 94: 
 95: -   **`neighborhoods` collection**: Stores information about neighborhoods, including their boundaries, landmarks, and user-generated content.  The structure includes:
 96:     -   `id` (DocumentID): The Google Maps Place ID of the neighborhood.
 97:     -   `name`: The name of the neighborhood.
 98:     -   `bounds`: Geographic bounds of the neighborhood (northeast and southwest coordinates).
 99:     -   `landmarks`: An array of landmarks within the neighborhood (including location, MID, and name).
100: 
101: -   **`places` collection**:  Stores detailed information about specific places.
102:     -   `id`: A unique identifier for the place.
103:     -   `name`: The name of the place.
104:     -   `primaryCategory`: The main category of the place (e.g., restaurant, bar).
105:     -   `tags`: An array of categories the place belongs to.
106:     -   `rating`: The average rating of the place.
107:     -   `reviewCount`: The number of reviews for the place.
108:     -   `coordinates`: The geographical coordinates of the place.
109:     -   `neighborhoodId`: The ID of the neighborhood the place belongs to.
110:     -   `address`:  The street address of the place.
111:     -   `description`: A description of the place.
112:     -   `thumbnailUrl`: A URL to a thumbnail image of the place.
113:     -   `details`: A dictionary of additional details.
114: 
115: -   **`content` collection**: Stores user-generated content (videos, captions, etc.).
116:     -   `id`: A unique identifier for the content.
117:     -   `placeIds`:  An array of place IDs the content is associated with.
118:     -   `eventIds`: An array of event IDs the content is associated with (optional).
119:     -   `neighborhoodId`: The ID of the neighborhood the content belongs to.
120:     -   `authorId`: The ID of the user who created the content.
121:     -   `videoUrl`: The URL of the video.
122:     -   `thumbnailUrl`: The URL of the video thumbnail.
123:     -   `caption`: The caption for the video.
124:     -   `tags`: An array of categories the content belongs to.
125:     -   `likes`: The number of likes the content has received.
126:     -   `views`: The number of views the content has received.
127:     -   `createdAt`: Timestamp of when the content was created.
128:     -   `updatedAt`: Timestamp of when the content was last updated.
129: 
130: -   **`users` collection**:  Stores user-specific data.  Crucially, it contains subcollections:
131:     -   `users/{userId}/unlocked_neighborhoods`:  Tracks which neighborhoods a user has unlocked.  Documents are named by `neighborhoodId`, and fields include `unlocked_at`, `unlocked_by_landmark`, `landmark_mid`, and `landmark_location`.
132:     -   `users/{userId}/saved_places`: Tracks the places a user has saved. Documents are named by `placeId`.
133: 
134: - **`detectedLandmarks` collection**: A record of landmarks detected by the Vision API.
135: 
136: ### Firebase Storage
137: 
138: Firebase Storage is used to store user-uploaded videos and thumbnails. The `storage.rules` file is currently set to `allow read, write: if false;`, meaning *all access is denied*.  This is a crucial security issue and needs to be addressed before deployment.  Proper rules should be implemented to control access based on authentication and authorization.
139: 
140: ### Authentication
141: 
142: Sightline uses Firebase Authentication to manage user accounts. It supports:
143: 
144: -   **Anonymous Authentication:** Users can start using the app without creating an account.
145: -   **Email/Password Authentication:** Users can create accounts to save their progress and preferences.  The `ProfileView` handles sign-up, sign-in, and account reset.
146: 
147: ## iOS Application (SwiftUI)
148: 
149: The iOS application is built using SwiftUI and follows a Model-View-ViewModel (MVVM) architecture.
150: 
151: ### Models
152: 
153: -   **`Content`**: Represents a piece of user-generated content (video, caption, etc.).
154: -   **`Event`**: Represents an event happening at a specific place.  (Not fully implemented in the provided code.)
155: -   **`FilterCategory`**: An enum representing different content categories.
156: -   **`Neighborhood`**: Represents a neighborhood, including its boundaries and landmarks.
157: -   **`Place`**: Represents a specific place (e.g., a restaurant, park, museum).
158: 
159: ### Services
160: 
161: -   **`AuthService`**: Handles user authentication (anonymous and email/password).
162: -   **`FirestoreService`**: Provides methods for interacting with Firestore, including fetching data, saving data, and managing user-specific information.
163: -   **`VideoPlayerManager`**: Manages video playback, including preloading and caching.  This is a key class for optimizing the user experience.
164: 
165: ### State Management
166: 
167: -   **`AppState`**: An `ObservableObject` that holds global application state, such as navigation and whether the user should be switched to the feed.
168: -   **`AppViewModel`**: An `ObservableObject` that manages preloading of data on app launch.
169: -   **`ContentFeedViewModel`**: An `ObservableObject` that manages the content feed, including fetching content, handling neighborhood and category selections, and controlling video playback.
170: -   **`ContentItemViewModel`**:  An `ObservableObject` that manages individual content items within the feed, primarily loading and displaying the associated place name.
171: -   **`PlaceDetailViewModel`**: An `ObservableObject` that manages the Place Detail view, loading place details and handling user interactions (e.g., saving a place).
172: -   **`ProfileViewModel`**: An `ObservableObject` for managing the user's profile, including authentication state, saved places, and sign-out functionality.
173: -   **`LandmarkDetectionViewModel`**: An `ObservableObject` responsible for handling the landmark detection process, calling the Cloud Function, and processing the results.
174: 
175: ### Views
176: 
177: -   **`AdaptiveColorButton`**: A reusable button component with adaptive styling.
178: -   **`FloatingMenuButton`**: A button component used in the floating menu.
179: -   **`FloatingMenu`**: A custom floating menu component for selecting neighborhoods and categories.
180: -   **`ScanningAnimation`**:  The animation displayed while the app is scanning for landmarks.
181: -   **`ScanningTransitionView`**:  The animation shown when a landmark is detected.
182: -   **`ContentFeedView`**: The main view that displays the content feed.
183: -   **`CameraView`**: The view that displays the camera feed and handles capturing images for landmark detection.
184: -   **`ContentItemView`**: Displays a single content item (video and caption) in the feed.
185: -   **`MainTabView`**: The main tab bar interface of the application.
186: -   **`PlaceDetailView`**: Displays detailed information about a specific place.
187: -   **`ProfileView`**: Displays the user's profile and authentication options.
188: -   **`SplashView`**: The initial splash screen displayed when the app launches.
189: -   **`VerticalFeedView`**: A custom view that implements vertical scrolling for the content feed using `UIPageViewController`.
190: -   **`DebugGalleryView`**: (DEBUG only) A view for testing landmark detection with a gallery of images.
191: -   **`LandmarkDetectionView`**: The main view for the landmark detection feature.
192: - **`LandmarkDetailView`**: (Within `LandmarkDetection.swift`) Displays detailed information about a detected landmark.
193: 
194: ### Landmark Detection (iOS)
195: 
196: The `LandmarkDetectionView` and `LandmarkDetectionViewModel` handle the landmark detection process on the client-side.  The `CameraView` uses `AVCaptureSession` to capture video frames.  The `CameraController` class manages the camera session, captures images, and sends them to the `LandmarkDetectionViewModel`.  The view model then converts the image to Base64, calls the `annotateImage` Cloud Function, and processes the result.  The UI is updated based on the detection results, including animations for scanning and successful detection.
197: 
198: ### Video Playback
199: 
200: The `VideoPlayerManager` class handles video playback using `AVQueuePlayer`. It prefetches and caches videos to improve performance and provide a smoother user experience. The `VerticalFeedView` uses this manager to display videos in the content feed.
201: 
202: ## Development Setup
203: 
204: ### Prerequisites
205: 
206: -   Xcode 14 or later
207: -   iOS 16 or later (for deployment)
208: -   A Firebase project
209: -   Node.js and npm (for Firebase Functions)
210: -   The Firebase CLI
211: 
212: ### Installation
213: 
214: 1.  **Clone the repository:**
215: 
216:     ```bash
217:     git clone <repository_url>
218:     cd <repository_name>
219:     ```
220: 
221: 2.  **Install Firebase dependencies:**
222: 
223:     ```bash
224:     cd firebase/functions
225:     npm install
226:     ```
227: 
228: 3.  **Install iOS dependencies:**
229:     *  Open the `sightline.xcodeproj` file in Xcode.
230:     *  Xcode should automatically resolve and fetch Swift Package dependencies.
231: 
232: ### Configuration
233: 
234: 1.  **Firebase:**
235:     -   Create a Firebase project in the Firebase console.
236:     -   Enable Firestore, Firebase Storage, Cloud Functions, and Firebase Authentication (Anonymous and Email/Password).
237:     -   Download the `GoogleService-Info.plist` file and add it to the `sightline/sightline/` directory in your Xcode project.  *Make sure it's added to the target.*
238:     -   Set up Firestore indexes as defined in `firebase/firestore.indexes.json`.
239:     -   Deploy Firestore rules (`firebase/firestore.rules`) and Storage rules (`firebase/storage.rules`). **Important:** Update the Storage rules to allow appropriate access.
240:     -   Deploy Cloud Functions:
241: 
242:         ```bash
243:         cd firebase/functions
244:         firebase deploy --only functions
245:         ```
246:     -   Set the `GOOGLE_MAPS_API_KEY` environment variable for the `annotateImage` function. You can do this in the Firebase console or using the Firebase CLI:
247:         ```bash
248:         firebase functions:config:set googlemaps.apikey="YOUR_API_KEY"
249:         ```
250:         Then redeploy the functions.
251: 
252: 2.  **Xcode:**
253:     -   Open the `sightline.xcodeproj` file in Xcode.
254:     -   Ensure the `GoogleService-Info.plist` file is correctly added to the project.
255:     -   Build and run the project on a simulator or a physical device.
256: 
257: ## Testing
258: 
259: -   **Unit Tests (`sightlineTests`)**:  The project includes a basic unit test file.  More comprehensive unit tests should be added to test individual components and services.
260: -   **UI Tests (`sightlineUITests`)**: The project includes basic UI tests, including a launch test.  More UI tests should be added to test user flows and interactions.
261: 
262: ## Contributing
263: 
264: Contributions are welcome! Please follow these guidelines:
265: 
266: 1.  Fork the repository.
267: 2.  Create a new branch for your feature or bug fix.
268: 3.  Make your changes and commit them with clear commit messages.
269: 4.  Write tests for your changes.
270: 5.  Submit a pull request.
271: 
272: ## License
273: 
274: [Add your chosen license here. For example, MIT, Apache 2.0, etc.  If you don't specify a license, the code is not open source.]
275: 
276: ## Code Overview (Repomix)
277: 
278: This README was significantly enhanced and expanded using Repomix, which provided a packed representation of the codebase.  The initial code provided was combined into a single, well-structured document, allowing for a comprehensive understanding of the project's structure, functionality, and dependencies. This README leverages the Repomix output to provide a clear and detailed explanation of the Sightline project.
</file>

<file path="repomix.config.json">
 1: {
 2:   "output": {
 3:     "style": "xml",
 4:     "filePath": "repomix.xml",
 5:     "removeComments": true,
 6:     "showLineNumbers": true,
 7:     "topFilesLength": 10
 8:   },
 9:   "ignore": {
10:     "customPatterns": ["_docs/**", "sightline/sightline/Assets.xcassets/**","firebase/**","sightline.xcodeproj/**"]
11:   }
12: }
</file>

<file path="xml-extractor.ts">
 1: import { file } from "bun";
 2: 
 3: 
 4: async function ensureDir(path: string) {
 5:   const dirs = path.split("/");
 6:   let currentPath = "";
 7: 
 8:   for (const dir of dirs) {
 9:     currentPath += dir + "/";
10:     try {
11:       await Bun.write(currentPath, "");
12:     } catch (e) {
13:       // Directory likely exists, continue
14:     }
15:   }
16: }
17: 
18: async function main() {
19:   // Read the XML file
20:   const xmlContent = await file("_docs/o1feed.xml").text();
21: 
22: 
23:   const fileMatches = xmlContent.matchAll(/<file path="([^"]+)"[^>]*>[\s\S]*?<content>\s*===\s*([\s\S]*?)\s*===\s*<\/content>/g);
24: 
25:   for (const match of fileMatches) {
26:     const [_, filePath, content] = match;
27: 
28:     // Ensure the directory structure exists
29:     const dirPath = filePath.split("/").slice(0, -1).join("/");
30:     await ensureDir(dirPath);
31: 
32: 
33:     try {
34:       await Bun.write(filePath, content);
35:       console.log(`‚úì Created ${filePath}`);
36:     } catch (err) {
37:       console.error(`‚úó Failed to create ${filePath}:`, err);
38:     }
39:   }
40: }
41: 
42: 
43: main().catch(console.error);
</file>

</files>
