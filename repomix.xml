This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document. The content has been processed where comments have been removed, line numbers have been added.
Generated by Repomix on: 2025-02-08T02:29:58.629Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: _docs/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Line numbers have been added to the beginning of each line
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
firebase/
  functions/
    .eslintrc.json
    .gitignore
    index.js
    package.json
  firebase.json
  firestore.indexes.json
  firestore.rules
  storage.rules
sightline/
  sightline/
    Assets.xcassets/
      AccentColor.colorset/
        Contents.json
      AppIcon.appiconset/
        Contents.json
      discoverbg.imageset/
        Contents.json
      Icon-1024.imageset/
        Contents.json
      ladybirdlake1.imageset/
        Contents.json
      nocontent.imageset/
        Contents.json
      profile-bg.imageset/
        Contents.json
      utcapitol1.imageset/
        Contents.json
      utcapitol2.imageset/
        Contents.json
      Contents.json
    Models/
      Content.swift
      Event.swift
      FilterCategory.swift
      Neighborhood.swift
      Place.swift
    Preview Content/
      Preview Assets.xcassets/
        Contents.json
    Services/
      AuthService.swift
      FirestoreError.swift
      FirestoreService.swift
      FirestoreService+TestData.swift
      ServiceContainer.swift
      VideoPlayerManager.swift
    sightline.xcdatamodeld/
      sightline.xcdatamodel/
        contents
      .xccurrentversion
    State/
      AppState.swift
      AppViewModel.swift
    Views/
      Components/
        AdaptiveColorButton.swift
        FloatingMenuButton.swift
        ScanningAnimation.swift
        ScanningTransitionView.swift
      ContentFeedView/
        ContentFeedView.swift
        ContentFeedViewModel.swift
      CameraView.swift
      ContentItemView.swift
      MainTabView.swift
      PlaceDetailView.swift
      ProfileView.swift
      SplashView.swift
      VerticalFeedView.swift
    DebugGalleryView.swift
    LandmarkDetection.swift
    sightlineApp.swift
  sightline.xcodeproj/
    xcuserdata/
      chrissutton.xcuserdatad/
        xcdebugger/
          Breakpoints_v2.xcbkptlist
        xcschemes/
          xcschememanagement.plist
  sightlineTests/
    sightlineTests.swift
  sightlineUITests/
    sightlineUITests.swift
    sightlineUITestsLaunchTests.swift
.gitignore
.markdownlint.json
.repomixignore
repomix.config.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="firebase/functions/.eslintrc.json">
 1: {
 2:   "root": true,
 3:   "env": {
 4:     "es6": true,
 5:     "node": true
 6:   },
 7:   "extends": [
 8:     "eslint:recommended",
 9:     "google"
10:   ],
11:   "rules": {
12:     "quotes": ["error", "double"]
13:   },
14:   "parserOptions": {
15:     "sourceType": "module",
16:     "ecmaVersion": 2020
17:   }
18: }
</file>

<file path="firebase/functions/.gitignore">
1: node_modules/
2: *.local
</file>

<file path="firebase/functions/index.js">
  1: import * as functions from "firebase-functions/v1";
  2: import {defineString} from "firebase-functions/params";
  3: import vision from "@google-cloud/vision";
  4: import admin from "firebase-admin";
  5: 
  6: 
  7: admin.initializeApp();
  8: 
  9: const API_KEY = defineString("GOOGLE_MAPS_API_KEY");
 10: 
 11: 
 12: 
 13: 
 14: 
 15: 
 16: 
 17: 
 18: async function fetchNeighborhoodData(latitude, longitude) {
 19:   const url = `https://maps.googleapis.com/maps/api/geocode/json?latlng=${latitude},${longitude}&result_type=neighborhood&key=${API_KEY.value()}`;
 20: 
 21:   try {
 22:     const response = await fetch(url);
 23:     const data = await response.json();
 24:     console.log(data);
 25:     if (data.results && data.results.length > 0) {
 26:       const neighborhood = data.results[0];
 27:       return {
 28:         place_id: neighborhood.place_id,
 29:         name: neighborhood.address_components[0].long_name,
 30:         bounds: neighborhood.geometry.bounds,
 31:         formatted_address: neighborhood.formatted_address,
 32:       };
 33:     }
 34:     return null;
 35:   } catch (error) {
 36:     console.error("Error fetching neighborhood data:", error);
 37:     return null;
 38:   }
 39: }
 40: 
 41: 
 42: 
 43: 
 44: export const annotateImage = functions.https.onCall(async (data, context) => {
 45:   if (!context?.auth) {
 46:     throw new functions.https.HttpsError(
 47:         "unauthenticated",
 48:         "annotateImage must be called while authenticated.",
 49:     );
 50:   }
 51: 
 52:   const client = new vision.ImageAnnotatorClient();
 53: 
 54:   try {
 55:     const [result] = await client.annotateImage(data);
 56: 
 57: 
 58:     if (!result.landmarkAnnotations?.length) {
 59:       return {landmark: null};
 60:     }
 61: 
 62: 
 63:     const firstLandmark = result.landmarkAnnotations[0];
 64:     const landmarkMid = firstLandmark.mid;
 65: 
 66: 
 67: 
 68:     const sanitizedMid = landmarkMid ?
 69:       landmarkMid.startsWith("/") ?
 70:         landmarkMid.slice(1).replace(/\//g, "_") :
 71:         landmarkMid :
 72:       null;
 73:     console.log(
 74:         "Detected landmark:",
 75:         firstLandmark,
 76:         "Using sanitized MID:",
 77:         sanitizedMid,
 78:     );
 79: 
 80:     const location = firstLandmark.locations[0].latLng;
 81: 
 82: 
 83:     const neighborhoodData = await fetchNeighborhoodData(
 84:         location.latitude,
 85:         location.longitude,
 86:     );
 87: 
 88:     console.log("Neighborhood Data:", neighborhoodData);
 89: 
 90: 
 91:     const db = admin.firestore();
 92: 
 93: 
 94: 
 95:     if (neighborhoodData?.place_id) {
 96:       await db
 97:           .collection("neighborhoods")
 98:           .doc(neighborhoodData.place_id)
 99:           .set(
100:               {
101:                 name: neighborhoodData.name,
102:                 bounds: neighborhoodData.bounds,
103:                 landmarks: admin.firestore.FieldValue.arrayUnion({
104:                   mid: sanitizedMid,
105:                   name: firstLandmark.description,
106:                   location: new admin.firestore.GeoPoint(
107:                       location.latitude,
108:                       location.longitude,
109:                   ),
110:                 }),
111:               },
112:               {merge: true},
113:           );
114:     }
115: 
116: 
117: 
118:     if (
119:       context.auth &&
120:       context.auth.uid &&
121:       neighborhoodData?.place_id &&
122:       sanitizedMid
123:     ) {
124:       await db
125:           .collection("users")
126:           .doc(context.auth.uid)
127:           .collection("unlocked_neighborhoods")
128:           .doc(neighborhoodData.place_id)
129:           .set(
130:               {
131:                 unlocked_at: admin.firestore.FieldValue.serverTimestamp(),
132:                 unlocked_by_landmark: "Vision API",
133:                 landmark_mid: sanitizedMid,
134:                 landmark_location: new admin.firestore.GeoPoint(
135:                     location.latitude,
136:                     location.longitude,
137:                 ),
138:               },
139:               {merge: true},
140:           );
141:     }
142: 
143: 
144:     if (sanitizedMid) {
145:       await db.collection("detectedLandmarks").doc(sanitizedMid).set(
146:           {
147:             name: firstLandmark.description,
148:             locations: firstLandmark.locations,
149:             score: firstLandmark.score,
150:             detected_at: admin.firestore.FieldValue.serverTimestamp(),
151:           },
152:           {merge: true},
153:       );
154:     }
155: 
156: 
157:     const landmark = {
158:       landmark: {
159:         name: firstLandmark.description,
160:         mid: sanitizedMid,
161:         score: firstLandmark.score,
162:         locations: firstLandmark.locations,
163:         neighborhood: neighborhoodData,
164:       },
165:     };
166:     console.log("Returning landmark response:", landmark);
167:     return landmark;
168:   } catch (err) {
169:     console.error("Error calling Vision API:", err);
170:     throw new functions.https.HttpsError("internal", err.message);
171:   }
172: });
</file>

<file path="firebase/functions/package.json">
 1: {
 2:   "name": "functions",
 3:   "description": "Cloud Functions for Firebase",
 4:   "scripts": {
 5:     "lint": "eslint . --fix",
 6:     "serve": "firebase emulators:start --only functions",
 7:     "shell": "firebase functions:shell",
 8:     "start": "npm run shell",
 9:     "deploy": "firebase deploy --only functions",
10:     "logs": "firebase functions:log"
11:   },
12:   "engines": {
13:     "node": "20"
14:   },
15:   "main": "index.js",
16:   "dependencies": {
17:     "@google-cloud/vision": "^4.3.2",
18:     "@googlemaps/google-maps-services-js": "^3.4.0",
19:     "firebase-admin": "^12.7.0",
20:     "firebase-functions": "^6.0.1",
21:     "geohash": "^0.0.1",
22:     "node-fetch": "^3.3.2"
23:   },
24:   "devDependencies": {
25:     "eslint": "^8.15.0",
26:     "eslint-config-google": "^0.14.0",
27:     "firebase-functions-test": "^3.1.0"
28:   },
29:   "private": true,
30:   "type": "module"
31: }
</file>

<file path="firebase/firebase.json">
 1: {
 2:   "firestore": {
 3:     "rules": "firestore.rules",
 4:     "indexes": "firestore.indexes.json"
 5:   },
 6:   "functions": [
 7:     {
 8:       "source": "functions",
 9:       "codebase": "default",
10:       "ignore": [
11:         "node_modules",
12:         ".git",
13:         "firebase-debug.log",
14:         "firebase-debug.*.log",
15:         "*.local"
16:       ],
17:       "predeploy": [
18:         "npm --prefix \"$RESOURCE_DIR\" run lint"
19:       ]
20:     }
21:   ],
22:   "storage": {
23:     "rules": "storage.rules"
24:   }
25: }
</file>

<file path="firebase/firestore.indexes.json">
1: {
2:   "indexes": [],
3:   "fieldOverrides": []
4: }
</file>

<file path="firebase/firestore.rules">
 1: rules_version = '2';
 2: 
 3: service cloud.firestore {
 4:   match /databases/{database}/documents {
 5: 
 6:     // This rule allows anyone with your Firestore database reference to view, edit,
 7:     // and delete all data in your Firestore database. It is useful for getting
 8:     // started, but it is configured to expire after 30 days because it
 9:     // leaves your app open to attackers. At that time, all client
10:     // requests to your Firestore database will be denied.
11:     //
12:     // Make sure to write security rules for your app before that time, or else
13:     // all client requests to your Firestore database will be denied until you Update
14:     // your rules
15:     match /{document=**} {
16:       allow read, write: if request.time < timestamp.date(2025, 3, 6);
17:     }
18:   }
19: }
</file>

<file path="firebase/storage.rules">
 1: rules_version = '2';
 2: 
 3: // Craft rules based on data in your Firestore database
 4: // allow write: if firestore.get(
 5: //    /databases/(default)/documents/users/$(request.auth.uid)).data.isAdmin;
 6: service firebase.storage {
 7:   match /b/{bucket}/o {
 8:     match /{allPaths=**} {
 9:       allow read, write: if false;
10:     }
11:   }
12: }
</file>

<file path="sightline/sightline/Assets.xcassets/AccentColor.colorset/Contents.json">
 1: {
 2:   "colors" : [
 3:     {
 4:       "idiom" : "universal"
 5:     }
 6:   ],
 7:   "info" : {
 8:     "author" : "xcode",
 9:     "version" : 1
10:   }
11: }
</file>

<file path="sightline/sightline/Assets.xcassets/AppIcon.appiconset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Icon-1024.png",
 5:       "idiom" : "universal",
 6:       "platform" : "ios",
 7:       "size" : "1024x1024"
 8:     },
 9:     {
10:       "appearances" : [
11:         {
12:           "appearance" : "luminosity",
13:           "value" : "dark"
14:         }
15:       ],
16:       "idiom" : "universal",
17:       "platform" : "ios",
18:       "size" : "1024x1024"
19:     },
20:     {
21:       "appearances" : [
22:         {
23:           "appearance" : "luminosity",
24:           "value" : "tinted"
25:         }
26:       ],
27:       "idiom" : "universal",
28:       "platform" : "ios",
29:       "size" : "1024x1024"
30:     }
31:   ],
32:   "info" : {
33:     "author" : "xcode",
34:     "version" : 1
35:   }
36: }
</file>

<file path="sightline/sightline/Assets.xcassets/discoverbg.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "discoverbg.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="sightline/sightline/Assets.xcassets/Icon-1024.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "Icon-1024.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="sightline/sightline/Assets.xcassets/ladybirdlake1.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "ladybirdlake1.jpeg",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="sightline/sightline/Assets.xcassets/nocontent.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "nocontent.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="sightline/sightline/Assets.xcassets/profile-bg.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "profile-bg.png",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="sightline/sightline/Assets.xcassets/utcapitol1.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "utcapital1.jpeg",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="sightline/sightline/Assets.xcassets/utcapitol2.imageset/Contents.json">
 1: {
 2:   "images" : [
 3:     {
 4:       "filename" : "utcapitol2.jpeg",
 5:       "idiom" : "universal",
 6:       "scale" : "1x"
 7:     },
 8:     {
 9:       "idiom" : "universal",
10:       "scale" : "2x"
11:     },
12:     {
13:       "idiom" : "universal",
14:       "scale" : "3x"
15:     }
16:   ],
17:   "info" : {
18:     "author" : "xcode",
19:     "version" : 1
20:   }
21: }
</file>

<file path="sightline/sightline/Assets.xcassets/Contents.json">
1: {
2:   "info" : {
3:     "author" : "xcode",
4:     "version" : 1
5:   }
6: }
</file>

<file path="sightline/sightline/Models/Content.swift">
 1: import FirebaseFirestore
 2: 
 3: struct Content: Identifiable, Codable, Equatable {
 4:     let id: String
 5:     let placeIds: [String]
 6:     let eventIds: [String]?
 7:     let neighborhoodId: String
 8:     let authorId: String
 9: 
10: 
11:     var videoUrl: String
12:     let thumbnailUrl: String
13: 
14: 
15:     let caption: String
16:     let tags: [FilterCategory]
17: 
18: 
19:     let likes: Int
20:     let views: Int
21: 
22: 
23:     let createdAt: Timestamp
24:     let updatedAt: Timestamp
25: 
26: 
27:     static func == (lhs: Content, rhs: Content) -> Bool {
28:         lhs.id == rhs.id &&
29:         lhs.placeIds == rhs.placeIds &&
30:         lhs.eventIds == rhs.eventIds &&
31:         lhs.neighborhoodId == rhs.neighborhoodId &&
32:         lhs.authorId == rhs.authorId &&
33:         lhs.videoUrl == rhs.videoUrl &&
34:         lhs.thumbnailUrl == rhs.thumbnailUrl &&
35:         lhs.caption == rhs.caption &&
36:         lhs.tags == rhs.tags &&
37:         lhs.likes == rhs.likes &&
38:         lhs.views == rhs.views
39:     }
40: 
41:     init(
42:         id: String,
43:         placeIds: [String],
44:         eventIds: [String]? = nil,
45:         neighborhoodId: String,
46:         authorId: String,
47:         videoUrl: String,
48:         thumbnailUrl: String,
49:         caption: String,
50:         tags: [FilterCategory],
51:         likes: Int,
52:         views: Int,
53:         createdAt: Timestamp = Timestamp(),
54:         updatedAt: Timestamp = Timestamp()
55:     ) {
56:         self.id = id
57:         self.placeIds = placeIds
58:         self.eventIds = eventIds
59:         self.neighborhoodId = neighborhoodId
60:         self.authorId = authorId
61:         self.videoUrl = videoUrl
62:         self.thumbnailUrl = thumbnailUrl
63:         self.caption = caption
64:         self.tags = tags
65:         self.likes = likes
66:         self.views = views
67:         self.createdAt = createdAt
68:         self.updatedAt = updatedAt
69:     }
70: }
</file>

<file path="sightline/sightline/Models/Event.swift">
 1: import FirebaseFirestore
 2: 
 3: struct Event: Identifiable, Codable {
 4:     let id: String
 5:     let placeId: String
 6:     let name: String
 7:     let description: String?
 8:     let startTime: Timestamp
 9:     let endTime: Timestamp?
10:     let tags: [FilterCategory]
11:     let thumbnailUrl: String?
12:     let createdAt: Timestamp
13:     let updatedAt: Timestamp
14: 
15:     init(
16:         id: String,
17:         placeId: String,
18:         name: String,
19:         description: String? = nil,
20:         startTime: Timestamp,
21:         endTime: Timestamp? = nil,
22:         tags: [FilterCategory] = [],
23:         thumbnailUrl: String? = nil,
24:         createdAt: Timestamp = Timestamp(),
25:         updatedAt: Timestamp = Timestamp()
26:     ) {
27:         self.id = id
28:         self.placeId = placeId
29:         self.name = name
30:         self.description = description
31:         self.startTime = startTime
32:         self.endTime = endTime
33:         self.tags = tags
34:         self.thumbnailUrl = thumbnailUrl
35:         self.createdAt = createdAt
36:         self.updatedAt = updatedAt
37:     }
38: }
</file>

<file path="sightline/sightline/Models/FilterCategory.swift">
 1: enum FilterCategory: String, Codable, CaseIterable, Identifiable {
 2:     case restaurant
 3:     case drinks
 4:     case events
 5:     case music
 6:     case art
 7:     case outdoors
 8:     case shopping
 9:     case coffee
10: 
11:     var id: String { rawValue }
12: }
</file>

<file path="sightline/sightline/Models/Neighborhood.swift">
 1: import FirebaseFirestore
 2: 
 3: struct Neighborhood: Codable, Identifiable, Equatable {
 4:     @DocumentID var id: String?
 5:     let name: String
 6:     let description: String?
 7:     let imageUrl: String?
 8:     let bounds: GeoBounds
 9:     let landmarks: [Landmark]?
10: 
11:     struct GeoBounds: Codable {
12:         struct Point: Codable {
13:             let lat: Double
14:             let lng: Double
15:         }
16:         let northeast: Point
17:         let southwest: Point
18:     }
19: 
20:     struct Landmark: Codable {
21:         let location: GeoPoint
22:         let mid: String
23:         let name: String
24:     }
25: 
26:     static func == (lhs: Neighborhood, rhs: Neighborhood) -> Bool {
27:         return lhs.id == rhs.id
28:     }
29: }
</file>

<file path="sightline/sightline/Models/Place.swift">
 1: import FirebaseFirestore
 2: 
 3: struct Place: Identifiable, Codable {
 4:     let id: String
 5:     let name: String
 6:     let primaryCategory: FilterCategory
 7:     let tags: [FilterCategory]
 8: 
 9: 
10:     let rating: Double
11:     let reviewCount: Int
12:     let coordinates: GeoPoint
13:     let neighborhoodId: String
14:     let address: String
15:     let description: String?
16:     let thumbnailUrl: String?
17:     let details: [String: String]
18:     let createdAt: Timestamp
19:     let updatedAt: Timestamp
20: 
21:     init(
22:         id: String,
23:         name: String,
24:         primaryCategory: FilterCategory,
25:         tags: [FilterCategory],
26:         rating: Double,
27:         reviewCount: Int,
28:         coordinates: GeoPoint,
29:         neighborhoodId: String,
30:         address: String,
31:         description: String? = nil,
32:         thumbnailUrl: String?,
33:         details: [String: String],
34:         createdAt: Timestamp = Timestamp(),
35:         updatedAt: Timestamp = Timestamp()
36:     ) {
37:         self.id = id
38:         self.name = name
39:         self.primaryCategory = primaryCategory
40:         self.tags = tags
41:         self.rating = rating
42:         self.reviewCount = reviewCount
43:         self.coordinates = coordinates
44:         self.neighborhoodId = neighborhoodId
45:         self.address = address
46:         self.description = description
47:         self.thumbnailUrl = thumbnailUrl
48:         self.details = details
49:         self.createdAt = createdAt
50:         self.updatedAt = updatedAt
51:     }
52: }
</file>

<file path="sightline/sightline/Preview Content/Preview Assets.xcassets/Contents.json">
1: {
2:   "info" : {
3:     "author" : "xcode",
4:     "version" : 1
5:   }
6: }
</file>

<file path="sightline/sightline/Services/AuthService.swift">
 1: import FirebaseAuth
 2: 
 3: protocol AuthServiceProtocol {
 4: 
 5:     var currentUser: User? { get }
 6:     var userId: String? { get }
 7:     var isAuthenticated: Bool { get }
 8: 
 9: 
10:     func signInAnonymously() async throws
11:     func signOut() throws
12: }
13: 
14: class AuthService: AuthServiceProtocol {
15:     private let auth = Auth.auth()
16: 
17:     var currentUser: User? {
18:         auth.currentUser
19:     }
20: 
21:     var userId: String? {
22:         currentUser?.uid
23:     }
24: 
25:     var isAuthenticated: Bool {
26:         currentUser != nil
27:     }
28: 
29:     func signInAnonymously() async throws {
30: 
31:         guard currentUser == nil else { return }
32: 
33:         do {
34:             let result = try await auth.signInAnonymously()
35:             print("Signed in anonymously with uid: \(result.user.uid)")
36:         } catch {
37:             print("Error signing in: \(error.localizedDescription)")
38:             throw error
39:         }
40:     }
41: 
42:     func signOut() throws {
43:         try auth.signOut()
44:     }
45: }
</file>

<file path="sightline/sightline/Services/FirestoreError.swift">
1: enum FirestoreError: Error {
2:     case decodingError
3:     case documentNotFound
4:     case invalidData
5: }
</file>

<file path="sightline/sightline/Services/FirestoreService.swift">
  1: import FirebaseFirestore
  2: import FirebaseStorage
  3: import AVKit
  4: import FirebaseAuth
  5: 
  6: protocol FirestoreServiceProtocol {
  7: 
  8:     func fetchUnlockedNeighborhoods(for userId: String) async throws -> [Neighborhood]
  9: 
 10: 
 11: 
 12: 
 13: 
 14: 
 15:     func fetchContentForPlace(placeId: String) async throws -> [Content]
 16:     func fetchContentByCategory(category: FilterCategory, neighborhoodId: String?) async throws -> [Content]
 17:     func saveDetectionResult(landmarkName: String) async throws
 18: 
 19: 
 20:     func fetchPlace(id: String) async throws -> Place
 21:     func fetchPlacesInNeighborhood(neighborhoodId: String) async throws -> [Place]
 22:     func addPlace(_ place: Place) async throws
 23:     func fetchAvailableCategories(for neighborhoodId: String) async throws -> [FilterCategory]
 24: 
 25: 
 26:     func savePlaceForUser(userId: String, placeId: String) async throws
 27:     func fetchSavedPlaceIds(for userId: String) async throws -> [String]
 28: }
 29: 
 30: class FirestoreService: FirestoreServiceProtocol {
 31: 
 32:     let db = Firestore.firestore()
 33:     let storage = Storage.storage()
 34: 
 35: 
 36:     func fetchPlacesInNeighborhood(neighborhoodId: String) async throws -> [Place] {
 37:         let query = db.collection("places").whereField("neighborhoodId", isEqualTo: neighborhoodId)
 38:         let snapshot = try await query.getDocuments()
 39: 
 40:         return try snapshot.documents.map { try $0.data(as: Place.self) }
 41:     }
 42: 
 43:     func addPlace(_ place: Place) async throws {
 44:         try db.collection("places")
 45:             .document(place.id)
 46:             .setData(from: place)
 47:     }
 48: 
 49:     func fetchPlace(id: String) async throws -> Place {
 50:         let docRef = db.collection("places").document(id)
 51:         let document = try await docRef.getDocument()
 52:         return try document.data(as: Place.self)
 53:     }
 54: 
 55: 
 56:     func fetchContentForPlace(placeId: String) async throws -> [Content] {
 57:         let snapshot = try await db.collection("content")
 58:             .whereField("placeId", isEqualTo: placeId)
 59:             .order(by: "createdAt", descending: true)
 60:             .getDocuments()
 61: 
 62:         return snapshot.documents.compactMap { document in
 63:             try? document.data(as: Content.self)
 64:         }
 65:     }
 66: 
 67:     func fetchContentByCategory(category: FilterCategory, neighborhoodId: String?) async throws -> [Content] {
 68:         print("🔍 Fetching content for category: \(category.rawValue), neighborhood: \(neighborhoodId ?? "all")")
 69: 
 70:         var query = db.collection("content")
 71:             .whereField("tags", arrayContains: category.rawValue)
 72:             .order(by: "createdAt", descending: true)
 73: 
 74:         if let neighborhoodId = neighborhoodId {
 75:             query = query.whereField("neighborhoodId", isEqualTo: neighborhoodId)
 76:         }
 77: 
 78:         let snapshot = try await query.getDocuments()
 79: 
 80:         let content = snapshot.documents.compactMap { document -> Content? in
 81:             guard let content = try? document.data(as: Content.self) else {
 82:                 print("⚠️ Failed to decode content: \(document.documentID)")
 83:                 return nil
 84:             }
 85:             return content
 86:         }
 87: 
 88:         print("✅ Found \(content.count) content items")
 89:         return content
 90:     }
 91: 
 92: 
 93:     func saveDetectionResult(landmarkName: String) async throws {
 94:         let landmarkData: [String: Any] = [
 95:             "name": landmarkName,
 96:             "detectedAt": FieldValue.serverTimestamp()
 97:         ]
 98: 
 99:         try await db.collection("detectedLandmarks")
100:             .addDocument(data: landmarkData)
101:     }
102: 
103:     func fetchUnlockedNeighborhoods(for userId: String) async throws -> [Neighborhood] {
104:         print("🔍 Fetching unlocked neighborhoods for user: \(userId)")
105: 
106: 
107:         let unlockedSnapshot = try await db.collection("users")
108:             .document(userId)
109:             .collection("unlocked_neighborhoods")
110:             .getDocuments()
111: 
112: 
113:         let neighborhoodIds = unlockedSnapshot.documents.map { $0.documentID }
114: 
115:         guard !neighborhoodIds.isEmpty else {
116:             print("⚠️ No unlocked neighborhoods found for user")
117:             return []
118:         }
119: 
120: 
121:         let neighborhoodSnapshot = try await db.collection("neighborhoods")
122:             .whereField(FieldPath.documentID(), in: neighborhoodIds)
123:             .getDocuments()
124: 
125:         let neighborhoods = neighborhoodSnapshot.documents.compactMap { document -> Neighborhood? in
126:             try? document.data(as: Neighborhood.self)
127:         }
128: 
129:         print("✅ Found \(neighborhoods.count) unlocked neighborhoods")
130:         return neighborhoods
131:     }
132: 
133: 
134:     private func decodeGeoBounds(from data: [String: Any]) throws -> Neighborhood.GeoBounds {
135:         guard let northeast = data["northeast"] as? [String: Any],
136:               let southwest = data["southwest"] as? [String: Any] else {
137:             throw DecodingError.dataCorrupted(.init(codingPath: [], debugDescription: "Missing bounds data"))
138:         }
139: 
140:         return Neighborhood.GeoBounds(
141:             northeast: .init(
142:                 lat: northeast["lat"] as? Double ?? 0,
143:                 lng: northeast["lng"] as? Double ?? 0
144:             ),
145:             southwest: .init(
146:                 lat: southwest["lat"] as? Double ?? 0,
147:                 lng: southwest["lng"] as? Double ?? 0
148:             )
149:         )
150:     }
151: 
152: 
153:     private func decodeLandmarks(from data: [[String: Any]]) throws -> [Neighborhood.Landmark]? {
154:         return data.compactMap { landmarkData in
155:             guard let location = landmarkData["location"] as? GeoPoint,
156:                   let mid = landmarkData["mid"] as? String,
157:                   let name = landmarkData["name"] as? String else {
158:                 return nil
159:             }
160: 
161:             return Neighborhood.Landmark(
162:                 location: location,
163:                 mid: mid,
164:                 name: name
165:             )
166:         }
167:     }
168: 
169:     func fetchAvailableCategories(for neighborhoodId: String) async throws -> [FilterCategory] {
170:         print("🔍 Fetching available categories for neighborhood: \(neighborhoodId)")
171: 
172:         let snapshot = try await db.collection("content")
173:             .whereField("neighborhoodId", isEqualTo: neighborhoodId)
174:             .getDocuments()
175: 
176: 
177:         var categorySet = Set<String>()
178: 
179: 
180:         for document in snapshot.documents {
181:             if let tags = document.data()["tags"] as? [String] {
182:                 categorySet.formUnion(tags)
183:             }
184:         }
185: 
186: 
187:         let categories = categorySet.compactMap { tagString -> FilterCategory? in
188:             return FilterCategory(rawValue: tagString)
189:         }.sorted { $0.rawValue < $1.rawValue }
190: 
191:         print("✅ Found \(categories.count) available categories")
192:         return categories
193:     }
194: 
195: 
196: 
197: 
198:     func savePlaceForUser(userId: String, placeId: String) async throws {
199:         let docRef = db.collection("users")
200:             .document(userId)
201:             .collection("saved_places")
202:             .document(placeId)
203: 
204:         try await docRef.setData([
205:             "savedAt": FieldValue.serverTimestamp()
206:         ])
207:     }
208: 
209: 
210:     func fetchSavedPlaceIds(for userId: String) async throws -> [String] {
211:         let snapshot = try await db.collection("users")
212:             .document(userId)
213:             .collection("saved_places")
214:             .getDocuments()
215: 
216:         return snapshot.documents.map { $0.documentID }
217:     }
218: 
219:     func createAnnotationRequest(imageURL: String, originalFilename: String) async throws {
220:         let annotationRequest = [
221:             "imageURL": imageURL,
222:             "originalFilename": originalFilename,
223:             "status": "pending",
224:             "createdAt": Timestamp(),
225:             "updatedAt": Timestamp()
226:         ] as [String : Any]
227: 
228:         try await db.collection("annotationRequests").addDocument(data: annotationRequest)
229:     }
230: }
</file>

<file path="sightline/sightline/Services/FirestoreService+TestData.swift">
1: 
</file>

<file path="sightline/sightline/Services/ServiceContainer.swift">
 1: import Foundation
 2: 
 3: 
 4: class ServiceContainer {
 5: 
 6:     static let shared = ServiceContainer()
 7: 
 8: 
 9:     let auth: AuthServiceProtocol
10:     let firestore: FirestoreServiceProtocol
11: 
12: 
13:     private init() {
14:         self.auth = AuthService()
15:         self.firestore = FirestoreService()
16:     }
17: }
</file>

<file path="sightline/sightline/Services/VideoPlayerManager.swift">
  1: import AVFoundation
  2: import Combine
  3: import SwiftUI
  4: import FirebaseStorage
  5: import AVKit
  6: import Foundation
  7: 
  8: @MainActor
  9: final class VideoPlayerManager: ObservableObject {
 10:     @Published private(set) var currentPlayer: AVPlayer?
 11:     @Published private(set) var isLoading = false
 12:     @Published private(set) var error: Error?
 13: 
 14:     private var playerLooper: AVPlayerLooper?
 15:     private var cancellables = Set<AnyCancellable>()
 16: 
 17: 
 18:     private var preloadedPlayers: [String: AVQueuePlayer] = [:]
 19: 
 20:     private var preloadedVideosQueue: [String] = []
 21: 
 22:     private let maxCacheSize = 10
 23: 
 24:     private var preloadTasks: [String: Task<Void, Never>] = [:]
 25:     private let preloadLimit = 2
 26: 
 27:     private var currentlyPlayingUrl: String?
 28: 
 29:     func prepareForDisplay(url: String) async {
 30:         await cleanup()
 31:         isLoading = true
 32:         error = nil
 33: 
 34:         do {
 35:             let downloadUrl = try await getDownloadURL(for: url)
 36:             let asset = AVURLAsset(url: downloadUrl)
 37: 
 38:             guard try await asset.load(.isPlayable) else {
 39:                 throw NSError(domain: "VideoPlayerManager", code: -1,
 40:                               userInfo: [NSLocalizedDescriptionKey: "Video is not playable"])
 41:             }
 42: 
 43:             let item = AVPlayerItem(asset: asset)
 44:             let player = AVQueuePlayer(playerItem: item)
 45:             playerLooper = AVPlayerLooper(player: player, templateItem: item)
 46: 
 47: 
 48:             try await waitUntilPlayerItemReady(item)
 49: 
 50:             player.publisher(for: \.status)
 51:                 .sink { [weak self] status in
 52:                     if status == .failed {
 53:                         self?.error = player.error
 54:                     }
 55:                 }
 56:                 .store(in: &cancellables)
 57: 
 58:             self.currentPlayer = player
 59:             self.isLoading = false
 60:             player.play()
 61:         } catch {
 62:             self.error = error
 63:             self.isLoading = false
 64:         }
 65:     }
 66: 
 67: 
 68:     private func waitUntilPlayerItemReady(_ item: AVPlayerItem) async throws {
 69:         while item.status != .readyToPlay {
 70:             if item.status == .failed {
 71:                 throw item.error ?? NSError(domain: "VideoPlayerManager", code: -1,
 72:                                              userInfo: [NSLocalizedDescriptionKey: "Failed to load video"])
 73:             }
 74:             try await Task.sleep(nanoseconds: 50_000_000)
 75:         }
 76:     }
 77: 
 78:     func preloadVideos(for urls: [String], at index: Int) {
 79: 
 80:         cleanupDistantPreloads(currentIndex: index)
 81: 
 82: 
 83:         let start = max(0, index - preloadLimit)
 84:         let end = min(urls.count - 1, index + preloadLimit)
 85: 
 86:         for i in start...end where i != index {
 87:             let url = urls[i]
 88:             if preloadedPlayers[url] == nil && preloadTasks[url] == nil {
 89:                 preloadTasks[url] = Task {
 90:                     await preloadVideo(url)
 91:                 }
 92:             }
 93:         }
 94:     }
 95: 
 96:     private func preloadVideo(_ url: String) async {
 97:         print("🔄 Preloading video: \(url)")
 98:         do {
 99:             let downloadUrl = try await getDownloadURL(for: url)
100:             let asset = AVURLAsset(url: downloadUrl)
101: 
102:             if try await asset.load(.isPlayable) {
103:                 let item = AVPlayerItem(asset: asset)
104:                 let player = AVQueuePlayer(playerItem: item)
105: 
106:                 try await waitUntilPlayerItemReady(item)
107:                 preloadedPlayers[url] = player
108: 
109: 
110:                 preloadedVideosQueue.append(url)
111:                 if preloadedVideosQueue.count > maxCacheSize {
112:                     let oldestUrl = preloadedVideosQueue.removeFirst()
113:                     preloadedPlayers[oldestUrl]?.pause()
114:                     preloadedPlayers[oldestUrl] = nil
115:                     print("🗑 Purged oldest video: \(oldestUrl) from cache")
116:                 }
117: 
118:                 print("✅ Successfully preloaded: \(url)")
119:             }
120:         } catch {
121:             print("❌ Error preloading video: \(error)")
122:         }
123:         preloadTasks[url] = nil
124:     }
125: 
126:     private func cleanupDistantPreloads(currentIndex: Int) {
127: 
128: 
129:     }
130: 
131:     func playerFor(url: String) -> AVPlayer? {
132:         if url == currentlyPlayingUrl {
133:             return currentPlayer
134:         }
135:         return preloadedPlayers[url]
136:     }
137: 
138: 
139:     func activatePlayerAsync(for url: String) async {
140: 
141:         if currentlyPlayingUrl == url, currentPlayer != nil {
142:             print("🔄 Video \(url) already active. Skipping reactivation.")
143:             return
144:         }
145: 
146:         print("🎥 Activating player for URL: \(url)")
147:         if let player = preloadedPlayers[url] {
148:             print("✅ Found preloaded player")
149:             await cleanup()
150:             currentPlayer = player
151:             currentlyPlayingUrl = url
152:             await player.seek(to: .zero)
153:             player.play()
154:         } else {
155:             print("⚠️ No preloaded player found, loading directly")
156:             await prepareForDisplay(url: url)
157:             currentlyPlayingUrl = url
158:         }
159:     }
160: 
161:     private func getDownloadURL(for gsUrl: String) async throws -> URL {
162:         let storageRef = Storage.storage().reference(forURL: gsUrl)
163:         return try await storageRef.downloadURL()
164:     }
165: 
166:     func cleanup() async {
167:         currentPlayer?.pause()
168:         playerLooper = nil
169:         currentPlayer = nil
170:         currentlyPlayingUrl = nil
171:         error = nil
172:         isLoading = false
173:         cancellables.removeAll()
174:     }
175: 
176: 
177:     func clearCache() {
178:         preloadedPlayers.forEach { (_, player) in
179:             player.pause()
180:         }
181:         preloadedPlayers.removeAll()
182:         preloadedVideosQueue.removeAll()
183:         preloadTasks.removeAll()
184:         print("Cleared video cache")
185:     }
186: }
187: 
188: extension VideoPlayerManager {
189:     nonisolated static func create() async -> VideoPlayerManager {
190:         await MainActor.run { VideoPlayerManager() }
191:     }
192: }
</file>

<file path="sightline/sightline/sightline.xcdatamodeld/sightline.xcdatamodel/contents">
1: <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
2: <model type="com.apple.IDECoreDataModeler.DataModel" documentVersion="1.0" lastSavedToolsVersion="1" systemVersion="11A491" minimumToolsVersion="Automatic" sourceLanguage="Swift" usedWithCloudKit="false" userDefinedModelVersionIdentifier="">
3:     <entity name="Item" representedClassName="Item" syncable="YES" codeGenerationType="class">
4:         <attribute name="timestamp" optional="YES" attributeType="Date" usesScalarValueType="NO"/>
5:     </entity>
6:     <elements>
7:         <element name="Item" positionX="-63" positionY="-18" width="128" height="44"/>
8:     </elements>
9: </model>
</file>

<file path="sightline/sightline/sightline.xcdatamodeld/.xccurrentversion">
1: <?xml version="1.0" encoding="UTF-8"?>
2: <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
3: <plist version="1.0">
4: <dict>
5: 	<key>_XCCurrentVersionName</key>
6: 	<string>sightline.xcdatamodel</string>
7: </dict>
8: </plist>
</file>

<file path="sightline/sightline/State/AppState.swift">
 1: import SwiftUI
 2: 
 3: class AppState: ObservableObject {
 4:     @Published var shouldSwitchToFeed = false
 5:     @Published var shouldSwitchToDiscover = false
 6:     @Published var lastUnlockedNeighborhoodId: String?
 7:     @Published var navigationPath = NavigationPath()
 8: 
 9: 
10:     @Published var shouldSwitchToProfile = false
11: 
12:     enum NavigationDestination: Hashable {
13:         case placeDetail(placeId: String, initialContentId: String)
14:     }
15: }
</file>

<file path="sightline/sightline/State/AppViewModel.swift">
 1: import SwiftUI
 2: 
 3: @MainActor
 4: final class AppViewModel: ObservableObject {
 5:     @Published private(set) var isPreloading = true
 6:     private let services = ServiceContainer.shared
 7: 
 8:     func preloadAppData() async {
 9:         guard let userId = services.auth.userId else { return }
10: 
11:         do {
12: 
13:             let neighborhoods = try await services.firestore.fetchUnlockedNeighborhoods(for: userId)
14: 
15: 
16:             if let firstNeighborhood = neighborhoods.first {
17:                 let categories = try await services.firestore.fetchAvailableCategories(
18:                     for: firstNeighborhood.id!
19:                 )
20: 
21: 
22:                 if let encodedNeighborhoods = try? JSONEncoder().encode(neighborhoods) {
23:                     UserDefaults.standard.set(encodedNeighborhoods, forKey: "preloadedNeighborhoods")
24:                 }
25:                 if let encodedCategories = try? JSONEncoder().encode(categories) {
26:                     UserDefaults.standard.set(encodedCategories, forKey: "preloadedCategories")
27:                 }
28:             }
29:         } catch {
30:             print("Error preloading app data: \(error)")
31:         }
32: 
33:         isPreloading = false
34:     }
35: }
</file>

<file path="sightline/sightline/Views/Components/AdaptiveColorButton.swift">
  1: import SwiftUI
  2: import UIKit
  3: 
  4: struct AdaptiveColorButton<Label: View>: View {
  5:     let action: () -> Void
  6:     let label: () -> Label
  7:     let isSelected: Bool
  8:     let expandHorizontally: Bool
  9: 
 10:     init(
 11:         isSelected: Bool,
 12:         expandHorizontally: Bool = false,
 13:         action: @escaping () -> Void,
 14:         @ViewBuilder label: @escaping () -> Label
 15:     ) {
 16:         self.isSelected = isSelected
 17:         self.expandHorizontally = expandHorizontally
 18:         self.action = action
 19:         self.label = label
 20:     }
 21: 
 22:     var body: some View {
 23:         Button(action: action) {
 24:             ZStack {
 25: 
 26:                 Color.white.opacity(isSelected ? 0.95 : 0.4)
 27:                     .background(.ultraThickMaterial)
 28:                     .frame(height: 36)
 29:                     .cornerRadius(8)
 30: 
 31:                     .shadow(color: .black.opacity(0.2), radius: 4, x: 0, y: 2)
 32:                     .overlay {
 33: 
 34:                         LinearGradient(
 35:                             colors: [
 36:                                 .white.opacity(0.6),
 37:                                 .gray.opacity(0.1)
 38:                             ],
 39:                             startPoint: .topLeading,
 40:                             endPoint: .bottomTrailing
 41:                         )
 42:                         .cornerRadius(8)
 43:                     }
 44:                     .overlay {
 45: 
 46:                         RoundedRectangle(cornerRadius: 8)
 47:                             .stroke(.white.opacity(0.5), lineWidth: 1)
 48:                     }
 49: 
 50: 
 51:                 label()
 52:                     .foregroundColor(.black)
 53:                     .controlSize(.small)
 54:                     .padding(.horizontal, 12)
 55:                     .padding(.vertical, 8)
 56:             }
 57:             .fixedSize(horizontal: true, vertical: false)
 58:             .frame(height: 36)
 59:         }
 60:         .scaleEffect(isSelected ? 0.98 : 1.0)
 61:         .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isSelected)
 62:     }
 63: }
 64: 
 65: 
 66: private struct ColorPreferenceKey: PreferenceKey {
 67:     static var defaultValue: CGRect = .zero
 68: 
 69:     static func reduce(value: inout CGRect, nextValue: () -> CGRect) {
 70:         value = nextValue()
 71:     }
 72: }
 73: 
 74: extension UIImage {
 75:     func cropToFrame(_ frame: CGRect) -> UIImage {
 76:         guard let cgImage = self.cgImage else { return self }
 77:         let scaledFrame = CGRect(
 78:             x: frame.origin.x * scale,
 79:             y: frame.origin.y * scale,
 80:             width: frame.width * scale,
 81:             height: frame.height * scale
 82:         )
 83:         guard let croppedCGImage = cgImage.cropping(to: scaledFrame) else { return self }
 84:         return UIImage(cgImage: croppedCGImage)
 85:     }
 86: 
 87:     func averageColor() -> UIColor {
 88:         guard let inputImage = CIImage(image: self) else { return .white }
 89:         let extentVector = CIVector(x: inputImage.extent.origin.x,
 90:                                   y: inputImage.extent.origin.y,
 91:                                   z: inputImage.extent.size.width,
 92:                                   w: inputImage.extent.size.height)
 93: 
 94:         guard let filter = CIFilter(name: "CIAreaAverage",
 95:                                   parameters: [kCIInputImageKey: inputImage,
 96:                                              kCIInputExtentKey: extentVector]) else { return .white }
 97:         guard let outputImage = filter.outputImage else { return .white }
 98: 
 99:         var bitmap = [UInt8](repeating: 0, count: 4)
100:         let context = CIContext(options: [.workingColorSpace: kCFNull as Any])
101:         context.render(outputImage,
102:                       toBitmap: &bitmap,
103:                       rowBytes: 4,
104:                       bounds: CGRect(x: 0, y: 0, width: 1, height: 1),
105:                       format: .RGBA8,
106:                       colorSpace: nil)
107: 
108:         return UIColor(red: CGFloat(bitmap[0]) / 255,
109:                       green: CGFloat(bitmap[1]) / 255,
110:                       blue: CGFloat(bitmap[2]) / 255,
111:                       alpha: CGFloat(bitmap[3]) / 255)
112:     }
113: }
114: 
115: extension UIColor {
116:     func getBrightness() -> CGFloat {
117:         var red: CGFloat = 0
118:         var green: CGFloat = 0
119:         var blue: CGFloat = 0
120:         var alpha: CGFloat = 0
121: 
122:         getRed(&red, green: &green, blue: &blue, alpha: &alpha)
123: 
124: 
125:         return ((red * 299) + (green * 587) + (blue * 114)) / 1000
126:     }
127: }
128: 
129: #Preview {
130:     VStack(spacing: 20) {
131: 
132:         AdaptiveColorButton(isSelected: false) {
133: 
134:         } label: {
135:             Text("Default Button")
136:         }
137: 
138: 
139:         AdaptiveColorButton(isSelected: true) {
140: 
141:         } label: {
142:             Text("Selected Button")
143:         }
144: 
145: 
146:         AdaptiveColorButton(isSelected: false) {
147: 
148:         } label: {
149:             Text("Button with Longer Text")
150:         }
151: 
152: 
153:         AdaptiveColorButton(isSelected: false) {
154: 
155:         } label: {
156:             HStack {
157:                 Image(systemName: "star.fill")
158:                 Text("Icon Button")
159:             }
160:         }
161:     }
162:     .padding()
163:     .frame(maxWidth: .infinity)
164:     .background(Color.black)
165: }
</file>

<file path="sightline/sightline/Views/Components/FloatingMenuButton.swift">
  1: import SwiftUI
  2: 
  3: 
  4: extension View {
  5:     @ViewBuilder func `if`<Content: View>(
  6:         _ condition: Bool,
  7:         transform: (Self) -> Content
  8:     ) -> some View {
  9:         if condition {
 10:             transform(self)
 11:         } else {
 12:             self
 13:         }
 14:     }
 15: }
 16: 
 17: struct FloatingMenuButton<Label: View>: View {
 18:     let action: () -> Void
 19:     let label: () -> Label
 20:     let isSelected: Bool
 21:     let expandHorizontally: Bool
 22: 
 23:     @State private var buttonFrame: CGRect = .zero
 24: 
 25:     init(
 26:         action: @escaping () -> Void,
 27:         isSelected: Bool = false,
 28:         expandHorizontally: Bool = false,
 29:         @ViewBuilder label: @escaping () -> Label
 30:     ) {
 31:         self.action = action
 32:         self.isSelected = isSelected
 33:         self.expandHorizontally = expandHorizontally
 34:         self.label = label
 35:     }
 36: 
 37:     var body: some View {
 38:         AdaptiveColorButton(
 39:             isSelected: isSelected,
 40:             expandHorizontally: expandHorizontally,
 41:             action: action,
 42:             label: label
 43:         )
 44:         .background(
 45:             GeometryReader { geo in
 46:                 Color.clear.onAppear {
 47:                     buttonFrame = geo.frame(in: .global)
 48:                 }
 49:             }
 50:         )
 51:     }
 52: }
 53: 
 54: struct FloatingMenu<T: Identifiable>: View {
 55:     let items: [T]
 56:     let itemTitle: (T) -> String
 57:     let selectedId: T.ID?
 58:     let onSelect: (T) -> Void
 59:     let alignment: HorizontalAlignment
 60:     @Binding var isExpanded: Bool
 61:     let onExploreMore: (() -> Void)?
 62: 
 63: 
 64:     @Namespace private var menuAnimation
 65: 
 66:     init(
 67:         items: [T],
 68:         itemTitle: @escaping (T) -> String,
 69:         selectedId: T.ID?,
 70:         onSelect: @escaping (T) -> Void,
 71:         alignment: HorizontalAlignment,
 72:         isExpanded: Binding<Bool>,
 73:         onExploreMore: (() -> Void)? = nil
 74:     ) {
 75:         self.items = items
 76:         self.itemTitle = itemTitle
 77:         self.selectedId = selectedId
 78:         self.onSelect = onSelect
 79:         self.alignment = alignment
 80:         self._isExpanded = isExpanded
 81:         self.onExploreMore = onExploreMore
 82:     }
 83: 
 84:     var body: some View {
 85: 
 86:         let triggerItem = items.first { $0.id == selectedId } ?? items.first
 87: 
 88:         VStack(alignment: alignment, spacing: 12) {
 89: 
 90:             VStack(alignment: alignment, spacing: 0) {
 91:                 FloatingMenuButton(
 92:                     action: {
 93:                         withAnimation(.spring(response: 0.4, dampingFraction: 0.8, blendDuration: 0.1)) {
 94: 
 95:                                 isExpanded.toggle()
 96: 
 97: 
 98: 
 99:                         }
100:                     },
101:                     isSelected: triggerItem?.id == selectedId,
102:                     expandHorizontally: alignment == .leading
103:                 ) {
104: 
105: 
106:                     Text(triggerItem.map(itemTitle) ?? "")
107:                         .if(!isExpanded) { view in
108:                             view.matchedGeometryEffect(id: "menuItem", in: menuAnimation)
109:                         }
110:                 }
111:             }
112: 
113: 
114:             VStack(alignment: alignment, spacing: 12) {
115:                 ForEach(Array(items.filter { $0.id != triggerItem?.id }.enumerated()),
116:                         id: \.element.id) { index, item in
117:                     FloatingMenuButton(
118:                         action: {
119:                             withAnimation(
120:                                 .spring(response: 0.4, dampingFraction: 0.8, blendDuration: 0.1)
121:                                     .delay(Double(index) * 0.05)
122:                             ) {
123:                                 onSelect(item)
124:                                 isExpanded = false
125:                             }
126:                         },
127:                         isSelected: item.id == selectedId,
128:                         expandHorizontally: alignment == .leading
129:                     ) {
130: 
131:                         Text(itemTitle(item))
132:                             .if(item.id == selectedId && isExpanded) { view in
133:                                 view.matchedGeometryEffect(id: "menuItem", in: menuAnimation)
134:                             }
135:                     }
136:                     .offset(x: isExpanded ? 0 : (alignment == .leading ? -200 : 200))
137:                     .animation(
138:                         .spring(response: 0.4, dampingFraction: 0.8, blendDuration: 0.1)
139:                             .delay(Double(index) * 0.05),
140:                         value: isExpanded
141:                     )
142:                 }
143: 
144: 
145: 
146: 
147: 
148: 
149: 
150: 
151: 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
164: 
165: 
166:             }
167:             .clipped()
168:             .frame(height: isExpanded ? nil : 0)
169:         }
170:         .frame(maxHeight: .infinity, alignment: .top)
171:     }
172: }
173: 
174: #Preview("FloatingMenu") {
175:     struct PreviewItem: Identifiable {
176:         let id: String
177:         let name: String
178:     }
179: 
180:     struct PreviewWrapper: View {
181:         @State private var leftExpanded = false
182:         @State private var rightExpanded = false
183:         @State private var singleExpanded = false
184:         @State private var leftSelected = "1"
185:         @State private var rightSelected = "2"
186: 
187:         let items = [
188:             PreviewItem(id: "1", name: "Dashboard"),
189:             PreviewItem(id: "2", name: "Reports"),
190:             PreviewItem(id: "3", name: "Settings")
191:         ]
192: 
193:         var body: some View {
194:             ZStack {
195:                 Color.black.ignoresSafeArea()
196: 
197:                 VStack(spacing: 40) {
198: 
199:                     FloatingMenu(
200:                         items: items,
201:                         itemTitle: { $0.name },
202:                         selectedId: leftSelected,
203:                         onSelect: { item in
204:                             leftSelected = item.id
205:                             leftExpanded = false
206:                         },
207:                         alignment: .leading,
208:                         isExpanded: $leftExpanded
209:                     )
210: 
211: 
212:                     FloatingMenu(
213:                         items: items,
214:                         itemTitle: { $0.name },
215:                         selectedId: rightSelected,
216:                         onSelect: { item in
217:                             rightSelected = item.id
218:                             rightExpanded = false
219:                         },
220:                         alignment: .trailing,
221:                         isExpanded: $rightExpanded
222:                     )
223: 
224: 
225:                     FloatingMenu(
226:                         items: [items[0]],
227:                         itemTitle: { $0.name },
228:                         selectedId: "1",
229:                         onSelect: { _ in },
230:                         alignment: .leading,
231:                         isExpanded: $singleExpanded,
232:                         onExploreMore: {}
233:                     )
234:                 }
235:                 .padding()
236:             }
237:         }
238:     }
239: 
240:     return PreviewWrapper()
241: }
</file>

<file path="sightline/sightline/Views/Components/ScanningAnimation.swift">
 1: import SwiftUI
 2: 
 3: struct ScanningAnimation: View {
 4:     let namespace: Namespace.ID
 5:     @State private var position: CGFloat = 0.0
 6: 
 7:     var body: some View {
 8:         GeometryReader { geometry in
 9:             let halfHeight = geometry.size.height / 2
10:             let scanningTop = geometry.size.height * 0.1 - halfHeight
11:             let scanningBottom = geometry.size.height * 0.9 - halfHeight
12: 
13:             ZStack {
14: 
15:                 Rectangle()
16:                     .fill(
17:                         LinearGradient(
18:                             gradient: Gradient(colors: [
19:                                 .clear,
20:                                 .blue.opacity(0.5),
21:                                 .blue,
22:                                 .blue.opacity(0.5),
23:                                 .clear
24:                             ]),
25:                             startPoint: .leading,
26:                             endPoint: .trailing
27:                         )
28:                     )
29:                     .frame(height: 3)
30:                     .offset(y: position)
31:                     .shadow(color: .blue.opacity(0.5), radius: 4)
32:                     .matchedGeometryEffect(id: "scannerLine", in: namespace)
33: 
34: 
35:                 ScannerCorners()
36:                     .stroke(Color.white.opacity(0.7), lineWidth: 3)
37:                     .frame(width: geometry.size.width * 0.8,
38:                            height: geometry.size.height * 0.7)
39:                     .position(x: geometry.size.width / 2,
40:                               y: geometry.size.height / 2)
41:                     .matchedGeometryEffect(id: "scannerCorners", in: namespace)
42: 
43:             }
44:             .onAppear {
45:                 position = scanningTop
46:                 withAnimation(
47:                     .easeInOut(duration: 2.0)
48:                         .repeatForever(autoreverses: true)
49:                 ) {
50:                     position = scanningBottom
51:                 }
52:             }
53:         }
54:     }
55: }
56: 
57: struct ScannerCorners: Shape {
58:     func path(in rect: CGRect) -> Path {
59:         var path = Path()
60:         let cornerLength: CGFloat = 30
61: 
62: 
63:         path.move(to: CGPoint(x: rect.minX, y: rect.minY + cornerLength))
64:         path.addLine(to: CGPoint(x: rect.minX, y: rect.minY))
65:         path.addLine(to: CGPoint(x: rect.minX + cornerLength, y: rect.minY))
66: 
67: 
68:         path.move(to: CGPoint(x: rect.maxX - cornerLength, y: rect.minY))
69:         path.addLine(to: CGPoint(x: rect.maxX, y: rect.minY))
70:         path.addLine(to: CGPoint(x: rect.maxX, y: rect.minY + cornerLength))
71: 
72: 
73:         path.move(to: CGPoint(x: rect.maxX, y: rect.maxY - cornerLength))
74:         path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY))
75:         path.addLine(to: CGPoint(x: rect.maxX - cornerLength, y: rect.maxY))
76: 
77: 
78:         path.move(to: CGPoint(x: rect.minX + cornerLength, y: rect.maxY))
79:         path.addLine(to: CGPoint(x: rect.minX, y: rect.maxY))
80:         path.addLine(to: CGPoint(x: rect.minX, y: rect.maxY - cornerLength))
81: 
82:         return path
83:     }
84: }
</file>

<file path="sightline/sightline/Views/Components/ScanningTransitionView.swift">
 1: import SwiftUI
 2: 
 3: struct ScanningTransitionView: View {
 4:     let namespace: Namespace.ID
 5:     @State private var animateTransition = false
 6: 
 7:     var body: some View {
 8:         GeometryReader { geometry in
 9:             ZStack {
10: 
11:                 Rectangle()
12:                     .fill(
13:                         LinearGradient(
14:                             gradient: Gradient(colors: [
15:                                 .clear,
16:                                 .blue.opacity(0.9),
17:                                 .blue,
18:                                 .blue.opacity(0.9),
19:                                 .clear
20:                             ]),
21:                             startPoint: .leading,
22:                             endPoint: .trailing
23:                         )
24:                     )
25: 
26:                     .frame(height: animateTransition ? 100 : 3)
27:                     .shadow(color: .blue.opacity(animateTransition ? 1.0 : 0.5),
28:                             radius: animateTransition ? 30 : 4)
29:                     .matchedGeometryEffect(id: "scannerLine", in: namespace)
30:                     .opacity(animateTransition ? 0 : 1)
31: 
32: 
33:                 ScannerCorners()
34:                     .stroke(Color.white.opacity(0.7), lineWidth: animateTransition ? 1 : 3)
35:                     .frame(width: animateTransition ? geometry.size.width * 1.5 : geometry.size.width * 0.8,
36:                            height: animateTransition ? geometry.size.height * 1.5 : geometry.size.height * 0.8)
37:                     .position(x: geometry.size.width / 2, y: geometry.size.height / 2)
38:                     .matchedGeometryEffect(id: "scannerCorners", in: namespace)
39:                     .opacity(animateTransition ? 0 : 1)
40:             }
41:             .onAppear {
42: 
43:                 withAnimation(.easeInOut(duration: 1.2)) {
44:                     animateTransition = true
45:                 }
46:             }
47:         }
48:         .ignoresSafeArea()
49:     }
50: }
</file>

<file path="sightline/sightline/Views/ContentFeedView/ContentFeedView.swift">
  1: import SwiftUI
  2: import UIKit
  3: 
  4: struct ContentFeedView: View {
  5:     @EnvironmentObject var appState: AppState
  6:     @EnvironmentObject var viewModel: ContentFeedViewModel
  7: 
  8:     @State private var showingNeighborhoods = false
  9:     @State private var showingCategories = false
 10:     @State private var selectedPlaceId: String? = nil
 11: 
 12:     var body: some View {
 13:         ZStack(alignment: .top) {
 14:             Color.black.ignoresSafeArea()
 15: 
 16:             if viewModel.isLoading {
 17:                 LoadingState()
 18:             } else if !viewModel.hasLoadedNeighborhoods {
 19:                 LoadingState()
 20:             } else if viewModel.unlockedNeighborhoods.isEmpty {
 21:                 EmptyNeighborhoodState()
 22:             } else if viewModel.contentItems.isEmpty {
 23:                 Text("No content available")
 24:                     .foregroundColor(.white)
 25:             } else {
 26:                 VerticalFeedView(
 27:                     currentIndex: $viewModel.currentIndex,
 28:                     itemCount: viewModel.contentItems.count,
 29:                     onIndexChanged: { index in
 30:                         viewModel.currentIndex = index
 31:                     }
 32:                 ) { index in
 33:                     if index < viewModel.contentItems.count {
 34:                         ContentItemView(content: viewModel.contentItems[index])
 35:                             .environmentObject(viewModel)
 36:                             .onTapGesture {
 37:                                 let placeIds = viewModel.contentItems[index].placeIds
 38:                                 if !placeIds.isEmpty {
 39:                                     selectedPlaceId = placeIds[0]
 40:                                 }
 41:                             }
 42:                     } else {
 43:                         Color.black
 44:                     }
 45:                 }
 46:                 .ignoresSafeArea()
 47:                 .zIndex(0)
 48:             }
 49: 
 50: 
 51:             HStack(alignment: .top) {
 52: 
 53:                 FloatingMenu(
 54:                     items: viewModel.unlockedNeighborhoods,
 55:                     itemTitle: { $0.name },
 56:                     selectedId: viewModel.selectedNeighborhood?.id,
 57:                     onSelect: { neighborhood in
 58:                         viewModel.selectedNeighborhood = neighborhood
 59:                         showingNeighborhoods = false
 60:                         Task {
 61:                             await viewModel.loadContent()
 62:                         }
 63:                     },
 64:                     alignment: .leading,
 65:                     isExpanded: $showingNeighborhoods,
 66:                     onExploreMore: {
 67:                         appState.shouldSwitchToDiscover = true
 68:                     }
 69:                 )
 70: 
 71:                 Spacer()
 72: 
 73: 
 74:                 FloatingMenu(
 75:                     items: viewModel.availableCategories,
 76:                     itemTitle: { $0.rawValue.capitalized },
 77:                     selectedId: viewModel.selectedCategory.rawValue,
 78:                     onSelect: { category in
 79:                         viewModel.categorySelected(category)
 80:                         showingCategories = false
 81:                     },
 82:                     alignment: .trailing,
 83:                     isExpanded: $showingCategories
 84:                 )
 85:             }
 86:             .padding(.top, 24)
 87:             .padding(.horizontal, 16)
 88:             .zIndex(2)
 89:         }
 90:         .sheet(item: Binding(
 91:             get: {
 92:                 selectedPlaceId.map { PlaceDetailPresentation(placeId: $0) }
 93:             },
 94:             set: { presentation in
 95:                 selectedPlaceId = presentation?.placeId
 96:             }
 97:         )) { presentation in
 98:             PlaceDetailView(placeId: presentation.placeId)
 99:                 .presentationDetents([.medium, .large])
100:                 .presentationDragIndicator(.visible)
101:                 .presentationBackgroundInteraction(.enabled)
102:         }
103:         .task {
104:             if !viewModel.hasLoadedNeighborhoods {
105:                 await viewModel.loadUnlockedNeighborhoods()
106:                 await viewModel.loadContent()
107:             } else if viewModel.contentItems.isEmpty {
108:                 await viewModel.loadContent()
109:             } else {
110:                 viewModel.videoManager.currentPlayer?.play()
111:             }
112:         }
113:     }
114: }
115: 
116: struct LoadingState: View {
117:     var body: some View {
118:         GeometryReader { geometry in
119:             VStack(spacing: 16) {
120:                 ProgressView()
121:                     .scaleEffect(1.5)
122:                     .tint(.white)
123: 
124:                 Text("Loading...")
125:                     .font(.custom("Baskerville", size: 18))
126:                     .foregroundColor(.white.opacity(0.8))
127:             }
128:             .frame(width: geometry.size.width, height: geometry.size.height)
129:         }
130:     }
131: }
132: 
133: struct EmptyNeighborhoodState: View {
134:     var body: some View {
135:         GeometryReader { geometry in
136:             ScrollView {
137:                 ZStack {
138: 
139:                     Image("nocontent")
140:                         .resizable()
141:                         .aspectRatio(contentMode: .fill)
142:                         .frame(width: geometry.size.width, height: geometry.size.height)
143:                         .clipped()
144:                         .ignoresSafeArea()
145: 
146: 
147:                     VStack(spacing: 24) {
148:                         VStack(spacing: 16) {
149: 
150:                             Text("Unlock Your First Neighborhood")
151:                                 .font(.custom("Baskerville-Bold", size: 28))
152:                                 .multilineTextAlignment(.center)
153: 
154:                             Text("Discover local landmarks to unlock neighborhood content and start exploring stories from your community")
155:                                 .font(.custom("Baskerville", size: 18))
156:                                 .foregroundColor(.secondary)
157:                                 .multilineTextAlignment(.center)
158: 
159:                             Image(systemName: "camera.viewfinder")
160:                                 .font(.system(size: 44))
161:                                 .foregroundColor(.white.opacity(0.8))
162:                                 .padding(.top, 8)
163:                         }
164:                         .padding(24)
165:                         .background(.ultraThinMaterial)
166:                         .cornerRadius(16)
167:                         .shadow(radius: 8)
168:                     }
169:                     .padding()
170:                 }
171:                 .frame(minHeight: geometry.size.height)
172:             }
173:             .ignoresSafeArea(edges: .top)
174:         }
175:         .ignoresSafeArea(edges: .top)
176:     }
177: }
178: 
179: struct CategoryPill: View {
180:     let title: String
181:     let isSelected: Bool
182: 
183:     var body: some View {
184:         Text(title)
185:             .padding(.horizontal, 16)
186:             .padding(.vertical, 8)
187:             .background(isSelected ? Color.white : Color.white.opacity(0.2))
188:             .foregroundColor(isSelected ? .black : .white)
189:             .cornerRadius(20)
190:     }
191: }
192: 
193: struct PlaceDetailPresentation: Identifiable {
194:     let id = UUID()
195:     let placeId: String
196: }
</file>

<file path="sightline/sightline/Views/ContentFeedView/ContentFeedViewModel.swift">
  1: import SwiftUI
  2: import FirebaseFirestore
  3: import FirebaseAuth
  4: import Combine
  5: 
  6: enum NavigationDestination: Hashable {
  7:     case placeDetail(placeId: String, initialContentId: String)
  8: }
  9: 
 10: @MainActor
 11: final class ContentFeedViewModel: ObservableObject {
 12:     @Published var unlockedNeighborhoods: [Neighborhood] = []
 13:     @Published var selectedNeighborhood: Neighborhood?
 14:     @Published var selectedCategory: FilterCategory = .restaurant
 15:     @Published var availableCategories: [FilterCategory] = []
 16:     @Published var contentItems: [Content] = []
 17: 
 18: 
 19:     @Published var currentIndex: Int = 0 {
 20:         didSet {
 21:             Task {
 22:                 await updateActiveVideo()
 23:             }
 24:         }
 25:     }
 26:     @Published var isLoading = false
 27:     @Published var places: [String: Place] = [:]
 28: 
 29:     @Published private(set) var hasLoadedNeighborhoods = false
 30: 
 31:     let videoManager = VideoPlayerManager()
 32:     private let services = ServiceContainer.shared
 33: 
 34: 
 35:     func updateActiveVideo() async {
 36:         guard !contentItems.isEmpty,
 37:               currentIndex >= 0,
 38:               currentIndex < contentItems.count
 39:         else { return }
 40: 
 41:         let urls = contentItems.map { $0.videoUrl }
 42:         videoManager.preloadVideos(for: urls, at: currentIndex)
 43: 
 44:         await videoManager.activatePlayerAsync(for: contentItems[currentIndex].videoUrl)
 45:     }
 46: 
 47:     func loadUnlockedNeighborhoods() async {
 48: 
 49:         DispatchQueue.main.async {
 50:             self.isLoading = true
 51:             self.hasLoadedNeighborhoods = false
 52:         }
 53: 
 54: 
 55:         if let data = UserDefaults.standard.data(forKey: "preloadedNeighborhoods"),
 56:            let neighborhoods = try? JSONDecoder().decode([Neighborhood].self, from: data) {
 57:             self.unlockedNeighborhoods = neighborhoods
 58:             if self.selectedNeighborhood == nil {
 59:                 self.selectedNeighborhood = neighborhoods.first
 60:             }
 61:             DispatchQueue.main.async {
 62:                 self.hasLoadedNeighborhoods = true
 63:                 self.isLoading = false
 64:             }
 65:             return
 66:         }
 67: 
 68: 
 69:         guard let userId = services.auth.userId else { return }
 70: 
 71:         do {
 72:             let neighborhoods = try await services.firestore.fetchUnlockedNeighborhoods(for: userId)
 73:             self.unlockedNeighborhoods = neighborhoods
 74:             if self.selectedNeighborhood == nil {
 75:                 self.selectedNeighborhood = neighborhoods.first
 76:             }
 77:             DispatchQueue.main.async {
 78:                 self.hasLoadedNeighborhoods = true
 79:                 self.isLoading = false
 80:             }
 81:         } catch {
 82:             print("Error loading neighborhoods: \(error)")
 83:             DispatchQueue.main.async {
 84:                 self.hasLoadedNeighborhoods = true
 85:                 self.isLoading = false
 86:             }
 87:         }
 88:     }
 89: 
 90:     private func loadAvailableCategories() async {
 91:         guard let neighborhood = selectedNeighborhood else { return }
 92: 
 93: 
 94:         if let firstNeighborhood = unlockedNeighborhoods.first,
 95:            neighborhood.id == firstNeighborhood.id,
 96:            let data = UserDefaults.standard.data(forKey: "preloadedCategories"),
 97:            let categories = try? JSONDecoder().decode([FilterCategory].self, from: data) {
 98:             self.availableCategories = categories
 99:             if !categories.contains(selectedCategory) && !categories.isEmpty {
100:                 selectedCategory = categories[0]
101:             }
102:             return
103:         }
104: 
105: 
106:         do {
107:             let categories = try await services.firestore.fetchAvailableCategories(
108:                 for: neighborhood.id!
109:             )
110:             self.availableCategories = categories
111: 
112:             if !categories.contains(selectedCategory) && !categories.isEmpty {
113:                 selectedCategory = categories[0]
114:                 await loadContent()
115:             }
116:         } catch {
117:             print("❌ Error loading available categories: \(error)")
118:         }
119:     }
120: 
121:     func loadContent() async {
122:         guard let neighborhood = selectedNeighborhood else {
123:             print("❌ No neighborhood selected")
124:             return
125:         }
126: 
127:         isLoading = true
128:         do {
129:             await loadAvailableCategories()
130: 
131:             print("🔄 Loading content for neighborhood: \(neighborhood.name), category: \(selectedCategory.rawValue)")
132: 
133:             let content = try await services.firestore.fetchContentByCategory(
134:                 category: selectedCategory,
135:                 neighborhoodId: neighborhood.id!
136:             )
137: 
138: 
139:             var placeMap: [String: Place] = [:]
140:             for item in content {
141:                 for placeId in item.placeIds {
142:                     do {
143:                         let place = try await services.firestore.fetchPlace(id: placeId)
144:                         placeMap[placeId] = place
145:                     } catch {
146:                         print("Error loading place \(placeId): \(error)")
147:                     }
148:                 }
149:             }
150: 
151:             self.contentItems = content
152:             self.places = placeMap
153:             print("✅ Loaded \(content.count) content items")
154: 
155: 
156:             if !content.isEmpty {
157:                 let urls = content.map { $0.videoUrl }
158:                 videoManager.preloadVideos(for: urls, at: 0)
159:                 await videoManager.activatePlayerAsync(for: content[0].videoUrl)
160:             }
161: 
162:             isLoading = false
163:         } catch {
164:             print("❌ Error loading content: \(error)")
165:             isLoading = false
166:         }
167:     }
168: 
169: 
170:     func categorySelected(_ category: FilterCategory) {
171:         selectedCategory = category
172:         self.currentIndex = 0
173:         Task {
174:             await loadContent()
175:         }
176:     }
177: }
</file>

<file path="sightline/sightline/Views/CameraView.swift">
  1: import SwiftUI
  2: import AVFoundation
  3: 
  4: class CameraController: NSObject, ObservableObject {
  5:     @Published var isAuthorized = false
  6:     @Published var error: String?
  7:     @Published var isCapturing = false
  8: 
  9:     var captureSession: AVCaptureSession?
 10:     private var videoOutput = AVCaptureVideoDataOutput()
 11:     private var frameCount = 0
 12:     private let maxFrames = 10
 13:     private var captureStartTime: Date?
 14:     private var lastCaptureTime: Date?
 15:     private var onFrameCaptured: ((UIImage) -> Void)?
 16: 
 17:     override init() {
 18:         super.init()
 19:         checkPermissions()
 20:     }
 21: 
 22:     func checkPermissions() {
 23:         switch AVCaptureDevice.authorizationStatus(for: .video) {
 24:         case .authorized:
 25:             self.isAuthorized = true
 26:             setupCamera()
 27:         case .notDetermined:
 28:             AVCaptureDevice.requestAccess(for: .video) { [weak self] granted in
 29:                 DispatchQueue.main.async {
 30:                     self?.isAuthorized = granted
 31:                     if granted {
 32:                         self?.setupCamera()
 33:                     }
 34:                 }
 35:             }
 36:         case .denied, .restricted:
 37:             self.isAuthorized = false
 38:             self.error = "Camera access is denied. Please enable it in Settings."
 39:         @unknown default:
 40:             self.isAuthorized = false
 41:             self.error = "Unknown camera authorization status"
 42:         }
 43:     }
 44: 
 45:     private func setupCamera() {
 46:         let session = AVCaptureSession()
 47:         session.sessionPreset = .medium
 48: 
 49:         guard let device = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back),
 50:               let input = try? AVCaptureDeviceInput(device: device) else {
 51:             error = "Failed to initialize camera"
 52:             return
 53:         }
 54: 
 55:         if session.canAddInput(input) {
 56:             session.addInput(input)
 57:         }
 58: 
 59:         videoOutput.setSampleBufferDelegate(self, queue: DispatchQueue(label: "camera.frame.processing"))
 60: 
 61:         if session.canAddOutput(videoOutput) {
 62:             session.addOutput(videoOutput)
 63:         }
 64: 
 65:         captureSession = session
 66:     }
 67: 
 68:     func startCapturing(onFrameCaptured: @escaping (UIImage) -> Void) {
 69:         self.onFrameCaptured = onFrameCaptured
 70:         self.frameCount = 0
 71:         self.lastCaptureTime = nil
 72:         self.captureStartTime = Date()
 73:         self.isCapturing = true
 74: 
 75:         DispatchQueue.global(qos: .userInitiated).async { [weak self] in
 76:             self?.captureSession?.startRunning()
 77:         }
 78:     }
 79: 
 80:     func stopCapturing() {
 81:         self.isCapturing = false
 82:         self.onFrameCaptured = nil
 83: 
 84:         DispatchQueue.global(qos: .userInitiated).async { [weak self] in
 85:             self?.captureSession?.stopRunning()
 86:         }
 87:     }
 88: }
 89: 
 90: extension CameraController: AVCaptureVideoDataOutputSampleBufferDelegate {
 91:     func captureOutput(_ output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection) {
 92:         guard isCapturing && frameCount < maxFrames else { return }
 93: 
 94:         let now = Date()
 95: 
 96:         if frameCount == 0 {
 97:             guard let startTime = captureStartTime, now.timeIntervalSince(startTime) >= 3.0 else {
 98:                 return
 99:             }
100:         } else {
101:             let requiredInterval: TimeInterval = frameCount < 5 ? 1.0 : 2.0
102:             guard let lastTime = lastCaptureTime, now.timeIntervalSince(lastTime) >= requiredInterval else {
103:                 return
104:             }
105:         }
106: 
107:         guard let imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer),
108:               let onFrameCaptured = onFrameCaptured else {
109:             return
110:         }
111: 
112:         let ciImage = CIImage(cvPixelBuffer: imageBuffer)
113:         let context = CIContext()
114:         guard let cgImage = context.createCGImage(ciImage, from: ciImage.extent) else { return }
115:         let image = UIImage(cgImage: cgImage)
116: 
117:         DispatchQueue.main.async {
118:             self.frameCount += 1
119:             self.lastCaptureTime = now
120:             onFrameCaptured(image)
121: 
122:             if self.frameCount >= self.maxFrames {
123:                 self.stopCapturing()
124:             }
125:         }
126:     }
127: }
128: 
129: struct CameraPreviewView: UIViewRepresentable {
130:     let session: AVCaptureSession
131: 
132:     func makeUIView(context: Context) -> UIView {
133:         let view = UIView(frame: UIScreen.main.bounds)
134:         let previewLayer = AVCaptureVideoPreviewLayer(session: session)
135:         previewLayer.frame = view.frame
136:         previewLayer.videoGravity = .resizeAspectFill
137:         view.layer.addSublayer(previewLayer)
138:         return view
139:     }
140: 
141:     func updateUIView(_ uiView: UIView, context: Context) {}
142: }
143: 
144: 
145: struct CameraView: View {
146:   @StateObject private var cameraController = CameraController()
147:   @Environment(\.dismiss) private var dismiss
148:   var onFrameCaptured: (UIImage) -> Void
149:   @Binding var shouldFlash: Bool
150: 
151:   @State private var flashOverlayOpacity: Double = 0.0
152: 
153:   var body: some View {
154:     GeometryReader { geometry in
155:       ZStack { if let session = cameraController.captureSession {
156:         CameraPreviewView(session: session)
157: 
158:         if cameraController.isCapturing {
159:           VStack {
160:             Spacer()
161:             Text("Scanning for landmarks...")
162:               .foregroundColor(.white)
163:               .padding()
164:               .background(Color.black.opacity(0.7))
165:               .cornerRadius(10)
166:             Spacer().frame(height: 160)
167:           }
168:         }
169: 
170:         if let error = cameraController.error {
171:           Text(error)
172:             .foregroundColor(.red)
173:             .padding()
174:             .background(Color.black.opacity(0.7))
175:             .cornerRadius(10)
176:         }
177: 
178: 
179:         Color.white
180:           .opacity(flashOverlayOpacity)
181:           .ignoresSafeArea()
182: 
183: 
184:       }
185:       }
186:       .ignoresSafeArea(.all, edges: .all)
187:       .onChange(of: shouldFlash) { newValue in
188:         if newValue {
189: 
190:           withAnimation(.easeIn(duration: 0.1)) {
191:             flashOverlayOpacity = 1.0
192:           }
193:           withAnimation(.easeOut(duration: 0.3).delay(0.1)) {
194:             flashOverlayOpacity = 0.0
195:           }
196: 
197:           DispatchQueue.main.asyncAfter(deadline: .now() + 0.4) {
198:             shouldFlash = false
199:           }
200:         }
201:       }
202:       .onAppear {
203:         cameraController.startCapturing { image in
204:           onFrameCaptured(image)
205:         }
206:       }
207:       .onDisappear {
208:         cameraController.stopCapturing()
209:       }
210:     }
211:   }
212: }
213: #if DEBUG
214: 
215: private struct MockCameraPreviewView: View {
216:     var body: some View {
217:         Color.gray
218:     }
219: }
220: 
221: struct CameraView_Previews: PreviewProvider {
222:     static var previews: some View {
223:         CameraView(
224:             onFrameCaptured: { _ in },
225:             shouldFlash: .constant(false)
226:         )
227:         .previewDisplayName("Camera View")
228: 
229: 
230:         CameraView(
231:             onFrameCaptured: { _ in },
232:             shouldFlash: .constant(true)
233:         )
234:         .previewDisplayName("With Flash")
235:     }
236: }
237: #endif
</file>

<file path="sightline/sightline/Views/ContentItemView.swift">
  1: import SwiftUI
  2: import AVKit
  3: import FirebaseStorage
  4: 
  5: @MainActor
  6: struct ContentItemView: View {
  7:     @EnvironmentObject var appState: AppState
  8:     @EnvironmentObject var feedViewModel: ContentFeedViewModel
  9:     let content: Content
 10:     @StateObject private var viewModel: ContentItemViewModel
 11:     @Environment(\.safeAreaInsets) private var safeAreaInsets
 12: 
 13:     init(content: Content) {
 14:         self.content = content
 15:         _viewModel = StateObject(wrappedValue: ContentItemViewModel(
 16:             content: content,
 17:             services: ServiceContainer.shared
 18:         ))
 19:     }
 20: 
 21:     var body: some View {
 22:         GeometryReader { geo in
 23:             ZStack {
 24:                 if let player = feedViewModel.videoManager.playerFor(url: content.videoUrl) {
 25:                     VideoPlayer(player: player)
 26:                         .edgesIgnoringSafeArea(.all)
 27:                         .frame(width: geo.size.width, height: geo.size.height + safeAreaInsets.top + safeAreaInsets.bottom)
 28:                         .offset(y: -safeAreaInsets.top)
 29:                 } else if feedViewModel.videoManager.error != nil {
 30:                     Color.black
 31:                     VStack {
 32:                         Image(systemName: "exclamationmark.triangle")
 33:                             .font(.largeTitle)
 34:                             .foregroundColor(.yellow)
 35:                         Text("Failed to load video")
 36:                             .foregroundColor(.white)
 37:                     }
 38:                 } else {
 39:                     Color.black
 40:                     ProgressView()
 41:                         .scaleEffect(1.5)
 42:                 }
 43: 
 44: 
 45:                 VStack {
 46:                     Spacer()
 47: 
 48: 
 49:                     VStack(spacing: 8) {
 50:                         HStack {
 51:                             VStack(alignment: .leading, spacing: 8) {
 52:                                 Text(content.caption)
 53:                                     .font(.headline)
 54:                                     .foregroundColor(.white)
 55:                                     .multilineTextAlignment(.leading)
 56: 
 57:                                 NavigationLink(value: AppState.NavigationDestination.placeDetail(placeId: content.placeIds[0], initialContentId: content.id)) {
 58:                                     Text(viewModel.placeName ?? "Loading place...")
 59:                                         .font(.subheadline)
 60:                                         .foregroundColor(.white)
 61:                                         .padding(.horizontal, 12)
 62:                                         .padding(.vertical, 6)
 63:                                         .background(.ultraThinMaterial)
 64:                                         .cornerRadius(16)
 65:                                 }
 66:                             }
 67:                             Spacer()
 68:                         }
 69:                         .padding(.horizontal)
 70:                         .padding(.bottom, 120)
 71:                     }
 72:                     .background(
 73:                         LinearGradient(
 74:                             gradient: Gradient(colors: [.clear, .black.opacity(0.3)]),
 75:                             startPoint: .top,
 76:                             endPoint: .bottom
 77:                         )
 78:                         .padding(.top, -100)
 79:                     )
 80:                 }
 81:             }
 82:         }
 83:         .onAppear {
 84:             Task {
 85:                 await viewModel.loadPlace()
 86:             }
 87:         }
 88:     }
 89: }
 90: 
 91: @MainActor
 92: final class ContentItemViewModel: ObservableObject {
 93:     @Published var placeName: String?
 94:     @Published var isLoadingPlace = true
 95:     private let content: Content
 96:     private let services: ServiceContainer
 97: 
 98:     init(content: Content, services: ServiceContainer) {
 99:         self.content = content
100:         self.services = services
101:     }
102: 
103:     func loadPlace() async {
104:         isLoadingPlace = true
105:         do {
106:             let place = try await services.firestore.fetchPlace(id: content.placeIds[0])
107:             await MainActor.run {
108:                 self.placeName = place.name
109:             }
110:         } catch {
111:             await handlePlaceLoadError(error)
112:         }
113:         isLoadingPlace = false
114:     }
115: 
116:     private func handlePlaceLoadError(_ error: Error) async {
117:         await MainActor.run {
118: 
119:             print("🔴 Critical place load error: \(error.localizedDescription)")
120:         }
121:     }
122: 
123:     func cleanup() {
124: 
125:     }
126: }
127: 
128: 
129: private extension EnvironmentValues {
130:     var safeAreaInsets: EdgeInsets {
131:         (UIApplication.shared.windows.first?.safeAreaInsets ?? .zero).insets
132:     }
133: }
134: 
135: private extension UIEdgeInsets {
136:     var insets: EdgeInsets {
137:         EdgeInsets(top: top, leading: left, bottom: bottom, trailing: right)
138:     }
139: }
</file>

<file path="sightline/sightline/Views/MainTabView.swift">
 1: import SwiftUI
 2: import FirebaseAuth
 3: 
 4: struct MainTabView: View {
 5:     @StateObject private var appState = AppState()
 6:     @State private var selectedTab = 0
 7:     @StateObject private var feedViewModel = ContentFeedViewModel()
 8:     private let services = ServiceContainer.shared
 9: 
10:     var body: some View {
11:         TabView(selection: $selectedTab) {
12: 
13:             LandmarkDetectionView()
14:                 .environmentObject(appState)
15:                 .tabItem {
16:                     Label("Discover", systemImage: "camera.viewfinder")
17:                 }
18:                 .tag(0)
19: 
20: 
21:             ContentFeedView()
22:                 .environmentObject(appState)
23:                 .environmentObject(feedViewModel)
24:                 .tabItem {
25:                     Label("Feed", systemImage: "play.square.stack")
26:                 }
27:                 .tag(1)
28: 
29: 
30:             ProfileView()
31:                 .environmentObject(appState)
32:                 .tabItem {
33:                     Label("Profile", systemImage: "person.circle")
34:                 }
35:                 .tag(2)
36:         }
37:         .tint(.white)
38:         .onAppear {
39: 
40:             let appearance = UITabBarAppearance()
41:             appearance.configureWithOpaqueBackground()
42:             appearance.backgroundColor = UIColor.black
43: 
44: 
45:             appearance.stackedLayoutAppearance.normal.iconColor = .gray
46:             appearance.stackedLayoutAppearance.normal.titleTextAttributes = [.foregroundColor: UIColor.gray]
47: 
48: 
49:             appearance.stackedLayoutAppearance.selected.iconColor = .white
50:             appearance.stackedLayoutAppearance.selected.titleTextAttributes = [.foregroundColor: UIColor.white]
51: 
52:             UITabBar.appearance().standardAppearance = appearance
53:             if #available(iOS 15.0, *) {
54:                 UITabBar.appearance().scrollEdgeAppearance = appearance
55:             }
56:         }
57:         .task {
58:             do {
59:                 try await services.auth.signInAnonymously()
60:             } catch {
61:                 print("Failed to sign in: \(error)")
62:             }
63:         }
64: 
65:         .onChange(of: appState.shouldSwitchToFeed) { oldValue, newValue in
66:             if newValue {
67:                 withAnimation {
68:                     selectedTab = 1
69:                 }
70:                 appState.shouldSwitchToFeed = false
71:             }
72:         }
73: 
74:         .onChange(of: selectedTab) { oldValue, newValue in
75:             if oldValue == 1 && newValue != 1 {
76: 
77:                 feedViewModel.videoManager.currentPlayer?.pause()
78:             }
79:         }
80: 
81:         .onChange(of: appState.shouldSwitchToProfile) { oldValue, newValue in
82:             if newValue {
83:                 withAnimation {
84:                     selectedTab = 2
85:                 }
86:                 appState.shouldSwitchToProfile = false
87:             }
88:         }
89:     }
90: }
</file>

<file path="sightline/sightline/Views/PlaceDetailView.swift">
  1: import SwiftUI
  2: import MapKit
  3: import FirebaseFirestore
  4: import FirebaseAuth
  5: import os
  6: 
  7: struct PlaceDetailView: View {
  8:     let placeId: String
  9:     @StateObject private var viewModel: PlaceDetailViewModel
 10:     @Environment(\.dismiss) private var dismiss
 11:     @EnvironmentObject private var appState: AppState
 12: 
 13: 
 14:     @State private var sheetHeight: CGFloat = UIScreen.main.bounds.height * 0.7
 15:     @State private var offset: CGFloat = 0
 16: 
 17:     @State private var region = MKCoordinateRegion(
 18:         center: CLLocationCoordinate2D(latitude: 30.0, longitude: -97.0),
 19:         span: MKCoordinateSpan(latitudeDelta: 0.05, longitudeDelta: 0.05)
 20:     )
 21: 
 22: 
 23:     @State private var showError = false
 24: 
 25:     private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "Sightline", category: "PlaceDetailView")
 26: 
 27:     init(placeId: String) {
 28:         self.placeId = placeId
 29:         _viewModel = StateObject(wrappedValue: PlaceDetailViewModel())
 30:     }
 31: 
 32:     func openDirections() {
 33:         guard let place = viewModel.place else { return }
 34: 
 35:         let coordinates = "\(place.coordinates.latitude),\(place.coordinates.longitude)"
 36:         let name = place.name.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? ""
 37:         let url = URL(string: "http:
 38: 
 39:         if let url = url, UIApplication.shared.canOpenURL(url) {
 40:             UIApplication.shared.open(url)
 41:         } else {
 42:             viewModel.errorMessage = "Unable to open Maps"
 43:         }
 44:     }
 45: 
 46:     var directionsButton: some View {
 47:         Button(action: openDirections) {
 48:             HStack {
 49:                 Image(systemName: "map.fill")
 50:                 Text("Get Directions")
 51:             }
 52:             .foregroundColor(.white)
 53:             .padding(.vertical, 12)
 54:             .padding(.horizontal, 24)
 55:             .background(Color.blue)
 56:             .cornerRadius(10)
 57:         }
 58:         .disabled(viewModel.place == nil)
 59:         .opacity(viewModel.place == nil ? 0.6 : 1.0)
 60:     }
 61: 
 62:     var savePlaceButton: some View {
 63:         Button(action: {
 64:             Task {
 65:                 await viewModel.savePlace()
 66: 
 67:                 appState.shouldSwitchToProfile = true
 68:                 dismiss()
 69:             }
 70:         }) {
 71:             HStack {
 72:                 Image(systemName: "heart.fill")
 73:                 Text("Save Place")
 74:             }
 75:             .foregroundColor(.white)
 76:             .padding(.vertical, 12)
 77:             .padding(.horizontal, 24)
 78:             .background(Color.pink)
 79:             .cornerRadius(10)
 80:         }
 81:         .disabled(viewModel.place == nil)
 82:         .opacity(viewModel.place == nil ? 0.6 : 1.0)
 83:     }
 84: 
 85:     var mapView: some View {
 86:         Group {
 87:             if let place = viewModel.place {
 88:                 Map(coordinateRegion: $region, annotationItems: [place]) { place in
 89:                     MapMarker(
 90:                         coordinate: CLLocationCoordinate2D(
 91:                             latitude: place.coordinates.latitude,
 92:                             longitude: place.coordinates.longitude
 93:                         ),
 94:                         tint: .red
 95:                     )
 96:                 }
 97:                 .onAppear {
 98: 
 99:                     let coordinate = CLLocationCoordinate2D(
100:                         latitude: place.coordinates.latitude,
101:                         longitude: place.coordinates.longitude
102:                     )
103:                     if CLLocationCoordinate2DIsValid(coordinate) {
104:                         region = MKCoordinateRegion(
105:                             center: coordinate,
106:                             span: MKCoordinateSpan(latitudeDelta: 0.01, longitudeDelta: 0.01)
107:                         )
108:                     } else {
109:                         logger.warning("Invalid coordinates for place: \(place.id)")
110:                     }
111:                 }
112:                 .frame(height: 200)
113:                 .cornerRadius(12)
114:                 .padding(.horizontal)
115:             } else {
116:                 ProgressView()
117:                     .frame(height: 200)
118:             }
119:         }
120:     }
121: 
122:     var headerView: some View {
123:         Text(viewModel.place?.name ?? "Loading...")
124:             .font(.title2)
125:             .fontWeight(.bold)
126:             .frame(maxWidth: .infinity)
127:             .padding(.top, 16)
128:             .padding(.bottom, 8)
129:     }
130: 
131:     var body: some View {
132:         GeometryReader { geometry in
133:             ScrollView {
134:                 VStack(spacing: 16) {
135:                     headerView
136: 
137:                     if let errorMessage = viewModel.errorMessage {
138:                         Text(errorMessage)
139:                             .foregroundColor(.red)
140:                             .padding(.horizontal)
141:                     }
142: 
143: 
144:                     Text(viewModel.place?.description ?? "No description available.")
145:                         .font(.body)
146:                         .padding(.horizontal)
147: 
148:                     mapView
149: 
150:                     directionsButton
151:                     savePlaceButton
152:                 }
153:             }
154:             .frame(maxWidth: geometry.size.width)
155:             .background(.ultraThinMaterial)
156:             .clipShape(RoundedRectangle(cornerRadius: 20, style: .continuous))
157:         }
158:         .presentationDetents([
159:             .height(400),
160:             .large
161:         ])
162:         .presentationDragIndicator(.visible)
163:         .presentationBackgroundInteraction(.enabled)
164:         .presentationBackground(.ultraThinMaterial)
165:         .onAppear {
166:             Task {
167:                 await viewModel.loadPlaceDetails(placeId: placeId)
168:             }
169:         }
170:     }
171: }
172: 
173: @MainActor
174: final class PlaceDetailViewModel: ObservableObject {
175:     @Published var place: Place?
176:     @Published var errorMessage: String?
177: 
178:     private let services = ServiceContainer.shared
179:     private let logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "Sightline", category: "PlaceDetailView")
180: 
181:     func loadPlaceDetails(placeId: String) async {
182:         do {
183:             let fetchedPlace = try await services.firestore.fetchPlace(id: placeId)
184:             await MainActor.run {
185:                 self.place = fetchedPlace
186:                 self.errorMessage = nil
187:             }
188:         } catch {
189:             logger.error("Error loading place details: \(error.localizedDescription)")
190:             await MainActor.run {
191:                 self.errorMessage = "Unable to load place details"
192:             }
193:         }
194:     }
195: 
196:     func savePlace() async {
197:         guard let place = self.place,
198:               let userId = Auth.auth().currentUser?.uid else { return }
199: 
200:         do {
201:             try await services.firestore.savePlaceForUser(userId: userId, placeId: place.id)
202:         } catch {
203:             self.errorMessage = "Error saving place: \(error.localizedDescription)"
204:         }
205:     }
206: }
</file>

<file path="sightline/sightline/Views/ProfileView.swift">
  1: import SwiftUI
  2: import FirebaseAuth
  3: 
  4: struct ProfileView: View {
  5:     @EnvironmentObject private var appState: AppState
  6:     @StateObject private var viewModel = ProfileViewModel()
  7: 
  8:     var body: some View {
  9:         ZStack {
 10:             if viewModel.isLoading {
 11:                 ProgressView()
 12:             } else if viewModel.isAnonymous {
 13:                 AuthView(viewModel: viewModel)
 14:             } else {
 15:                 UserProfileView(viewModel: viewModel)
 16:                     .navigationTitle("Profile")
 17:             }
 18:         }
 19:         .onAppear {
 20:             viewModel.checkAuthState()
 21:         }
 22:     }
 23: }
 24: 
 25: 
 26: struct AuthView: View {
 27:     @ObservedObject var viewModel: ProfileViewModel
 28:     @State private var isSignIn = false
 29:     @State private var email = ""
 30:     @State private var password = ""
 31:     @State private var confirmPassword = ""
 32: 
 33:     var body: some View {
 34:         GeometryReader { geometry in
 35:             ScrollView {
 36:                 ZStack {
 37:                     // Background Image
 38:                     Image("profile-bg")
 39:                         .resizable()
 40:                         .aspectRatio(contentMode: .fill)
 41:                         .frame(width: geometry.size.width, height: geometry.size.height)
 42:                         .clipped()
 43:                         .ignoresSafeArea()
 44: 
 45: 
 46:                     VStack(spacing: 24) {
 47:                         VStack(spacing: 24) {
 48: 
 49:                             VStack(spacing: 8) {
 50:                                 Text(isSignIn ? "Sign In" : "Create an Account")
 51:                                     .font(.custom("Baskerville-Bold", size: 28))
 52: 
 53:                                 if viewModel.hasPendingSavedPlaces {
 54:                                     Text("Sign up to save your places!")
 55:                                         .font(.custom("Baskerville", size: 18))
 56:                                         .foregroundColor(.yellow)
 57:                                         .multilineTextAlignment(.center)
 58:                                         .padding(.horizontal)
 59:                                 } else {
 60:                                     Text(isSignIn ? "Welcome Back" : "Save Places, Post Content, and More")
 61:                                         .font(.custom("Baskerville", size: 18))
 62:                                         .foregroundColor(.secondary)
 63:                                         .multilineTextAlignment(.center)
 64:                                 }
 65:                             }
 66: 
 67: 
 68:                             VStack(spacing: 16) {
 69:                                 TextField("Email", text: $email)
 70:                                     .textContentType(.emailAddress)
 71:                                     .keyboardType(.emailAddress)
 72:                                     .autocapitalization(.none)
 73:                                     .foregroundColor(.black)
 74:                                     .customTextField()
 75: 
 76:                                 SecureField("Password", text: $password)
 77:                                     .textContentType(isSignIn ? .password : .newPassword)
 78:                                     .foregroundColor(.black)
 79:                                     .customTextField()
 80: 
 81: 
 82:                                 if !isSignIn {
 83:                                     SecureField("Confirm Password", text: $confirmPassword)
 84:                                         .textContentType(.newPassword)
 85:                                         .customTextField()
 86:                                 }
 87:                             }
 88: 
 89:                             if let error = viewModel.errorMessage {
 90:                                 Text(error)
 91:                                     .foregroundColor(.red)
 92:                                     .font(.caption)
 93:                                     .padding(.horizontal)
 94:                             }
 95: 
 96:                             Button(action: {
 97:                                 Task {
 98:                                     if isSignIn {
 99:                                         await viewModel.signIn(email: email, password: password)
100:                                     } else {
101:                                         await viewModel.signUp(email: email, password: password, confirmPassword: confirmPassword)
102:                                     }
103:                                 }
104:                             }) {
105:                                 if viewModel.isProcessing {
106:                                     ProgressView()
107:                                         .progressViewStyle(CircularProgressViewStyle(tint: .white))
108:                                 } else {
109:                                     Text(isSignIn ? "Sign In" : "Create Account")
110:                                         .frame(maxWidth: .infinity)
111:                                         .foregroundColor(.white)
112:                                 }
113:                             }
114:                             .padding()
115:                             .background(Color.yellow)
116:                             .cornerRadius(10)
117:                             .disabled(viewModel.isProcessing)
118: 
119: 
120:                             Button(action: {
121:                                 withAnimation {
122:                                     isSignIn.toggle()
123:                                     viewModel.errorMessage = nil
124:                                 }
125:                             }) {
126:                                 Text(isSignIn ? "Need an account? Sign Up" : "Already have an account? Sign In")
127:                                     .foregroundColor(.white)
128:                                     .underline()
129:                             }
130:                         }
131:                         .padding(24)
132:                         .background(.ultraThinMaterial)
133:                         .cornerRadius(16)
134:                         .shadow(radius: 8)
135: 
136: 
137:                           Button(action: {
138:                               Task {
139:                                   await viewModel.resetAccount()
140:                               }
141:                           }) {
142:                               Text("Reset Account")
143:                                   .frame(maxWidth: .infinity)
144:                                   .padding()
145:                                   .background(Color.red.opacity(0.9))
146:                                   .foregroundColor(.white)
147:                                   .cornerRadius(10)
148:                           }
149:                       }
150: 
151:                     .padding()
152:                 }
153:                 .frame(minHeight: geometry.size.height)
154:             }
155:             .scrollDismissesKeyboard(.interactively)
156:             .ignoresSafeArea(edges: .top)
157:         }
158:         .ignoresSafeArea(edges: .top)
159:     }
160: }
161: 
162: 
163: struct UserProfileView: View {
164:     @ObservedObject var viewModel: ProfileViewModel
165: 
166:     var body: some View {
167:         GeometryReader { geometry in
168:             ScrollView {
169:                 ZStack {
170: 
171:                     Image("profile-bg")
172:                         .resizable()
173:                         .aspectRatio(contentMode: .fill)
174:                         .frame(width: geometry.size.width, height: geometry.size.height)
175:                         .clipped()
176:                         .ignoresSafeArea()
177: 
178: 
179:                     VStack(spacing: 24) {
180: 
181:                         VStack(spacing: 20) {
182: 
183:                             VStack(spacing: 12) {
184:                                 Image(systemName: "person.circle.fill")
185:                                     .resizable()
186:                                     .frame(width: 80, height: 80)
187:                                     .foregroundColor(.white)
188: 
189:                                 Text(viewModel.userEmail ?? "")
190:                                     .font(.headline)
191:                             }
192: 
193:                             Divider()
194:                                 .background(.white.opacity(0.5))
195: 
196:                             // Stats or other info could go here
197:                             HStack(spacing: 32) {
198:                                 StatView(title: "Places", value: "0")
199:                                 StatView(title: "Posts", value: "0")
200:                                 StatView(title: "Likes", value: "0")
201:                             }
202:                         }
203:                         .padding(24)
204:                         .background(.ultraThinMaterial)
205:                         .cornerRadius(16)
206:                         .shadow(radius: 8)
207: 
208: 
209:                         VStack(spacing: 16) {
210: 
211:                             if !viewModel.savedPlaces.isEmpty {
212:                                 VStack(alignment: .leading, spacing: 10) {
213:                                     Text("Saved Places")
214:                                         .font(.title3)
215:                                         .fontWeight(.bold)
216: 
217:                                     ForEach(viewModel.savedPlaces, id: \.id) { place in
218:                                         VStack(alignment: .leading) {
219:                                             Text(place.name)
220:                                                 .font(.subheadline)
221:                                                 .fontWeight(.semibold)
222:                                             Text(place.address)
223:                                                 .font(.caption)
224:                                                 .foregroundColor(.secondary)
225:                                         }
226:                                         .padding(.vertical, 8)
227:                                         Divider()
228:                                     }
229:                                 }
230:                                 .padding()
231:                                 .background(.ultraThinMaterial)
232:                                 .cornerRadius(12)
233:                             }
234: 
235:                             Button(action: {
236:                                 Task {
237:                                     await viewModel.signOut()
238:                                 }
239:                             }) {
240:                                 Text("Sign Out")
241:                                     .frame(maxWidth: .infinity)
242:                                     .padding()
243:                                     .background(Color.red.opacity(0.8))
244:                                     .foregroundColor(.white)
245:                                     .cornerRadius(10)
246:                             }
247: 
248:                         }
249:                         .padding(24)
250:                         .background(.ultraThinMaterial)
251:                         .cornerRadius(16)
252:                         .shadow(radius: 8)
253: 
254:                     }
255:                     .padding()
256:                 }
257:                 .frame(minHeight: geometry.size.height)
258:             }
259:             .scrollDismissesKeyboard(.interactively)
260:             .ignoresSafeArea(edges: .top)
261:         }
262:         .ignoresSafeArea(edges: .top)
263:         .onAppear {
264:             Task {
265:                 await viewModel.loadSavedPlaces()
266:             }
267:         }
268:     }
269: }
270: 
271: 
272: struct StatView: View {
273:     let title: String
274:     let value: String
275: 
276:     var body: some View {
277:         VStack(spacing: 4) {
278:             Text(value)
279:                 .font(.headline)
280:             Text(title)
281:                 .font(.caption)
282:                 .foregroundColor(.secondary)
283:         }
284:     }
285: }
286: 
287: @MainActor
288: class ProfileViewModel: ObservableObject {
289:     @Published var isLoading = true
290:     @Published var isAnonymous = true
291:     @Published var isProcessing = false
292:     @Published var errorMessage: String?
293:     @Published var userEmail: String?
294: 
295: 
296:     @Published var savedPlaces: [Place] = []
297: 
298:     @Published var hasPendingSavedPlaces = false
299: 
300:     private let auth = ServiceContainer.shared.auth
301:     private let firestoreService = ServiceContainer.shared.firestore
302: 
303:     func checkAuthState() {
304:         if let user = Auth.auth().currentUser {
305:             isAnonymous = user.isAnonymous
306:             userEmail = user.email
307: 
308: 
309:             if user.isAnonymous {
310:                 Task {
311:                     await checkPendingSavedPlaces()
312:                 }
313:             }
314:         }
315:         isLoading = false
316:     }
317: 
318:     private func checkPendingSavedPlaces() async {
319:         guard let userId = Auth.auth().currentUser?.uid else { return }
320:         do {
321:             let placeIds = try await firestoreService.fetchSavedPlaceIds(for: userId)
322:             await MainActor.run {
323:                 self.hasPendingSavedPlaces = !placeIds.isEmpty
324:             }
325:         } catch {
326:             print("Error checking pending saved places: \(error)")
327:         }
328:     }
329: 
330:     func signUp(email: String, password: String, confirmPassword: String) async {
331:         guard !isProcessing else { return }
332:         guard !email.isEmpty else {
333:             errorMessage = "Please enter an email"
334:             return
335:         }
336:         guard password == confirmPassword else {
337:             errorMessage = "Passwords don't match"
338:             return
339:         }
340:         guard password.count >= 6 else {
341:             errorMessage = "Password must be at least 6 characters"
342:             return
343:         }
344: 
345:         isProcessing = true
346:         errorMessage = nil
347: 
348:         do {
349: 
350:             if let user = Auth.auth().currentUser {
351:                 let credential = EmailAuthProvider.credential(withEmail: email, password: password)
352:                 try await user.link(with: credential)
353:                 isAnonymous = false
354:                 userEmail = email
355:             }
356:         } catch {
357:             errorMessage = error.localizedDescription
358:         }
359: 
360:         isProcessing = false
361:     }
362: 
363:     func signOut() async {
364:         do {
365:             try await auth.signOut()
366: 
367: 
368:             isAnonymous = true
369:             userEmail = nil
370:             savedPlaces.removeAll()
371:         } catch {
372:             errorMessage = "Failed to sign out"
373:         }
374:     }
375: 
376:     func signIn(email: String, password: String) async {
377:         guard !isProcessing else { return }
378:         guard !email.isEmpty else {
379:             errorMessage = "Please enter an email"
380:             return
381:         }
382:         guard !password.isEmpty else {
383:             errorMessage = "Please enter a password"
384:             return
385:         }
386: 
387:         isProcessing = true
388:         errorMessage = nil
389: 
390:         do {
391:             let result = try await Auth.auth().signIn(withEmail: email, password: password)
392:             isAnonymous = false
393:             userEmail = result.user.email
394:         } catch {
395:             errorMessage = error.localizedDescription
396:         }
397: 
398:         isProcessing = false
399:     }
400: 
401:     func resetAccount() async {
402:         print("🔄 Starting account reset...")
403:         do {
404:             print("📤 Attempting to sign out current user...")
405:             try await auth.signOut()
406:             print("✅ Sign out successful")
407: 
408:             print("🗑️ Clearing UserDefaults...")
409:             UserDefaults.standard.removePersistentDomain(forName: Bundle.main.bundleIdentifier!)
410:             print("✅ UserDefaults cleared")
411: 
412: 
413:             print("🔄 Resetting view model state...")
414:             isAnonymous = true
415:             userEmail = nil
416:             errorMessage = nil
417:             savedPlaces.removeAll()
418:             print("✅ View model state reset")
419: 
420:             print("⏳ Waiting for Firebase to auto-create anonymous user...")
421:             try await Task.sleep(nanoseconds: 1_000_000_000)
422: 
423:             if let currentUser = Auth.auth().currentUser {
424:                 print("✅ New user state: anonymous=\(currentUser.isAnonymous), email=\(currentUser.email ?? "")")
425:             } else {
426:                 print("⚠️ No current user after reset")
427:             }
428:         } catch {
429:             print("❌ Reset failed with error: \(error.localizedDescription)")
430:             errorMessage = "Failed to reset account: \(error.localizedDescription)"
431:         }
432:     }
433: 
434: 
435:     func loadSavedPlaces() async {
436:         guard let userId = Auth.auth().currentUser?.uid, !isAnonymous else { return }
437:         do {
438:             let placeIds = try await firestoreService.fetchSavedPlaceIds(for: userId)
439:             var fetched: [Place] = []
440:             for pid in placeIds {
441:                 do {
442:                     let place = try await firestoreService.fetchPlace(id: pid)
443:                     fetched.append(place)
444:                 } catch {
445:                     print("Failed to fetch place (\(pid)): \(error)")
446:                 }
447:             }
448: 
449:             await MainActor.run {
450:                 self.savedPlaces = fetched
451:             }
452:         } catch {
453:             print("Error fetching saved places: \(error)")
454:         }
455:     }
456: }
457: 
458: struct ProfileView_Previews: PreviewProvider {
459:     static var previews: some View {
460:         ProfileView()
461:             .environmentObject(AppState())
462:     }
463: }
464: 
465: 
466: extension View {
467: 
468:     func customTextField() -> some View {
469:         self
470:             .textFieldStyle(.plain)
471:             .padding(12)
472:             .background(Color.white)
473:             .accentColor(Color.yellow)
474:             .tint(Color.black)
475:             .cornerRadius(8)
476:     }
477: }
</file>

<file path="sightline/sightline/Views/SplashView.swift">
  1: import SwiftUI
  2: 
  3: struct SplashView: View {
  4:     @State private var progress: CGFloat = 0
  5:     @State private var opacity: Double = 1
  6:     let onFinished: () -> Void
  7: 
  8:     var body: some View {
  9:         ZStack {
 10:             Color.black.edgesIgnoringSafeArea(.all)
 11: 
 12: 
 13:             BorderAnimation(progress: progress)
 14:                 .stroke(Color.blue, lineWidth: 10)
 15:                 .edgesIgnoringSafeArea(.all)
 16:                 .mask(
 17:                     RoundedRectangle(cornerRadius: UIScreen.main.displayCornerRadius)
 18:                         .edgesIgnoringSafeArea(.all)
 19:                 )
 20: 
 21:             VStack(spacing: 24) {
 22: 
 23: 
 24:                 Image("Icon-1024")
 25:                     .resizable()
 26:                     .frame(width: 80, height: 80)
 27:                     .cornerRadius(16)
 28:                     .shadow(color: .blue.opacity(0.3), radius: 10)
 29: 
 30:                 VStack(spacing: 12) {
 31:                     Text("SightLine")
 32:                         .font(.custom("Baskerville", size: 24))
 33:                         .fontWeight(.medium)
 34:                         .foregroundColor(.white)
 35:                 }
 36:             }
 37:         }
 38:         .opacity(opacity)
 39:         .onAppear {
 40:             withAnimation(.linear(duration: 2).repeatForever(autoreverses: false)) {
 41:                 progress = 1.0
 42:             }
 43: 
 44:             DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
 45:                 withAnimation(.easeOut(duration: 0.5)) {
 46:                     opacity = 0
 47:                 }
 48:                 DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
 49:                     onFinished()
 50:                 }
 51:             }
 52:         }
 53:     }
 54: }
 55: 
 56: extension UIScreen {
 57:     var displayCornerRadius: CGFloat {
 58:         let key = "_displayCornerRadius"
 59:         if let val = self.value(forKey: key) as? CGFloat {
 60:             return val
 61:         }
 62:         return 39
 63:     }
 64: }
 65: 
 66: struct BorderAnimation: Shape {
 67:     var progress: CGFloat
 68: 
 69:     var animatableData: CGFloat {
 70:         get { progress }
 71:         set { progress = newValue }
 72:     }
 73: 
 74:     func path(in rect: CGRect) -> Path {
 75:         let cornerRadius = UIScreen.main.displayCornerRadius
 76: 
 77: 
 78:         let roundedRect = Path { path in
 79:             path.move(to: CGPoint(x: rect.minX + cornerRadius, y: rect.minY))
 80: 
 81: 
 82:             path.addLine(to: CGPoint(x: rect.maxX - cornerRadius, y: rect.minY))
 83:             path.addArc(
 84:                 center: CGPoint(x: rect.maxX - cornerRadius, y: rect.minY + cornerRadius),
 85:                 radius: cornerRadius,
 86:                 startAngle: Angle(degrees: -90),
 87:                 endAngle: Angle(degrees: 0),
 88:                 clockwise: false
 89:             )
 90: 
 91: 
 92:             path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY - cornerRadius))
 93:             path.addArc(
 94:                 center: CGPoint(x: rect.maxX - cornerRadius, y: rect.maxY - cornerRadius),
 95:                 radius: cornerRadius,
 96:                 startAngle: Angle(degrees: 0),
 97:                 endAngle: Angle(degrees: 90),
 98:                 clockwise: false
 99:             )
100: 
101: 
102:             path.addLine(to: CGPoint(x: rect.minX + cornerRadius, y: rect.maxY))
103:             path.addArc(
104:                 center: CGPoint(x: rect.minX + cornerRadius, y: rect.maxY - cornerRadius),
105:                 radius: cornerRadius,
106:                 startAngle: Angle(degrees: 90),
107:                 endAngle: Angle(degrees: 180),
108:                 clockwise: false
109:             )
110: 
111: 
112:             path.addLine(to: CGPoint(x: rect.minX, y: rect.minY + cornerRadius))
113:             path.addArc(
114:                 center: CGPoint(x: rect.minX + cornerRadius, y: rect.minY + cornerRadius),
115:                 radius: cornerRadius,
116:                 startAngle: Angle(degrees: 180),
117:                 endAngle: Angle(degrees: 270),
118:                 clockwise: false
119:             )
120:         }
121: 
122: 
123:         return roundedRect.trimmedPath(from: 0, to: progress)
124:     }
125: }
126: 
127: 
128: struct SplashView_Previews: PreviewProvider {
129:     static var previews: some View {
130:         SplashView {
131:             print("Splash finished")
132:         }
133:         .previewDisplayName("Splash Screen")
134:     }
135: }
</file>

<file path="sightline/sightline/Views/VerticalFeedView.swift">
  1: import SwiftUI
  2: import UIKit
  3: 
  4: struct VerticalFeedView<Content: View>: UIViewControllerRepresentable {
  5:     let content: (Int) -> Content
  6:     @Binding var currentIndex: Int
  7:     let itemCount: Int
  8:     let onIndexChanged: (Int) -> Void
  9: 
 10:     init(currentIndex: Binding<Int>,
 11:          itemCount: Int,
 12:          onIndexChanged: @escaping (Int) -> Void,
 13:          @ViewBuilder content: @escaping (Int) -> Content) {
 14:         self.content = content
 15:         self._currentIndex = currentIndex
 16:         self.itemCount = itemCount
 17:         self.onIndexChanged = onIndexChanged
 18:     }
 19: 
 20:     func makeCoordinator() -> Coordinator {
 21:         Coordinator(self)
 22:     }
 23: 
 24:     func makeUIViewController(context: Context) -> UIPageViewController {
 25:         let controller = UIPageViewController(
 26:             transitionStyle: .scroll,
 27:             navigationOrientation: .vertical,
 28:             options: [.interPageSpacing: 0]
 29:         )
 30:         controller.dataSource = context.coordinator
 31:         controller.delegate = context.coordinator
 32:         controller.view.backgroundColor = .black
 33: 
 34: 
 35:         controller.view.gestureRecognizers?.forEach { gesture in
 36:             (gesture as? UIScreenEdgePanGestureRecognizer)?.isEnabled = false
 37:         }
 38: 
 39: 
 40:         let hostingController = context.coordinator.hostingController(for: currentIndex)
 41:         controller.setViewControllers([hostingController], direction: .forward, animated: false)
 42: 
 43:         return controller
 44:     }
 45: 
 46:     func updateUIViewController(_ uiViewController: UIPageViewController, context: Context) {
 47: 
 48:         if context.coordinator.currentIndex != currentIndex {
 49:             let newVC = context.coordinator.hostingController(for: currentIndex)
 50:             let direction: UIPageViewController.NavigationDirection =
 51:                 context.coordinator.currentIndex > currentIndex ? .reverse : .forward
 52: 
 53: 
 54:             let shouldAnimate = abs(context.coordinator.currentIndex - currentIndex) <= 1
 55:             uiViewController.setViewControllers([newVC], direction: direction, animated: shouldAnimate)
 56:             context.coordinator.currentIndex = currentIndex
 57:         }
 58:     }
 59: 
 60:     class Coordinator: NSObject, UIPageViewControllerDataSource, UIPageViewControllerDelegate {
 61:         var parent: VerticalFeedView
 62:         var currentIndex: Int
 63:         var hostingControllers: [Int: UIHostingController<AnyView>] = [:]
 64: 
 65:         init(_ verticalFeedView: VerticalFeedView) {
 66:             self.parent = verticalFeedView
 67:             self.currentIndex = verticalFeedView.currentIndex
 68:         }
 69: 
 70:         func hostingController(for index: Int) -> UIHostingController<AnyView> {
 71:             if let existingController = hostingControllers[index] {
 72:                 return existingController
 73:             }
 74: 
 75:             guard index >= 0 && index < parent.itemCount else {
 76: 
 77:                 let fallbackView = AnyView(Color.black)
 78:                 let fallbackController = UIHostingController(rootView: fallbackView)
 79:                 fallbackController.view.backgroundColor = .clear
 80:                 return fallbackController
 81:             }
 82: 
 83:             let view = AnyView(
 84:                 parent.content(index)
 85:                     .frame(maxWidth: .infinity, maxHeight: .infinity)
 86:                     .background(Color.black)
 87:             )
 88: 
 89:             let hostingController = UIHostingController(rootView: view)
 90:             hostingController.view.backgroundColor = .clear
 91:             hostingControllers[index] = hostingController
 92: 
 93:             cleanupDistantControllers(from: index)
 94: 
 95:             return hostingController
 96:         }
 97: 
 98:         private func cleanupDistantControllers(from currentIndex: Int) {
 99:             let keepRange = (currentIndex - 2)...(currentIndex + 2)
100:             hostingControllers = hostingControllers.filter { keepRange.contains($0.key) }
101:         }
102: 
103: 
104: 
105:         func pageViewController(_ pageViewController: UIPageViewController, viewControllerBefore viewController: UIViewController) -> UIViewController? {
106:             let index = currentIndex - 1
107:             guard index >= 0 else { return nil }
108:             return hostingController(for: index)
109:         }
110: 
111:         func pageViewController(_ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController) -> UIViewController? {
112:             let index = currentIndex + 1
113:             guard index < parent.itemCount else { return nil }
114:             return hostingController(for: index)
115:         }
116: 
117: 
118: 
119:         func pageViewController(_ pageViewController: UIPageViewController,
120:                               didFinishAnimating finished: Bool,
121:                               previousViewControllers: [UIViewController],
122:                               transitionCompleted completed: Bool) {
123:             guard completed,
124:                   let visibleViewController = pageViewController.viewControllers?.first,
125:                   let index = hostingControllers.first(where: { $0.value == visibleViewController })?.key
126:             else { return }
127: 
128:             currentIndex = index
129:             parent.onIndexChanged(index)
130:         }
131:     }
132: }
</file>

<file path="sightline/sightline/DebugGalleryView.swift">
 1: import SwiftUI
 2: 
 3: struct DebugGalleryView: View {
 4:     let imageNames: [String]
 5:     @StateObject private var viewModel: LandmarkDetectionViewModel
 6: 
 7:     init(imageNames: [String], appState: AppState) {
 8:         self.imageNames = imageNames
 9:         self._viewModel = StateObject(wrappedValue: LandmarkDetectionViewModel(appState: appState))
10:     }
11: 
12:     private let columns = [
13:         GridItem(.flexible()),
14:         GridItem(.flexible()),
15:         GridItem(.flexible())
16:     ]
17: 
18:     var body: some View {
19:         NavigationView {
20:             ScrollView {
21:                 LazyVGrid(columns: columns, spacing: 16) {
22:                     ForEach(imageNames, id: \.self) { imageName in
23:                         if let uiImage = UIImage(named: imageName) {
24:                             Image(uiImage: uiImage)
25:                                 .resizable()
26:                                 .scaledToFill()
27:                                 .frame(width: 100, height: 100)
28:                                 .clipped()
29:                                 .cornerRadius(8)
30:                                 .overlay(
31:                                     viewModel.isLoading ?
32:                                     ProgressView()
33:                                         .background(Color.black.opacity(0.3))
34:                                     : nil
35:                                 )
36:                                 .onTapGesture {
37:                                     Task {
38:                                         await viewModel.detectLandmark(for: uiImage)
39:                                     }
40:                                 }
41:                         } else {
42:                             RoundedRectangle(cornerRadius: 8)
43:                                 .fill(Color.gray)
44:                                 .frame(width: 100, height: 100)
45:                                 .overlay(Text("No Image")
46:                                     .foregroundColor(.white)
47:                                     .font(.caption)
48:                                 )
49:                         }
50:                     }
51:                 }
52:                 .padding()
53:             }
54:             .navigationTitle("Debug Landmark Detection")
55:             .navigationBarTitleDisplayMode(.inline)
56: 
57:             if let landmark = viewModel.detectedLandmark {
58:                 LandmarkDetailView(landmark: landmark)
59:             }
60:         }
61:     }
62: }
63: 
64: struct DebugGalleryView_Previews: PreviewProvider {
65:     static var previews: some View {
66:         DebugGalleryView(
67:             imageNames: ["utcapitol1", "utcapitol2", "ladybirdlake1"],
68:             appState: AppState()
69:         )
70:     }
71: }
</file>

<file path="sightline/sightline/LandmarkDetection.swift">
  1: import SwiftUI
  2: import FirebaseAuth
  3: import FirebaseFirestore
  4: import FirebaseFunctions
  5: import UIKit
  6: 
  7: 
  8: struct LandmarkInfo: Identifiable {
  9:     let id = UUID()
 10:     let name: String
 11:     let description: String?
 12:     let detailedDescription: String?
 13:     let websiteUrl: String?
 14:     let imageUrl: String?
 15:     let latitude: Double?
 16:     let longitude: Double?
 17:     let neighborhood: Neighborhood?
 18: 
 19:     init(name: String, knowledgeGraphData: [String: Any]?, locationData: [[String: Any]]?, neighborhoodData: [String: Any]?) {
 20:         self.name = name
 21:         self.description = knowledgeGraphData?["description"] as? String
 22:         self.detailedDescription = (knowledgeGraphData?["detailedDescription"] as? [String: Any])?["articleBody"] as? String
 23:         self.websiteUrl = (knowledgeGraphData?["url"] as? String)
 24:         self.imageUrl = (knowledgeGraphData?["image"] as? [String: Any])?["contentUrl"] as? String
 25: 
 26:         if let firstLocation = (locationData?.first),
 27:            let latLng = firstLocation["latLng"] as? [String: Any] {
 28:             self.latitude = latLng["latitude"] as? Double
 29:             self.longitude = latLng["longitude"] as? Double
 30:         } else {
 31:             self.latitude = nil
 32:             self.longitude = nil
 33:         }
 34: 
 35:         if let neighborhoodData = neighborhoodData {
 36: 
 37:             let id = neighborhoodData["place_id"] as? String ?? ""
 38:             let name = neighborhoodData["name"] as? String ?? ""
 39:             let description = neighborhoodData["description"] as? String ?? ""
 40:             let imageUrl = neighborhoodData["image_url"] as? String ?? ""
 41:             let boundsData = neighborhoodData["bounds"] as? [String: Any] ?? [:]
 42: 
 43:             let neData = boundsData["northeast"] as? [String: Any] ?? [:]
 44:             let swData = boundsData["southwest"] as? [String: Any] ?? [:]
 45: 
 46:             let bounds = Neighborhood.GeoBounds(
 47:                 northeast: Neighborhood.GeoBounds.Point(
 48:                     lat: neData["lat"] as? Double ?? 0,
 49:                     lng: neData["lng"] as? Double ?? 0
 50:                 ),
 51:                 southwest: Neighborhood.GeoBounds.Point(
 52:                     lat: swData["lat"] as? Double ?? 0,
 53:                     lng: swData["lng"] as? Double ?? 0
 54:                 )
 55:             )
 56: 
 57:             self.neighborhood = Neighborhood(
 58:                 id: id,
 59:                 name: name,
 60:                 description: description,
 61:                 imageUrl: imageUrl,
 62:                 bounds: bounds,
 63:                 landmarks: nil
 64:             )
 65:         } else {
 66:             self.neighborhood = nil
 67:         }
 68:     }
 69: }
 70: 
 71: class LandmarkDetectionViewModel: ObservableObject {
 72:     @Published var selectedImage: UIImage?
 73:     @Published var detectionResult: String = ""
 74:     @Published var detectedLandmark: LandmarkInfo?
 75:     @Published var unlockStatus: String = ""
 76:     @Published var isLoading = false  // Add loading state
 77: 
 78:     let imageNames = ["utcapitol1", "utcapitol2", "ladybirdlake1"]
 79:     private let services = ServiceContainer.shared
 80:     private lazy var functions = Functions.functions()
 81:     private var appState: AppState
 82: 
 83:     init(appState: AppState) {
 84:         self.appState = appState
 85:     }
 86: 
 87:     func detectLandmark(for image: UIImage) async {
 88:         await MainActor.run {
 89:             isLoading = true
 90:             detectionResult = ""
 91:             detectedLandmark = nil
 92:         }
 93: 
 94:         guard let imageData = image.jpegData(compressionQuality: 0.8) else {
 95:             await MainActor.run {
 96:                 detectionResult = "Image conversion failed."
 97:                 isLoading = false
 98:             }
 99:             return
100:         }
101: 
102:         let base64String = imageData.base64EncodedString()
103:         let requestData: [String: Any] = [
104:             "image": ["content": base64String],
105:             "features": [
106:                 ["maxResults": 1, "type": "LANDMARK_DETECTION"]
107:             ]
108:         ]
109: 
110:         do {
111:             let result = try await functions.httpsCallable("annotateImage").call(requestData)
112:             if let dict = result.data as? [String: Any],
113:                let landmarkData = dict["landmark"] as? [String: Any] {
114: 
115:                 let landmarkName = landmarkData["name"] as? String ?? "Unknown Landmark"
116:                 let neighborhoodData = landmarkData["neighborhood"] as? [String: Any]
117: 
118:                 let landmark = LandmarkInfo(
119:                     name: landmarkName,
120:                     knowledgeGraphData: nil,
121:                     locationData: landmarkData["locations"] as? [[String: Any]],
122:                     neighborhoodData: neighborhoodData
123:                 )
124: 
125:                 await MainActor.run {
126:                     detectedLandmark = landmark
127:                 }
128: 
129: 
130:                 await handleNeighborhoodUnlock(landmark: landmark)
131: 
132:             } else {
133:                 await MainActor.run {
134:                     detectionResult = "No landmarks detected."
135:                 }
136:             }
137:         } catch {
138:             await MainActor.run {
139:                 detectionResult = "Error: \(error.localizedDescription)"
140:             }
141:         }
142: 
143:         await MainActor.run {
144:             isLoading = false
145:         }
146:     }
147: 
148:     private func handleDetectionResult(_ data: Any) {
149:         guard let dict = data as? [String: Any] else {
150:             handleError("Invalid response format")
151:             return
152:         }
153: 
154:         guard let landmarkData = dict["landmark"] as? [String: Any],
155:               let landmarkName = landmarkData["name"] as? String else {
156:             detectionResult = "No landmarks detected."
157:             isLoading = false
158:             return
159:         }
160: 
161:         let neighborhoodData = landmarkData["neighborhood"] as? [String: Any]
162: 
163:         let landmark = LandmarkInfo(
164:             name: landmarkName,
165:             knowledgeGraphData: landmarkData["knowledgeGraph"] as? [String: Any],
166:             locationData: landmarkData["locations"] as? [[String: Any]],
167:             neighborhoodData: neighborhoodData
168:         )
169: 
170:         detectionResult = landmarkName
171:         detectedLandmark = landmark
172: 
173: 
174:         Task {
175:             await handleNeighborhoodUnlock(landmark: landmark)
176:         }
177:     }
178: 
179:     private func handleError(_ message: String) {
180:         detectionResult = "Error: \(message)"
181:         print("Detection error: \(message)")
182:         isLoading = false
183:     }
184: 
185:     private func handleNeighborhoodUnlock(landmark: LandmarkInfo) async {
186:         guard let neighborhood = landmark.neighborhood else {
187:             await MainActor.run {
188:                 unlockStatus = "No neighborhood found for this landmark"
189:             }
190:             return
191:         }
192: 
193:         guard let neighborhoodId = neighborhood.id else {
194:             await MainActor.run {
195:                 unlockStatus = "Invalid neighborhood ID"
196:             }
197:             return
198:         }
199: 
200:     }
201: 
202:     func updateAppState(_ newAppState: AppState) {
203:         self.appState = newAppState
204:     }
205: }
206: 
207: 
208: struct LandmarkDetailView: View {
209:     let landmark: LandmarkInfo
210: 
211:     var body: some View {
212:         ScrollView {
213:             VStack(alignment: .leading, spacing: 16) {
214:                 if let imageUrl = landmark.imageUrl,
215:                    let url = URL(string: imageUrl) {
216:                     AsyncImage(url: url) { image in
217:                         image
218:                             .resizable()
219:                             .scaledToFit()
220:                     } placeholder: {
221:                         ProgressView()
222:                     }
223:                     .frame(maxHeight: 300)
224:                 }
225: 
226:                 VStack(alignment: .leading, spacing: 12) {
227:                     Text(landmark.name)
228:                         .font(.title)
229:                         .bold()
230: 
231:                     if let description = landmark.description {
232:                         Text(description)
233:                             .font(.subheadline)
234:                     }
235: 
236:                     if let detailedDescription = landmark.detailedDescription {
237:                         Text(detailedDescription)
238:                             .font(.body)
239:                             .padding(.top, 8)
240:                     }
241: 
242:                     if let websiteUrl = landmark.websiteUrl,
243:                        let url = URL(string: websiteUrl) {
244:                         Link("Visit Website", destination: url)
245:                             .padding(.top, 8)
246:                     }
247: 
248:                     if let lat = landmark.latitude,
249:                        let lon = landmark.longitude {
250:                         Text("Location: \(lat), \(lon)")
251:                             .font(.caption)
252:                             .padding(.top, 8)
253:                     }
254:                 }
255:                 .padding()
256:             }
257:         }
258:         .navigationBarTitleDisplayMode(.inline)
259:     }
260: }
261: 
262: struct LandmarkDetectionView: View {
263:     @EnvironmentObject var appState: AppState
264:     @StateObject private var viewModel = LandmarkDetectionViewModel(appState: AppState())
265: 
266: 
267:     @State private var isCameraMode = false
268:     @State private var navigateToLandmark: LandmarkInfo? = nil
269:     @State private var showTransition: Bool = false
270:     @State private var shouldFlash = false
271:     @State private var fadeToBlack = false
272:     @State private var showingGalleryPicker = false
273: 
274:     @Namespace private var scanningNamespace
275: 
276:     var body: some View {
277:         GeometryReader { geometry in
278:             ZStack {
279: 
280:                 Image("discoverbg")
281:                     .resizable()
282:                     .aspectRatio(contentMode: .fill)
283:                     .frame(width: geometry.size.width, height: geometry.size.height + 100)
284:                     .clipped()
285: 
286: 
287:                 Rectangle()
288:                     .fill(.ultraThinMaterial)
289:                     .frame(height: geometry.safeAreaInsets.top)
290:                     .ignoresSafeArea()
291: 
292:                 if isCameraMode {
293: 
294:                     CameraView(
295:                       onFrameCaptured: { image in
296:                         Task {
297:                           await viewModel.detectLandmark(for: image)
298:                           if let landmark = viewModel.detectedLandmark {
299:                             await animateLandmarkDetectionFlow(landmark: landmark)
300:                           }
301:                         }
302:                       },
303:                       shouldFlash: $shouldFlash
304:                     )
305: 
306: 
307: 
308:                     VStack {
309:                       HStack {
310:                         Button(action: {
311:                           isCameraMode = false
312:                         }) {
313:                           Image(systemName: "xmark")
314:                             .font(.title2)
315:                             .foregroundColor(.white)
316:                             .padding(12)
317:                             .background(.ultraThinMaterial)
318:                             .clipShape(Circle())
319:                         }
320:                         .padding(.leading)
321:                         Spacer()
322:                       }
323:                       .padding(.top, geometry.safeAreaInsets.top + 40)
324:                       Spacer()
325:                     }
326: 
327: 
328:                     if showTransition {
329:                       ScanningTransitionView(namespace: scanningNamespace)
330:                         .ignoresSafeArea()
331:                     } else {
332:                       ScanningAnimation(namespace: scanningNamespace)
333:                         .ignoresSafeArea()
334:                     }
335: 
336: 
337:                     if viewModel.detectionResult.contains("Error") {
338:                       VStack {
339:                         Spacer()
340:                         Text(viewModel.detectionResult)
341:                           .foregroundColor(.white)
342:                           .padding()
343:                           .background(.black.opacity(0.6))
344:                           .cornerRadius(10)
345:                           .padding(.bottom, 30)
346:                       }
347:                     }
348: 
349: 
350:                     Color.black
351:                       .opacity(fadeToBlack ? 1.0 : 0.0)
352:                       .ignoresSafeArea()
353:                 } else {
354: 
355:                     ScrollView {
356:                         GeometryReader { scrollGeometry in
357: 
358:                             VStack {
359:                               Spacer(minLength:800)
360: 
361: 
362:                                 VStack(spacing: 16) {
363:                                     Image(systemName: "camera.viewfinder")
364:                                         .font(.system(size: 64))
365:                                         .foregroundColor(Color(.systemYellow))
366: 
367:                                     Text("Discover Your City")
368:                                         .font(.custom("Baskerville-Bold", size: 32))
369:                                         .multilineTextAlignment(.center)
370:                                         .fixedSize(horizontal: false, vertical: true)
371:                                         .frame(maxWidth: .infinity)
372:                                         .padding(.horizontal, 24)
373: 
374:                                     Text("Capture landmarks to unlock neighborhood content and explore local stories")
375:                                         .font(.custom("Baskerville", size: 20))
376:                                         .foregroundColor(.white)
377:                                         .multilineTextAlignment(.center)
378:                                         .fixedSize(horizontal: false, vertical: true)
379:                                         .frame(maxWidth: .infinity)
380:                                         .padding(.horizontal, 24)
381: 
382:                                     Button(action: {
383:                                         isCameraMode = true
384:                                     }) {
385:                                         HStack(spacing: 12) {
386:                                             Image(systemName: "camera.fill")
387:                                                 .font(.title3)
388:                                             Text("Open Camera")
389:                                                 .font(.title3)
390:                                         }
391:                                         .foregroundColor(.black)
392:                                         .frame(maxWidth: .infinity)
393:                                         .padding(.vertical, 16)
394:                                         .background(Color(.systemYellow))
395:                                         .cornerRadius(12)
396:                                     }
397:                                     .padding(.top, 12)
398:                                 }
399:                                 .padding(24)
400:                                 .background(.ultraThinMaterial)
401:                                 .cornerRadius(16)
402:                                 .shadow(radius: 8)
403:                                 .padding()
404: 
405:                                 Spacer(minLength: 0)
406:                             }
407:                             .frame(
408:                                 minWidth: scrollGeometry.size.width,
409:                                 minHeight: scrollGeometry.size.height
410:                             )
411:                         }
412:                     }
413:                 }
414: 
415: #if DEBUG
416: 
417:                 VStack {
418:                   Spacer()
419:                   HStack {
420:                     Spacer()
421:                     Button(action: {
422:                       showingGalleryPicker = true
423:                     }) {
424:                       Image(systemName: "photo.stack")
425:                         .font(.title2)
426:                         .foregroundColor(.white)
427:                         .padding(12)
428:                         .background(.ultraThinMaterial)
429:                         .clipShape(Circle())
430:                     }
431:                     .padding(.trailing, 16)
432:                     .padding(.bottom, 160)
433:                   }
434:                 }
435: #endif
436:             }
437: 
438: 
439:             if let landmark = navigateToLandmark {
440:                 NavigationLink(
441:                     destination: LandmarkDetailView(landmark: landmark),
442:                     isActive: Binding(
443:                         get: { navigateToLandmark != nil },
444:                         set: { if !$0 { navigateToLandmark = nil } }
445:                     )
446:                 ) {
447:                     EmptyView()
448:                 }
449:             }
450:         }
451:         .ignoresSafeArea(.container, edges: [.top])
452:         .sheet(isPresented: $showingGalleryPicker) {
453:             NavigationView {
454:                 ScrollView {
455:                     LazyVGrid(columns: [
456:                         GridItem(.flexible()),
457:                         GridItem(.flexible()),
458:                         GridItem(.flexible())
459:                     ], spacing: 8) {
460:                         ForEach(viewModel.imageNames, id: \.self) { name in
461:                             Image(name)
462:                                 .resizable()
463:                                 .aspectRatio(contentMode: .fill)
464:                                 .frame(height: 120)
465:                                 .clipShape(RoundedRectangle(cornerRadius: 8))
466:                                 .onTapGesture {
467:                                     if let uiImage = UIImage(named: name) {
468:                                         viewModel.selectedImage = uiImage
469:                                         Task {
470:                                             await viewModel.detectLandmark(for: uiImage)
471:                                         }
472:                                         showingGalleryPicker = false
473:                                     }
474:                                 }
475:                         }
476:                     }
477:                     .padding()
478:                 }
479:                 .navigationTitle("Debug Gallery")
480:                 .navigationBarTitleDisplayMode(.inline)
481:                 .toolbar {
482:                     ToolbarItem(placement: .navigationBarTrailing) {
483:                         Button("Done") {
484:                             showingGalleryPicker = false
485:                         }
486:                     }
487:                 }
488:             }
489:         }
490:         .onAppear {
491:             viewModel.updateAppState(appState)
492:         }
493:     }
494: 
495: 
496:     private func animateLandmarkDetectionFlow(landmark: LandmarkInfo) async {
497: 
498:         withAnimation(.easeIn(duration: 0.1)) {
499:             shouldFlash = true
500:         }
501: 
502: 
503:         try? await Task.sleep(nanoseconds: 150_000_000)
504: 
505: 
506:         withAnimation(.easeInOut(duration: 1.0)) {
507:             showTransition = true
508:         }
509: 
510: 
511:         try? await Task.sleep(nanoseconds: 1_000_000_000)
512: 
513: 
514:         withAnimation(.easeIn(duration: 0.5)) {
515:             fadeToBlack = true
516:         }
517: 
518: 
519:         try? await Task.sleep(nanoseconds: 500_000_000)
520: 
521: 
522:         appState.shouldSwitchToFeed = true
523: 
524: 
525:         isCameraMode = false
526: 
527: 
528:         showTransition = false
529:         fadeToBlack = false
530:         shouldFlash = false
531:     }
532: }
533: 
534: struct LandmarkDetectionView_Previews: PreviewProvider {
535:     static var previews: some View {
536:         let previewAppState = AppState()
537:         LandmarkDetectionView()
538:             .environmentObject(previewAppState)
539:     }
540: }
</file>

<file path="sightline/sightline/sightlineApp.swift">
 1: import SwiftUI
 2: import FirebaseCore
 3: 
 4: import FirebaseAuth
 5: 
 6: @main
 7: struct SightlineApp: App {
 8:     @StateObject private var appState = AppState()
 9:     @StateObject private var appViewModel = AppViewModel()
10:     @State private var showingSplash = true
11: 
12:     init() {
13: 
14:         FirebaseApp.configure()
15:     }
16: 
17:     var body: some Scene {
18:         WindowGroup {
19:             ZStack {
20:                 MainTabView()
21:                     .environmentObject(appState)
22:                     .task {
23: 
24:                         do {
25:                             try await ServiceContainer.shared.auth.signInAnonymously()
26: 
27:                             await appViewModel.preloadAppData()
28: 
29:                             withAnimation {
30:                                 showingSplash = false
31:                             }
32:                         } catch {
33:                             print("Failed to initialize app: \(error)")
34: 
35:                             showingSplash = false
36:                         }
37:                     }
38: 
39:                 if showingSplash {
40:                     SplashView {
41: 
42:                     }
43:                     .transition(.opacity)
44:                 }
45:             }
46:         }
47:     }
48: }
</file>

<file path="sightline/sightline.xcodeproj/xcuserdata/chrissutton.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist">
1: <?xml version="1.0" encoding="UTF-8"?>
2: <Bucket
3:    uuid = "D2849DC8-FDC9-410B-B0D8-E42151764F8C"
4:    type = "1"
5:    version = "2.0">
6: </Bucket>
</file>

<file path="sightline/sightline.xcodeproj/xcuserdata/chrissutton.xcuserdatad/xcschemes/xcschememanagement.plist">
 1: <?xml version="1.0" encoding="UTF-8"?>
 2: <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
 3: <plist version="1.0">
 4: <dict>
 5: 	<key>SchemeUserState</key>
 6: 	<dict>
 7: 		<key>sightline.xcscheme_^#shared#^_</key>
 8: 		<dict>
 9: 			<key>orderHint</key>
10: 			<integer>0</integer>
11: 		</dict>
12: 	</dict>
13: </dict>
14: </plist>
</file>

<file path="sightline/sightlineTests/sightlineTests.swift">
 1: import Testing
 2: @testable import sightline
 3: 
 4: struct sightlineTests {
 5: 
 6:     @Test func example() async throws {
 7: 
 8:     }
 9: 
10: }
</file>

<file path="sightline/sightlineUITests/sightlineUITests.swift">
 1: import XCTest
 2: 
 3: final class sightlineUITests: XCTestCase {
 4: 
 5:     override func setUpWithError() throws {
 6: 
 7: 
 8: 
 9:         continueAfterFailure = false
10: 
11: 
12:     }
13: 
14:     override func tearDownWithError() throws {
15: 
16:     }
17: 
18:     @MainActor
19:     func testExample() throws {
20: 
21:         let app = XCUIApplication()
22:         app.launch()
23: 
24: 
25:     }
26: 
27:     @MainActor
28:     func testLaunchPerformance() throws {
29:         if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 7.0, *) {
30: 
31:             measure(metrics: [XCTApplicationLaunchMetric()]) {
32:                 XCUIApplication().launch()
33:             }
34:         }
35:     }
36: }
</file>

<file path="sightline/sightlineUITests/sightlineUITestsLaunchTests.swift">
 1: import XCTest
 2: 
 3: final class sightlineUITestsLaunchTests: XCTestCase {
 4: 
 5:     override class var runsForEachTargetApplicationUIConfiguration: Bool {
 6:         true
 7:     }
 8: 
 9:     override func setUpWithError() throws {
10:         continueAfterFailure = false
11:     }
12: 
13:     @MainActor
14:     func testLaunch() throws {
15:         let app = XCUIApplication()
16:         app.launch()
17: 
18: 
19: 
20: 
21:         let attachment = XCTAttachment(screenshot: app.screenshot())
22:         attachment.name = "Launch Screen"
23:         attachment.lifetime = .keepAlways
24:         add(attachment)
25:     }
26: }
</file>

<file path=".gitignore">
 1: # Firebase build and deployment files
 2: /firebase-debug.log
 3: /firebase-debug.*.log
 4: .firebaserc
 5: 
 6: # Firebase Hosting
 7: /firebase.json
 8: *.cache
 9: hosting/.cache
10: 
11: # Firebase Functions
12: /functions/node_modules/
13: /functions/.env
14: /functions/package-lock.json
15: 
16: # Firebase Emulators
17: /firebase-*.zip
18: /.firebase/
19: /emulator-ui/
20: 
21: # Logs
22: *.log
23: npm-debug.log*
24: yarn-debug.log*
25: yarn-error.log*
26: 
27: # Environment files (local configs)
28: /.env.*
29: .DS_Store
30: .env.*
31: 
32: # Xcode
33: *.pbxproj
34: *.xcworkspace
35: *.xcuserdatadirectory
36: GoogleService-Info.plist
</file>

<file path=".markdownlint.json">
1: {
2:   "MD013": false,
3:   "MD025": false,
4:   "MD033": false,
5:   "MD022": false,
6:   "MD032": false
7: }
</file>

<file path=".repomixignore">
1: # Add patterns to ignore here, one per line
2: # Example:
3: # *.log
4: # tmp/
</file>

<file path="repomix.config.json">
 1: {
 2:   "output": {
 3:     "style": "xml",
 4:     "filePath": "repomix.xml",
 5:     "removeComments": true,
 6:     "showLineNumbers": true,
 7:     "topFilesLength": 10
 8:   },
 9:   "ignore": {
10:     "customPatterns": ["_docs/**"]
11:   }
12: }
</file>

</files>
