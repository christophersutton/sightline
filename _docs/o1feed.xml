<Plan>
1. We want the feed (parent) to be responsible for pausing/resuming videos when swiping.
2. We'll remove the auto-play call in ContentItemView’s loadPlayer(), so it won’t remain paused once we come back.
3. In ContentFeedView’s onIndexChanged, we’ll pause the oldIndex video and play the newIndex video, ensuring a previously viewed video resumes playback.
</Plan>

<file path="sightline/sightline/Views/ContentFeed/ContentFeedView.swift" action="rewrite">
  <change>
    <description>Pause old video and play new video on swipe (back or forward). Force refresh by .id(...) as before.</description>
    <content>
===
import SwiftUI
import UIKit

struct ContentFeedView: View {
    @EnvironmentObject var appState: AppState
    @EnvironmentObject var appStore: AppStore

    @State private var showingNeighborhoods = false
    @State private var showingCategories = false
    @State private var selectedPlaceId: String? = nil

    var body: some View {
        ZStack(alignment: .top) {
            Color.black.ignoresSafeArea()

            contentDisplay
                .zIndex(0)

            menuBar
                .zIndex(2)
        }
        .sheet(item: Binding(
            get: { selectedPlaceId.map { PlaceDetailPresentation(placeId: $0) } },
            set: { presentation in selectedPlaceId = presentation?.placeId }
        )) { presentation in
            PlaceDetailView(placeId: presentation.placeId)
                .presentationDetents([.medium, .large])
                .presentationDragIndicator(.visible)
                .presentationBackgroundInteraction(.enabled)
        }
        .task {
            await appStore.loadUnlockedNeighborhoods()
        }
    }

    @ViewBuilder
    private var contentDisplay: some View {
        if appStore.unlockedNeighborhoods.isEmpty {
            EmptyNeighborhoodState()
        } else if appStore.contentItems.isEmpty {
            Text("No content available")
                .foregroundColor(.white)
        } else {
            feedView
        }
    }

    private var feedView: some View {
        VerticalFeedView(
            currentIndex: $appStore.currentIndex,
            itemCount: appStore.contentItems.count,
            onIndexChanged: { oldIndex, newIndex in
                // 1) Pause the old video
                if oldIndex < appStore.contentItems.count {
                    let oldUrl = appStore.contentItems[oldIndex].videoUrl
                    appStore.videoManager.playerFor(url: oldUrl)?.pause()
                }
                
                // 2) Play the new video
                if newIndex < appStore.contentItems.count {
                    let newUrl = appStore.contentItems[newIndex].videoUrl
                    appStore.videoManager.playerFor(url: newUrl)?.play()
                }
                
                // Update current index
                appStore.currentIndex = newIndex
                
                // Optionally preload more videos around newIndex
                let videoURLs = appStore.contentItems.map { $0.videoUrl }
                appStore.videoManager.preloadVideos(for: videoURLs, at: newIndex)
            }
        ) { index in
            if index < appStore.contentItems.count {
                ContentItemView(content: appStore.contentItems[index])
                    .onTapGesture {
                        let placeIds = appStore.contentItems[index].placeIds
                        if !placeIds.isEmpty {
                            selectedPlaceId = placeIds[0]
                        }
                    }
            } else {
                Color.black
            }
        }
        // Force refresh if category, neighborhood, or items changed:
        .id("\(appStore.selectedNeighborhood?.id ?? "none")_\(appStore.selectedCategory.rawValue)_\(appStore.contentItems.count)")
        .ignoresSafeArea()
    }
  
    private var menuBar: some View {
        HStack(alignment: .top) {
            NeighborhoodSelectorView(
                selectedNeighborhood: $appStore.selectedNeighborhood,
                isExpanded: $showingNeighborhoods,
                onExploreMore: { appState.shouldSwitchToDiscover = true },
                onNeighborhoodSelected: { Task { await appStore.loadContent() } }
            )

            Spacer()

            if let neighborhoodId = appStore.selectedNeighborhood?.id {
                CategorySelectorView(
                    selectedCategory: $appStore.selectedCategory,
                    isExpanded: $showingCategories,
                    onCategorySelected: { Task { await appStore.loadContent() } }
                )
                .id(neighborhoodId)
            } else {
                Text("Select a neighborhood").foregroundColor(.white)
            }
        }
        .padding(.top, 24)
        .padding(.horizontal, 16)
    }
}

struct LoadingState: View {
    var body: some View {
        GeometryReader { geometry in
            VStack(spacing: 16) {
                ProgressView()
                    .scaleEffect(1.5)
                    .tint(.white)
                
                Text("Loading...")
                    .font(.custom("Baskerville", size: 18))
                    .foregroundColor(.white.opacity(0.8))
            }
            .frame(width: geometry.size.width, height: geometry.size.height)
        }
    }
}

struct PlaceDetailPresentation: Identifiable {
    let id = UUID()
    let placeId: String
}
===
    </content>
  </change>
</file>

<file path="sightline/sightline/Views/ContentFeed/ContentItemView.swift" action="rewrite">
  <change>
    <description>Remove auto-play from ContentItemView, letting the parent code handle playback.</description>
    <content>
===
import SwiftUI
import AVKit
import FirebaseStorage

struct ContentItemView: View {
    @EnvironmentObject var appStore: AppStore
    let content: Content
    @State private var player: AVQueuePlayer?
    @State private var isLoading = true
    @State private var error: Error?

    var body: some View {
        GeometryReader { _ in
            ZStack {
                if let player = player {
                    VideoPlayer(player: player)
                        .edgesIgnoringSafeArea(.all)
                } else if isLoading {
                    LoadingView()
                } else {
                    ErrorView()
                }
                ContentOverlay(content: content)
            }
        }
        .onAppear {
            // Just load or fetch the player, do NOT auto-play
            loadPlayer()
        }
        // No need to pause onDisappear if feed is managing it
    }
    
    private func loadPlayer() {
        guard player == nil else { return }
        Task {
            do {
                let newPlayer = try await appStore.videoManager.fetchPlayer(for: content.videoUrl)
                await MainActor.run {
                    player = newPlayer
                    // Don’t automatically play; parent feed controls it
                    isLoading = false
                }
            } catch {
                await MainActor.run {
                    self.error = error
                    isLoading = false
                }
            }
        }
    }
}

private extension EnvironmentValues {
    var safeAreaInsets: EdgeInsets {
        (UIApplication.shared.windows.first?.safeAreaInsets ?? .zero).insets
    }
}

private extension UIEdgeInsets {
    var insets: EdgeInsets {
        EdgeInsets(top: top, leading: left, bottom: bottom, trailing: right)
    }
}

struct ErrorView: View {
    var body: some View {
        VStack {
            Image(systemName: "exclamationmark.triangle")
                .font(.largeTitle)
                .foregroundColor(.yellow)
            Text("Failed to load video")
                .foregroundColor(.white)
        }
    }
}

struct LoadingView: View {
    var body: some View {
        Color.black
        ProgressView()
            .scaleEffect(1.5)
    }
}

struct ContentOverlay: View {
    let content: Content
    @EnvironmentObject var appStore: AppStore
    
    var body: some View {
        VStack {
            Spacer()
            VStack(spacing: 8) {
                HStack {
                    VStack(alignment: .leading, spacing: 8) {
                        Text(content.caption)
                            .font(.headline)
                            .foregroundColor(.white)
                            .multilineTextAlignment(.leading)
                        
                        if let placeId = content.placeIds.first {
                            NavigationLink(value: AppState.NavigationDestination.placeDetail(placeId: placeId, initialContentId: content.id)) {
                                Text(appStore.places[placeId]?.name ?? "Loading place...")
                                    .font(.subheadline)
                                    .foregroundColor(.white)
                                    .padding(.horizontal, 12)
                                    .padding(.vertical, 6)
                                    .background(.ultraThinMaterial)
                                    .cornerRadius(16)
                            }
                        }
                    }
                    Spacer()
                }
                .padding(.horizontal)
                .padding(.bottom, 120)
            }
            .background(
                LinearGradient(
                    gradient: Gradient(colors: [.clear, .black.opacity(0.3)]),
                    startPoint: .top,
                    endPoint: .bottom
                )
                .padding(.top, -100)
            )
        }
    }
}
===
    </content>
  </change>
</file>